
//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

// This is an autogenerated file, we want to ensure that it contains exactly the contents we want to generate
// clang-format off

#ifndef _LIBCUDACXX___ATOMIC_FUNCTIONS_CUDA_PTX_GENERATED_H
#define _LIBCUDACXX___ATOMIC_FUNCTIONS_CUDA_PTX_GENERATED_H

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/cassert>
#include <cuda/std/cstdint>

#include <cuda/std/__type_traits/enable_if.h>
#include <cuda/std/__type_traits/is_signed.h>
#include <cuda/std/__type_traits/is_unsigned.h>

#include <cuda/std/__atomic/scopes.h>
#include <cuda/std/__atomic/order.h>
#include <cuda/std/__atomic/functions/cuda_ptx_generated_helper.h>

enum class __atomic_operand_type
{
  _f,
  _s,
  _u,
  _b,
};

template <__atomic_operand_type, size_t>
struct __atomic_operand_tag
{};

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_b,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.b16 %0,[%1];"
                : "=h"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_u,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.u16 %0,[%1];"
                : "=h"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_s,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.s16 %0,[%1];"
                : "=h"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_b,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.b32 %0,[%1];"
                : "=r"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_f,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.f32 %0,[%1];"
                : "=f"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_u,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.u32 %0,[%1];"
                : "=r"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_s,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.s32 %0,[%1];"
                : "=r"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_b,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.b64 %0,[%1];"
                : "=l"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_f,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.f64 %0,[%1];"
                : "=d"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_u,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.u64 %0,[%1];"
                : "=l"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_load(
  _Type* __ptr, _Type& __dst, __atomic_operand_tag<__atomic_operand_type::_s,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("ld.%2%3%4.s64 %0,[%1];"
                : "=l"(__dst)
                : "l"(__ptr), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_b,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.b16 %0,[%1];"
                :: "l"(__ptr), "h"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_u,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.u16 %0,[%1];"
                :: "l"(__ptr), "h"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_s,16>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.s16 %0,[%1];"
                :: "l"(__ptr), "h"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_b,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.b32 %0,[%1];"
                :: "l"(__ptr), "r"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_f,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.f32 %0,[%1];"
                :: "l"(__ptr), "f"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_u,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.u32 %0,[%1];"
                :: "l"(__ptr), "r"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_s,32>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.s32 %0,[%1];"
                :: "l"(__ptr), "r"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_b,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.b64 %0,[%1];"
                :: "l"(__ptr), "l"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_f,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.f64 %0,[%1];"
                :: "l"(__ptr), "d"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_u,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.u64 %0,[%1];"
                :: "l"(__ptr), "l"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Mmio, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_store(
  _Type* __ptr, _Type __val, __atomic_operand_tag<__atomic_operand_type::_s,64>, _Mmio, _Scope, _Memorder)
{
  asm volatile("st.%2%3%4.s64 %0,[%1];"
                :: "l"(__ptr), "l"(__val), "C"(_Mmio::value), "C"(_Scope::value), "C"(_Memorder::value)
                 : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,32>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.b32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,32>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.f32 %0,[%1],%2;"
                : "=f"(__dst)
                : "l"(__ptr), "f"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,32>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.s32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,32>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.u32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,64>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.b64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,64>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.f64 %0,[%1],%2;"
                : "=d"(__dst)
                : "l"(__ptr), "d"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,64>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.s64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_exchange(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,64>, _Scope, _Memorder)
{
  asm volatile("atom.exch.%3%4.u64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,16>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.b16 %0,[%1],%2,%3;"
                : "=h"(__dst)
                : "l"(__ptr), "h"(__cmp), "h"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,32>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.b32 %0,[%1],%2,%3;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__cmp), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,32>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.f32 %0,[%1],%2,%3;"
                : "=f"(__dst)
                : "l"(__ptr), "f"(__cmp), "f"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,32>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.s32 %0,[%1],%2,%3;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__cmp), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,32>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.u32 %0,[%1],%2,%3;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__cmp), "r"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,64>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.b64 %0,[%1],%2,%3;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__cmp), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,64>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.f64 %0,[%1],%2,%3;"
                : "=d"(__dst)
                : "l"(__ptr), "d"(__cmp), "d"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,64>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.s64 %0,[%1],%2,%3;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__cmp), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_compare_exchange(
  _Type* __ptr, _Type& __dst, _Type __cmp, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,64>, _Scope, _Memorder)
{
  asm volatile("atom.cas.%4%5.u64 %0,[%1],%2,%3;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__cmp), "l"(__op), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,32>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.b32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,32>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.f32 %0,[%1],%2;"
                : "=f"(__dst)
                : "l"(__ptr), "f"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,32>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.u32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,32>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.s32 %0,[%1],%2;"
                : "=r"(__dst)
                : "l"(__ptr), "r"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_b,64>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.b64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_f,64>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.f64 %0,[%1],%2;"
                : "=d"(__dst)
                : "l"(__ptr), "d"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_u,64>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.u64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

template <class _Type, class _Op, class _Scope, class _Memorder>
static inline _CCCL_DEVICE void __cuda_atomic_fetch(
  _Type* __ptr, _Type& __dst, _Type __op, __atomic_operand_tag<__atomic_operand_type::_s,64>, _Op, _Scope, _Memorder)
{
  asm volatile("atom.%3%4%5.s64 %0,[%1],%2;"
                : "=l"(__dst)
                : "l"(__ptr), "l"(__op), "C"(_Op::value), "C"(_Scope::value), "C"(_Memorder::value)
                : "memory");
}

#endif // defined(_CCCL_CUDA_COMPILER)

_LIBCUDACXX_END_NAMESPACE_STD

#endif // _LIBCUDACXX___ATOMIC_FUNCTIONS_CUDA_PTX_GENERATED_H

// clang-format on
