// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_EXCEPTION
#define _LIBCUDACXX_EXCEPTION

/*
    exception synopsis

namespace std
{

class exception
{
public:
    exception() noexcept;
    exception(const exception&) noexcept;
    exception& operator=(const exception&) noexcept;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class bad_exception
    : public exception
{
public:
    bad_exception() noexcept;
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
unexpected_handler get_unexpected() noexcept;
[[noreturn]] void unexpected();

typedef void (*terminate_handler)();
terminate_handler set_terminate(terminate_handler  f ) noexcept;
terminate_handler get_terminate() noexcept;
[[noreturn]] void terminate() noexcept;

bool uncaught_exception()  noexcept;
int  uncaught_exceptions() noexcept;  // C++17

typedef unspecified exception_ptr;

exception_ptr current_exception() noexcept;
void rethrow_exception [[noreturn]] (exception_ptr p);
template<class E> exception_ptr make_exception_ptr(E e) noexcept;

class nested_exception
{
public:
    nested_exception() noexcept;
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    exception_ptr nested_ptr() const noexcept;
};

template <class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}  // std

*/

#ifndef __cuda_std__
#  include <__config>
#endif //__cuda_std__

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/cstddef>
#include <cuda/std/detail/libcxx/include/__assert>  // all public C++ headers provide the assertion handler
#include <cuda/std/detail/libcxx/include/__exception/exception.h>
#include <cuda/std/detail/libcxx/include/__exception/terminate.h>
#include <cuda/std/detail/libcxx/include/cstdlib>
#include <cuda/std/type_traits>
#include <cuda/std/version>

#if defined(_LIBCUDACXX_ABI_VCRUNTIME)
#include <vcruntime_exception.h>
#endif

_LIBCUDACXX_BEGIN_NAMESPACE_STD_NOVERSION // purposefully not using versioning namespace

// nested_exception

class _LIBCUDACXX_EXCEPTION_ABI nested_exception
{
    exception_ptr __ptr_;
public:
    _LIBCUDACXX_HOST_DEVICE nested_exception() noexcept;
//     nested_exception(const nested_exception&) noexcept = default;
//     nested_exception& operator=(const nested_exception&) noexcept = default;
    _LIBCUDACXX_HOST_DEVICE virtual ~nested_exception() noexcept;

    // access functions
    _LIBCUDACXX_NORETURN _LIBCUDACXX_HOST_DEVICE void rethrow_nested() const;
    _LIBCUDACXX_INLINE_VISIBILITY exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    _LIBCUDACXX_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

#ifndef _LIBCUDACXX_NO_EXCEPTIONS
template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    _LIBCUDACXX_NORETURN static inline _LIBCUDACXX_INLINE_VISIBILITY void
    __do_throw(_Tp&& __t)
    {
        throw __nested<_Up>(_CUDA_VSTD::forward<_Tp>(__t));
    }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    _LIBCUDACXX_NORETURN static inline _LIBCUDACXX_INLINE_VISIBILITY void
    __do_throw(_Tp&& __t)
    {
        throw _CUDA_VSTD::forward<_Tp>(__t);
    }
};
#endif

template <class _Tp>
_LIBCUDACXX_NORETURN inline _LIBCUDACXX_INLINE_VISIBILITY
void
throw_with_nested(_Tp&& __t)
{
#ifndef _LIBCUDACXX_NO_EXCEPTIONS
    typedef __decay_t<_Tp> _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(_CUDA_VSTD::forward<_Tp>(__t));
#else
    ((void)__t);
    // FIXME: Make this abort
#endif
}

template <class _From, class _To>
struct __can_dynamic_cast : public
    _LIBCUDACXX_BOOL_CONSTANT(
              is_polymorphic<_From>::value &&
                 (!is_base_of<_To, _From>::value ||
                   is_convertible<const _From*, const _To*>::value))
{};

template <class _Ep>
inline _LIBCUDACXX_INLINE_VISIBILITY
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
#if !defined(_CCCL_COMPILER_MSVC)
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(_CUDA_VSTD::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
#endif // _CCCL_COMPILER_MSVC
}

template <class _Ep>
inline _LIBCUDACXX_INLINE_VISIBILITY
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

_LIBCUDACXX_END_NAMESPACE_STD_NOVERSION

#endif  // _LIBCUDACXX_EXCEPTION
