// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_EXCEPTION
#define _LIBCUDACXX_EXCEPTION

/*
    exception synopsis

namespace std
{

class exception
{
public:
    exception() noexcept;
    exception(const exception&) noexcept;
    exception& operator=(const exception&) noexcept;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class bad_exception
    : public exception
{
public:
    bad_exception() noexcept;
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
unexpected_handler get_unexpected() noexcept;
[[noreturn]] void unexpected();

typedef void (*terminate_handler)();
terminate_handler set_terminate(terminate_handler  f ) noexcept;
terminate_handler get_terminate() noexcept;
[[noreturn]] void terminate() noexcept;

bool uncaught_exception()  noexcept;
int  uncaught_exceptions() noexcept;  // C++17

typedef unspecified exception_ptr;

exception_ptr current_exception() noexcept;
void rethrow_exception [[noreturn]] (exception_ptr p);
template<class E> exception_ptr make_exception_ptr(E e) noexcept;

class nested_exception
{
public:
    nested_exception() noexcept;
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    exception_ptr nested_ptr() const noexcept;
};

template <class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}  // std

*/

#ifndef __cuda_std__
#include <__config>
#endif //__cuda_std__

#include "__exception/exception_ptr.h"
#include "__exception/exception.h"
#include "__exception/nested_exception.h"
#include "__exception/operations.h"
#include "__exception/terminate.h"

#include "cstddef"
#include "cstdlib"
#include "type_traits"
#include "version"

#if defined(_LIBCUDACXX_ABI_VCRUNTIME)
#include <vcruntime_exception.h>
#endif

#if defined(_LIBCUDACXX_USE_PRAGMA_GCC_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCUDACXX_BEGIN_NAMESPACE_STD_NOVERSION // purposefully not using versioning namespace

_LIBCUDACXX_END_NAMESPACE_STD_NOVERSION

#endif  // _LIBCUDACXX_EXCEPTION
