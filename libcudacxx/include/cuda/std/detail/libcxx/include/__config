//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_CONFIG
#define _LIBCUDACXX_CONFIG

#include <cuda/__cccl_config> // IWYU pragma: export

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/__internal/atomic.h>
#include <cuda/std/__internal/cpp_dialect.h>
#include <cuda/std/__internal/features.h>
#include <cuda/std/__internal/namespaces.h>
#include <cuda/std/__internal/thread_api.h>

#ifdef __cplusplus

// __config may be included in `extern "C"` contexts, switch back to include <nv/target>
extern "C++" {
#  include <nv/target>
}

#  define _LIBCUDACXX_VERSION 10000

#  if !defined(_LIBCUDACXX_DISABLE_ADDITIONAL_DIAGNOSTICS)
#    define _LIBCUDACXX_DIAGNOSE_WARNING(_COND, _MSG) _CCCL_DIAGNOSE_IF(_COND, _MSG, "warning")
#    define _LIBCUDACXX_DIAGNOSE_ERROR(_COND, _MSG)   _CCCL_DIAGNOSE_IF(_COND, _MSG, "error")
#  else
#    define _LIBCUDACXX_DIAGNOSE_WARNING(_COND, _MSG)
#    define _LIBCUDACXX_DIAGNOSE_ERROR(_COND, _MSG)
#  endif

#  if defined(_LIBCUDACXX_ENABLE_CXX17_REMOVED_FEATURES)
#    define _LIBCUDACXX_ENABLE_CXX17_REMOVED_AUTO_PTR
#    define _LIBCUDACXX_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS
#    define _LIBCUDACXX_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE
#    define _LIBCUDACXX_ENABLE_CXX17_REMOVED_BINDERS
#  endif // _LIBCUDACXX_ENABLE_CXX17_REMOVED_FEATURES

// NVRTC has a bug that prevented the use of delegated constructors, as it did not accept execution space annotations.
// This creates a whole lot of boilerplate that we can avoid through a macro (see nvbug3961621)
#  if _CCCL_COMPILER(NVRTC, <, 12, 6)
#    define _LIBCUDACXX_DELEGATE_CONSTRUCTORS(__class, __baseclass, ...)                                          \
      using __base = __baseclass<__VA_ARGS__>;                                                                    \
      _CCCL_TEMPLATE(class... _Args)                                                                              \
      _CCCL_REQUIRES(::cuda::std::is_constructible_v<__base, _Args...>)                                           \
      _CCCL_API constexpr __class(_Args&&... __args) noexcept(                                                    \
        ::cuda::std::is_nothrow_constructible_v<__base, _Args...>)                                                \
          : __base(::cuda::std::forward<_Args>(__args)...)                                                        \
      {}                                                                                                          \
      _CCCL_HIDE_FROM_ABI constexpr __class() noexcept(::cuda::std::is_nothrow_default_constructible_v<__base>) = \
        default;
#  else // ^^^ workaround ^^^ / vvv no workaround vvv
#    define _LIBCUDACXX_DELEGATE_CONSTRUCTORS(__class, __baseclass, ...)                                          \
      using __base = __baseclass<__VA_ARGS__>;                                                                    \
      using __base::__base;                                                                                       \
      _CCCL_HIDE_FROM_ABI constexpr __class() noexcept(::cuda::std::is_nothrow_default_constructible_v<__base>) = \
        default;
#  endif // ^^^ no workaround ^^^

#endif // __cplusplus

#endif // _LIBCUDACXX_CONFIG
