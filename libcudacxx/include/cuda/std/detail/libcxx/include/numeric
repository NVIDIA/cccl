// -*- C++ -*-
//===---------------------------- numeric ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_NUMERIC
#define _LIBCUDACXX_NUMERIC

/*
    numeric synopsis

namespace std
{

#ifndef __cuda_std__
template <class InputIterator, class T>
    T
    accumulate(InputIterator first, InputIterator last, T init);

template <class InputIterator, class T, class BinaryOperation>
    T
    accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);

template<class InputIterator>
    typename iterator_traits<InputIterator>::value_type
    reduce(InputIterator first, InputIterator last);  // C++17

template<class InputIterator, class T>
    T
    reduce(InputIterator first, InputIterator last, T init);  // C++17

template<class InputIterator, class T, class BinaryOperation>
    T
    reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);  // C++17

template <class InputIterator1, class InputIterator2, class T>
    T
    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);

template <class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>
    T
    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
                  T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);


template<class InputIterator1, class InputIterator2, class T>
    T
    transform_reduce(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, T init);  // C++17

template<class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>
    T
    transform_reduce(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, T init,
                     BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);  // C++17

template<class InputIterator, class T, class BinaryOperation, class UnaryOperation>
    T
    transform_reduce(InputIterator first, InputIterator last, T init,
                     BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template <class InputIterator, class OutputIterator>
    OutputIterator
    partial_sum(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator
    partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);

template<class InputIterator, class OutputIterator, class T>
    OutputIterator
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init); // C++17

template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
    OutputIterator
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init, BinaryOperation binary_op); // C++17

template<class InputIterator, class OutputIterator>
    OutputIterator
    inclusive_scan(InputIterator first, InputIterator last, OutputIterator result);  // C++17

template<class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op);  // C++17

template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
    OutputIterator
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op, T init);  // C++17

template<class InputIterator, class OutputIterator, class T,
         class BinaryOperation, class UnaryOperation>
    OutputIterator
    transform_exclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result, T init,
                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation>
    OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation, class T>
    OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);  // C++17

template <class InputIterator, class OutputIterator>
    OutputIterator
    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator
    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);
#endif // __cuda_std__

template <class ForwardIterator, class T>
    void iota(ForwardIterator first, ForwardIterator last, T value);

#ifndef __cuda_std__
template <class M, class N>
    constexpr common_type_t<M,N> gcd(M m, N n);    // C++17

template <class M, class N>
    constexpr common_type_t<M,N> lcm(M m, N n);    // C++17
#endif // __cuda_std__

integer         midpoint(integer a, integer b);                  // C++20
pointer         midpoint(pointer a, pointer b);                  // C++20
floating_point  midpoint(floating_point a, floating_point b);    // C++20

}  // std

*/

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/__iterator/iterator_traits.h>
#include <cuda/std/__numeric/accumulate.h>
#include <cuda/std/__numeric/exclusive_scan.h>
#include <cuda/std/__numeric/inclusive_scan.h>
#include <cuda/std/__numeric/inner_product.h>
#include <cuda/std/__numeric/partial_sum.h>
#include <cuda/std/__numeric/reduce.h>
#include <cuda/std/__numeric/transform_exclusive_scan.h>
#include <cuda/std/__numeric/transform_inclusive_scan.h>
#include <cuda/std/__numeric/transform_reduce.h>
#include <cuda/std/__utility/move.h>
#include <cuda/std/cmath> // for isnormal
#include <cuda/std/detail/libcxx/include/__assert> // all public C++ headers provide the assertion handler
#include <cuda/std/detail/libcxx/include/__pragma_push>
#include <cuda/std/functional>
#include <cuda/std/limits> // for numeric_limits
#include <cuda/std/version>

_LIBCUDACXX_BEGIN_NAMESPACE_STD

#ifndef __cuda_std__

template <class _InputIterator, class _OutputIterator>
inline _LIBCUDACXX_INLINE_VISIBILITY _OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
  if (__first != __last)
  {
    typename iterator_traits<_InputIterator>::value_type __t1(*__first);
    *__result = __t1;
    for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
    {
      typename iterator_traits<_InputIterator>::value_type __t2(*__first);
      *__result = __t2 - __t1;
      __t1      = _CUDA_VSTD::move(__t2);
    }
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
inline _LIBCUDACXX_INLINE_VISIBILITY _OutputIterator adjacent_difference(
  _InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)
{
  if (__first != __last)
  {
    typename iterator_traits<_InputIterator>::value_type __t1(*__first);
    *__result = __t1;
    for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
    {
      typename iterator_traits<_InputIterator>::value_type __t2(*__first);
      *__result = __binary_op(__t2, __t1);
      __t1      = _CUDA_VSTD::move(__t2);
    }
  }
  return __result;
}
#endif // __cuda_std__

template <class _ForwardIterator, class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _CCCL_CONSTEXPR_CXX14 void
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_)
{
  for (; __first != __last; ++__first, (void) ++__value_)
  {
    *__first = __value_;
  }
}

#ifndef __cuda_std__
#  if _CCCL_STD_VER > 2014
template <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value>
struct __ct_abs;

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, true>
{
  constexpr _LIBCUDACXX_INLINE_VISIBILITY _Result operator()(_Source __t) const noexcept
  {
    if (__t >= 0)
    {
      return __t;
    }
    if (__t == numeric_limits<_Source>::min())
    {
      return -static_cast<_Result>(__t);
    }
    return -__t;
  }
};

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, false>
{
  constexpr _LIBCUDACXX_INLINE_VISIBILITY _Result operator()(_Source __t) const noexcept
  {
    return __t;
  }
};

template <class _Tp>
constexpr _LIBCUDACXX_HIDDEN _Tp __gcd(_Tp __m, _Tp __n)
{
  static_assert((!is_signed<_Tp>::value), "");
  return __n == 0 ? __m : _CUDA_VSTD::__gcd<_Tp>(__n, __m % __n);
}

template <class _Tp, class _Up>
constexpr _LIBCUDACXX_INLINE_VISIBILITY common_type_t<_Tp, _Up> gcd(_Tp __m, _Up __n)
{
  static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to gcd must be integer types");
  static_assert((!is_same<__remove_cv_t<_Tp>, bool>::value), "First argument to gcd cannot be bool");
  static_assert((!is_same<__remove_cv_t<_Up>, bool>::value), "Second argument to gcd cannot be bool");
  using _Rp = common_type_t<_Tp, _Up>;
  using _Wp = make_unsigned_t<_Rp>;
  return static_cast<_Rp>(
    _CUDA_VSTD::__gcd(static_cast<_Wp>(__ct_abs<_Rp, _Tp>()(__m)), static_cast<_Wp>(__ct_abs<_Rp, _Up>()(__n))));
}

template <class _Tp, class _Up>
constexpr _LIBCUDACXX_INLINE_VISIBILITY common_type_t<_Tp, _Up> lcm(_Tp __m, _Up __n)
{
  static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to lcm must be integer types");
  static_assert((!is_same<__remove_cv_t<_Tp>, bool>::value), "First argument to lcm cannot be bool");
  static_assert((!is_same<__remove_cv_t<_Up>, bool>::value), "Second argument to lcm cannot be bool");
  if (__m == 0 || __n == 0)
  {
    return 0;
  }

  using _Rp  = common_type_t<_Tp, _Up>;
  _Rp __val1 = __ct_abs<_Rp, _Tp>()(__m) / _CUDA_VSTD::gcd(__m, __n);
  _Rp __val2 = __ct_abs<_Rp, _Up>()(__n);
  _LIBCUDACXX_ASSERT((numeric_limits<_Rp>::max() / __val1 > __val2), "Overflow in lcm");
  return __val1 * __val2;
}

#  endif /* _CCCL_STD_VER > 2014 */

#  if _CCCL_STD_VER > 2017
template <class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY constexpr enable_if_t<
  is_integral_v<_Tp> && !is_same_v<bool, _Tp> && !is_null_pointer_v<_Tp>,
  _Tp>
midpoint(_Tp __a, _Tp __b) noexcept _LIBCUDACXX_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
{
  using _Up = std::make_unsigned_t<_Tp>;

  int __sign = 1;
  _Up __m    = __a;
  _Up __M    = __b;
  if (__a > __b)
  {
    __sign = -1;
    __m    = __b;
    __M    = __a;
  }
  return __a + __sign * _Tp(_Up(__M - __m) >> 1);
}

template <class _TPtr>
_LIBCUDACXX_INLINE_VISIBILITY constexpr enable_if_t<
  is_pointer_v<_TPtr> && is_object_v<remove_pointer_t<_TPtr>> && !is_void_v<remove_pointer_t<_TPtr>>
    && (sizeof(remove_pointer_t<_TPtr>) > 0),
  _TPtr>
midpoint(_TPtr __a, _TPtr __b) noexcept
{
  return __a + _CUDA_VSTD::midpoint(ptrdiff_t(0), __b - __a);
}

template <typename _Tp>
constexpr int __sign(_Tp __val)
{
  return (_Tp(0) < __val) - (__val < _Tp(0));
}

template <typename _Fp>
constexpr _Fp __fp_abs(_Fp __f)
{
  return __f >= 0 ? __f : -__f;
}

template <class _Fp>
_LIBCUDACXX_INLINE_VISIBILITY constexpr enable_if_t<is_floating_point_v<_Fp>, _Fp> midpoint(_Fp __a, _Fp __b) noexcept
{
  constexpr _Fp __lo = numeric_limits<_Fp>::min() * 2;
  constexpr _Fp __hi = numeric_limits<_Fp>::max() / 2;
  return __fp_abs(__a) <= __hi && __fp_abs(__b) <= __hi
         ? // typical case: overflow is impossible
           (__a + __b) / 2
         : // always correctly rounded
           __fp_abs(__a) < __lo ? __a + __b / 2 : // not safe to halve a
             __fp_abs(__a) < __lo ? __a / 2 + __b
                                  : // not safe to halve b
             __a / 2 + __b / 2; // otherwise correctly rounded
}

#  endif // _CCCL_STD_VER > 2017
#endif // __cuda_std__

_LIBCUDACXX_END_NAMESPACE_STD

#if defined(_LIBCUDACXX_HAS_PARALLEL_ALGORITHMS) && _CCCL_STD_VER >= 2017
#  include <__pstl_numeric>
#endif

#include <cuda/std/detail/libcxx/include/__pragma_pop> //__cuda_std__

#endif // _LIBCUDACXX_NUMERIC
