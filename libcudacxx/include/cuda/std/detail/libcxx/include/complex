// -*- C++ -*-
//===--------------------------- complex ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_COMPLEX
#define _LIBCUDACXX_COMPLEX

/*
    complex synopsis

namespace std
{

template<class T>
class complex
{
public:
    typedef T value_type;

    complex(const T& re = T(), const T& im = T()); // constexpr in C++14
    complex(const complex&);  // constexpr in C++14
    template<class X> complex(const complex<X>&);  // constexpr in C++14

    T real() const; // constexpr in C++14
    T imag() const; // constexpr in C++14

    void real(T); // constexpr in C++20
    void imag(T); // constexpr in C++20

    complex<T>& operator= (const T&); // constexpr in C++20
    complex<T>& operator+=(const T&); // constexpr in C++20
    complex<T>& operator-=(const T&); // constexpr in C++20
    complex<T>& operator*=(const T&); // constexpr in C++20
    complex<T>& operator/=(const T&); // constexpr in C++20

    complex& operator=(const complex&); // constexpr in C++20
    template<class X> complex<T>& operator= (const complex<X>&); // constexpr in C++20
    template<class X> complex<T>& operator+=(const complex<X>&); // constexpr in C++20
    template<class X> complex<T>& operator-=(const complex<X>&); // constexpr in C++20
    template<class X> complex<T>& operator*=(const complex<X>&); // constexpr in C++20
    template<class X> complex<T>& operator/=(const complex<X>&); // constexpr in C++20
};

template<>
class complex<float>
{
public:
    typedef float value_type;

    constexpr complex(float re = 0.0f, float im = 0.0f);
    explicit constexpr complex(const complex<double>&);
    explicit constexpr complex(const complex<long double>&);

    constexpr float real() const;
    void real(float); // constexpr in C++20
    constexpr float imag() const;
    void imag(float); // constexpr in C++20

    complex<float>& operator= (float); // constexpr in C++20
    complex<float>& operator+=(float); // constexpr in C++20
    complex<float>& operator-=(float); // constexpr in C++20
    complex<float>& operator*=(float); // constexpr in C++20
    complex<float>& operator/=(float); // constexpr in C++20

    complex<float>& operator=(const complex<float>&); // constexpr in C++20
    template<class X> complex<float>& operator= (const complex<X>&); // constexpr in C++20
    template<class X> complex<float>& operator+=(const complex<X>&); // constexpr in C++20
    template<class X> complex<float>& operator-=(const complex<X>&); // constexpr in C++20
    template<class X> complex<float>& operator*=(const complex<X>&); // constexpr in C++20
    template<class X> complex<float>& operator/=(const complex<X>&); // constexpr in C++20
};

template<>
class complex<double>
{
public:
    typedef double value_type;

    constexpr complex(double re = 0.0, double im = 0.0);
    constexpr complex(const complex<float>&);
    explicit constexpr complex(const complex<long double>&);

    constexpr double real() const;
    void real(double); // constexpr in C++20
    constexpr double imag() const;
    void imag(double); // constexpr in C++20

    complex<double>& operator= (double); // constexpr in C++20
    complex<double>& operator+=(double); // constexpr in C++20
    complex<double>& operator-=(double); // constexpr in C++20
    complex<double>& operator*=(double); // constexpr in C++20
    complex<double>& operator/=(double); // constexpr in C++20
    complex<double>& operator=(const complex<double>&); // constexpr in C++20

    template<class X> complex<double>& operator= (const complex<X>&); // constexpr in C++20
    template<class X> complex<double>& operator+=(const complex<X>&); // constexpr in C++20
    template<class X> complex<double>& operator-=(const complex<X>&); // constexpr in C++20
    template<class X> complex<double>& operator*=(const complex<X>&); // constexpr in C++20
    template<class X> complex<double>& operator/=(const complex<X>&); // constexpr in C++20
};

template<>
class complex<long double>
{
public:
    typedef long double value_type;

    constexpr complex(long double re = 0.0L, long double im = 0.0L);
    constexpr complex(const complex<float>&);
    constexpr complex(const complex<double>&);

    constexpr long double real() const;
    void real(long double); // constexpr in C++20
    constexpr long double imag() const;
    void imag(long double); // constexpr in C++20

    complex<long double>& operator=(const complex<long double>&); // constexpr in C++20
    complex<long double>& operator= (long double); // constexpr in C++20
    complex<long double>& operator+=(long double); // constexpr in C++20
    complex<long double>& operator-=(long double); // constexpr in C++20
    complex<long double>& operator*=(long double); // constexpr in C++20
    complex<long double>& operator/=(long double); // constexpr in C++20

    template<class X> complex<long double>& operator= (const complex<X>&); // constexpr in C++20
    template<class X> complex<long double>& operator+=(const complex<X>&); // constexpr in C++20
    template<class X> complex<long double>& operator-=(const complex<X>&); // constexpr in C++20
    template<class X> complex<long double>& operator*=(const complex<X>&); // constexpr in C++20
    template<class X> complex<long double>& operator/=(const complex<X>&); // constexpr in C++20
};

// 26.3.6 operators:
template<class T> complex<T> operator+(const complex<T>&, const complex<T>&); // constexpr in C++20
template<class T> complex<T> operator+(const complex<T>&, const T&);          // constexpr in C++20
template<class T> complex<T> operator+(const T&, const complex<T>&);          // constexpr in C++20
template<class T> complex<T> operator-(const complex<T>&, const complex<T>&); // constexpr in C++20
template<class T> complex<T> operator-(const complex<T>&, const T&);          // constexpr in C++20
template<class T> complex<T> operator-(const T&, const complex<T>&);          // constexpr in C++20
template<class T> complex<T> operator*(const complex<T>&, const complex<T>&); // constexpr in C++20
template<class T> complex<T> operator*(const complex<T>&, const T&);          // constexpr in C++20
template<class T> complex<T> operator*(const T&, const complex<T>&);          // constexpr in C++20
template<class T> complex<T> operator/(const complex<T>&, const complex<T>&); // constexpr in C++20
template<class T> complex<T> operator/(const complex<T>&, const T&);          // constexpr in C++20
template<class T> complex<T> operator/(const T&, const complex<T>&);          // constexpr in C++20
template<class T> complex<T> operator+(const complex<T>&);                    // constexpr in C++20
template<class T> complex<T> operator-(const complex<T>&);                    // constexpr in C++20
template<class T> bool operator==(const complex<T>&, const complex<T>&); // constexpr in C++14
template<class T> bool operator==(const complex<T>&, const T&); // constexpr in C++14
template<class T> bool operator==(const T&, const complex<T>&); // constexpr in C++14
template<class T> bool operator!=(const complex<T>&, const complex<T>&); // constexpr in C++14
template<class T> bool operator!=(const complex<T>&, const T&); // constexpr in C++14
template<class T> bool operator!=(const T&, const complex<T>&); // constexpr in C++14

template<class T, class charT, class traits>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>&, complex<T>&);
template<class T, class charT, class traits>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>&, const complex<T>&);

// 26.3.7 values:

template<class T>              T real(const complex<T>&); // constexpr in C++14
                     long double real(long double);       // constexpr in C++14
                          double real(double);            // constexpr in C++14
template<Integral T>      double real(T);                 // constexpr in C++14
                          float  real(float);             // constexpr in C++14

template<class T>              T imag(const complex<T>&); // constexpr in C++14
                     long double imag(long double);       // constexpr in C++14
                          double imag(double);            // constexpr in C++14
template<Integral T>      double imag(T);                 // constexpr in C++14
                          float  imag(float);             // constexpr in C++14

template<class T> T abs(const complex<T>&);

template<class T>              T arg(const complex<T>&);
                     long double arg(long double);
                          double arg(double);
template<Integral T>      double arg(T);
                          float  arg(float);

template<class T>              T norm(const complex<T>&); // constexpr in C++20
                     long double norm(long double);       // constexpr in C++20
                          double norm(double);            // constexpr in C++20
template<Integral T>      double norm(T);                 // constexpr in C++20
                          float  norm(float);             // constexpr in C++20

template<class T>      complex<T>           conj(const complex<T>&); // constexpr in C++20
                       complex<long double> conj(long double);       // constexpr in C++20
                       complex<double>      conj(double);            // constexpr in C++20
template<Integral T>   complex<double>      conj(T);                 // constexpr in C++20
                       complex<float>       conj(float);             // constexpr in C++20

template<class T>    complex<T>           proj(const complex<T>&);
                     complex<long double> proj(long double);
                     complex<double>      proj(double);
template<Integral T> complex<double>      proj(T);
                     complex<float>       proj(float);

template<class T> complex<T> polar(const T&, const T& = T());

// 26.3.8 transcendentals:
template<class T> complex<T> acos(const complex<T>&);
template<class T> complex<T> asin(const complex<T>&);
template<class T> complex<T> atan(const complex<T>&);
template<class T> complex<T> acosh(const complex<T>&);
template<class T> complex<T> asinh(const complex<T>&);
template<class T> complex<T> atanh(const complex<T>&);
template<class T> complex<T> cos (const complex<T>&);
template<class T> complex<T> cosh (const complex<T>&);
template<class T> complex<T> exp (const complex<T>&);
template<class T> complex<T> log (const complex<T>&);
template<class T> complex<T> log10(const complex<T>&);

template<class T> complex<T> pow(const complex<T>&, const T&);
template<class T> complex<T> pow(const complex<T>&, const complex<T>&);
template<class T> complex<T> pow(const T&, const complex<T>&);

template<class T> complex<T> sin (const complex<T>&);
template<class T> complex<T> sinh (const complex<T>&);
template<class T> complex<T> sqrt (const complex<T>&);
template<class T> complex<T> tan (const complex<T>&);
template<class T> complex<T> tanh (const complex<T>&);

}  // std

*/

#ifndef __cuda_std__
#include <__config>
#include <stdexcept>
#if !defined(_LIBCUDACXX_HAS_NO_LOCALIZATION)
#   include <sstream> // for _CUDA_VSTD::basic_ostringstream
#endif
#endif // __cuda_std__

#include "__assert" // all public C++ headers provide the assertion handler
#include "__type_traits/enable_if.h"
#include "__type_traits/is_arithmetic.h"
#include "__type_traits/is_floating_point.h"
#include "__type_traits/is_integral.h"
#include "__type_traits/is_same.h"
#include "__type_traits/promote.h"
#include "climits"
#include "cmath"
#include "cstdint"
#include "type_traits"
#include "version"

// Compatability helpers for thrust to convert between `std::complex` and `cuda::std::complex`
#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
#include <complex>

#define _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__c) reinterpret_cast<const _Up (&)[2]>(__c)[0]
#define _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__c) reinterpret_cast<const _Up (&)[2]>(__c)[1]
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

#ifndef __cuda_std__
#include <__pragma_push>
#endif // __cuda_std__

#if defined(_LIBCUDACXX_USE_PRAGMA_GCC_SYSTEM_HEADER)
#pragma GCC system_header
#endif

# if _LIBCUDACXX_CUDA_ABI_VERSION > 3
#  define _LIBCUDACXX_COMPLEX_ALIGNAS(V) _ALIGNAS(V)
# else
#  define _LIBCUDACXX_COMPLEX_ALIGNAS(V)
# endif

#ifdef LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_OPERATIONS
#  ifndef LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_MULTIPLICATION
#    define LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_MULTIPLICATION
#  endif // LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_MULTIPLICATION
#  ifndef LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_DIVISION
#    define LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_DIVISION
#  endif // LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_DIVISION
#endif // LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_OPERATIONS

_LIBCUDACXX_BEGIN_NAMESPACE_STD

template<class _Tp> class _LIBCUDACXX_TEMPLATE_VIS _LIBCUDACXX_COMPLEX_ALIGNAS(2*sizeof(_Tp)) complex;

template<class _Tp> _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX
complex<_Tp> operator*(const complex<_Tp>& __z, const complex<_Tp>& __w);

template<class _Tp> _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX
complex<_Tp> operator/(const complex<_Tp>& __x, const complex<_Tp>& __y);

template<class _Tp>
class _LIBCUDACXX_TEMPLATE_VIS _LIBCUDACXX_COMPLEX_ALIGNAS(2*sizeof(_Tp)) complex
{
public:
    typedef _Tp value_type;
private:
    value_type __re_;
    value_type __im_;
public:
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex(const value_type& __re = value_type(), const value_type& __im = value_type())
        : __re_(__re), __im_(__im) {}
    template<class _Xp> _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex(const complex<_Xp>& __c)
        : __re_(__c.real()), __im_(__c.imag()) {}

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex(const ::std::complex<_Up>& __other)
        : __re_(_LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other)), __im_(_LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other))
    {}

    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex& operator=(const ::std::complex<_Up>& __other) {
        __re_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other);
        __im_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other);
        return *this;
    }

    _LIBCUDACXX_HOST _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    operator ::std::complex<_Tp>() const { return { __re_, __im_ }; }
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 value_type real() const {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 value_type imag() const {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void real(value_type __re) {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void imag(value_type __im) {__im_ = __im;}

#if defined(__cuda_std__)
    // Those additional volatile overloads are meant to help with reductions in thrust
    _LIBCUDACXX_INLINE_VISIBILITY value_type real() const volatile {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY value_type imag() const volatile {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY void real(value_type __re) volatile {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY void imag(value_type __im) volatile {__im_ = __im;}
#endif // defined(__cuda_std__)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator= (const value_type& __re) {__re_ = __re; __im_ = value_type(); return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator+=(const value_type& __re) {__re_ += __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator-=(const value_type& __re) {__re_ -= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator*=(const value_type& __re) {__re_ *= __re; __im_ *= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator/=(const value_type& __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<> class complex<double>;
#ifdef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
template<> class complex<long double>;
#endif // _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE

template<>
class _LIBCUDACXX_TEMPLATE_VIS _LIBCUDACXX_COMPLEX_ALIGNAS(2*sizeof(float)) complex<float>
{
    float __re_;
    float __im_;
public:
    typedef float value_type;

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR complex(float __re = 0.0f, float __im = 0.0f)
        : __re_(__re), __im_(__im) {}
    _LIBCUDACXX_INLINE_VISIBILITY
    explicit _LIBCUDACXX_CONSTEXPR complex(const complex<double>& __c);
    _LIBCUDACXX_INLINE_VISIBILITY
    explicit _LIBCUDACXX_CONSTEXPR complex(const complex<long double>& __c);

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex(const ::std::complex<_Up>& __other)
        : __re_(_LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other)), __im_(_LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other))
    {}

    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex& operator=(const ::std::complex<_Up>& __other) {
        __re_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other);
        __im_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other);
        return *this;
    }

    _LIBCUDACXX_HOST _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    operator ::std::complex<float>() const { return { __re_, __im_ }; }
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR float real() const {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR float imag() const {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void real(value_type __re) {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void imag(value_type __im) {__im_ = __im;}

#if defined(__cuda_std__)
    // Those additional volatile overloads are meant to help with reductions in thrust
    _LIBCUDACXX_INLINE_VISIBILITY float real() const volatile {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY float imag() const volatile {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY void real(value_type __re) volatile {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY void imag(value_type __im) volatile {__im_ = __im;}
#endif // defined(__cuda_std__)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator= (float __re) { __re_ = __re; __im_ = value_type(); return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator+=(float __re) {__re_ += __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator-=(float __re) {__re_ -= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator*=(float __re) {__re_ *= __re; __im_ *= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator/=(float __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<>
class _LIBCUDACXX_TEMPLATE_VIS _LIBCUDACXX_COMPLEX_ALIGNAS(2*sizeof(double)) complex<double>
{
    double __re_;
    double __im_;
public:
    typedef double value_type;

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR complex(double __re = 0.0, double __im = 0.0)
        : __re_(__re), __im_(__im) {}
    _LIBCUDACXX_INLINE_VISIBILITY
    _LIBCUDACXX_CONSTEXPR complex(const complex<float>& __c);
    _LIBCUDACXX_INLINE_VISIBILITY
    explicit _LIBCUDACXX_CONSTEXPR complex(const complex<long double>& __c);

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex(const ::std::complex<_Up>& __other)
        : __re_(_LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other)), __im_(_LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other))
    {}

    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex& operator=(const ::std::complex<_Up>& __other) {
        __re_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other);
        __im_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other);
        return *this;
    }

    _LIBCUDACXX_HOST _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    operator ::std::complex<double>() const { return { __re_, __im_ }; }
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR double real() const {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR double imag() const {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void real(value_type __re) {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void imag(value_type __im) {__im_ = __im;}

#if defined(__cuda_std__)
    // Those additional volatile overloads are meant to help with reductions in thrust
    _LIBCUDACXX_INLINE_VISIBILITY double real() const volatile {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY double imag() const volatile {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY void real(value_type __re) volatile {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY void imag(value_type __im) volatile {__im_ = __im;}
#endif // defined(__cuda_std__)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator= (double __re) {__re_ = __re; __im_ = value_type(); return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator+=(double __re) {__re_ += __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator-=(double __re) {__re_ -= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator*=(double __re) {__re_ *= __re; __im_ *= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator/=(double __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<>
class _LIBCUDACXX_TEMPLATE_VIS _LIBCUDACXX_COMPLEX_ALIGNAS(2*sizeof(long double)) complex<long double>
{
#ifndef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
public:
    template <typename _Dummy = void>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR complex(long double __re = 0.0, long double __im = 0.0)
        {static_assert(is_same<_Dummy, void>::value, "complex<long double> is not supported");}

    template <typename _Tp, typename _Dummy = void>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR complex(const complex<_Tp> &__c)
        {static_assert(is_same<_Dummy, void>::value, "complex<long double> is not supported");}

#else
    long double __re_;
    long double __im_;
public:
    typedef long double value_type;

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR complex(long double __re = 0.0L, long double __im = 0.0L)
        : __re_(__re), __im_(__im) {}
    _LIBCUDACXX_INLINE_VISIBILITY
    _LIBCUDACXX_CONSTEXPR complex(const complex<float>& __c);
    _LIBCUDACXX_INLINE_VISIBILITY
    _LIBCUDACXX_CONSTEXPR complex(const complex<double>& __c);

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex(const ::std::complex<_Up>& __other)
        : __re_(_LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other)), __im_(_LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other))
    {}

    template <class _Up>
    _LIBCUDACXX_INLINE_VISIBILITY
    complex& operator=(const ::std::complex<_Up>& __other) {
        __re_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__other);
        __im_ = _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__other);
        return *this;
    }

    _LIBCUDACXX_HOST _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    operator ::std::complex<long double>() const { return { __re_, __im_ }; }
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR long double real() const {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR long double imag() const {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void real(value_type __re) {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void imag(value_type __im) {__im_ = __im;}

#if defined(__cuda_std__)
    // Those additional volatile overloads are meant to help with reductions in thrust
    _LIBCUDACXX_INLINE_VISIBILITY long double real() const volatile {return __re_;}
    _LIBCUDACXX_INLINE_VISIBILITY long double imag() const volatile {return __im_;}

    _LIBCUDACXX_INLINE_VISIBILITY void real(value_type __re) volatile {__re_ = __re;}
    _LIBCUDACXX_INLINE_VISIBILITY void imag(value_type __im) volatile {__im_ = __im;}
#endif // defined(__cuda_std__)

    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator= (long double __re) {__re_ = __re; __im_ = value_type(); return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator+=(long double __re) {__re_ += __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator-=(long double __re) {__re_ -= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator*=(long double __re) {__re_ *= __re; __im_ *= __re; return *this;}
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
    complex& operator/=(long double __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp>
    _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
#endif // _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
};

#if defined(_LIBCUDACXX_USE_PRAGMA_MSVC_WARNING)
  // MSVC complains about narrowing conversions on these copy constructors regardless if they are used
  #pragma warning(push)
  #pragma warning(disable : 4244)
#endif

inline
_LIBCUDACXX_CONSTEXPR
complex<float>::complex(const complex<double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
_LIBCUDACXX_CONSTEXPR
complex<double>::complex(const complex<float>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

#ifdef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
inline
_LIBCUDACXX_CONSTEXPR
complex<float>::complex(const complex<long double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
_LIBCUDACXX_CONSTEXPR
complex<double>::complex(const complex<long double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
_LIBCUDACXX_CONSTEXPR
complex<long double>::complex(const complex<float>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
_LIBCUDACXX_CONSTEXPR
complex<long double>::complex(const complex<double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}
#endif // _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE

#if defined(_LIBCUDACXX_USE_PRAGMA_MSVC_WARNING)
  #pragma warning(pop)
#endif

// 26.3.6 operators:

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t += __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator+(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t += __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator+(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__y);
    __t += __x;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t -= __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator-(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t -= __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator-(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(-__y);
    __t += __x;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX
complex<_Tp>
operator*(const complex<_Tp>& __z, const complex<_Tp>& __w)
{
    _Tp __a = __z.real();
    _Tp __b = __z.imag();
    _Tp __c = __w.real();
    _Tp __d = __w.imag();

#if _LIBCUDACXX_STD_VER > 11 && defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
    // Avoid floating point operations that are invalid during constant evaluation
    if (__libcpp_is_constant_evaluated()) {
        bool __z_zero = __a == _Tp(0) && __b == _Tp(0);
        bool __w_zero = __c == _Tp(0) && __d == _Tp(0);
        bool __z_inf = _CUDA_VSTD::__constexpr_isinf(__a) || _CUDA_VSTD::__constexpr_isinf(__b);
        bool __w_inf = _CUDA_VSTD::__constexpr_isinf(__c) || _CUDA_VSTD::__constexpr_isinf(__d);
        bool __z_nan = !__z_inf && (
            (_CUDA_VSTD::__constexpr_isnan(__a) && _CUDA_VSTD::__constexpr_isnan(__b))
            || (_CUDA_VSTD::__constexpr_isnan(__a) && __b == _Tp(0))
            || (__a == _Tp(0) && _CUDA_VSTD::__constexpr_isnan(__b))
        );
        bool __w_nan = !__w_inf && (
            (_CUDA_VSTD::__constexpr_isnan(__c) && _CUDA_VSTD::__constexpr_isnan(__d))
            || (_CUDA_VSTD::__constexpr_isnan(__c) && __d == _Tp(0))
            || (__c == _Tp(0) && _CUDA_VSTD::__constexpr_isnan(__d))
        );
        if (__z_nan || __w_nan) {
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
        }
        if (__z_inf || __w_inf) {
            if (__z_zero || __w_zero) {
                return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
            }
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::infinity()), _Tp(numeric_limits<_Tp>::infinity()));
        }
        bool __z_nonzero_nan = !__z_inf && !__z_nan && (_CUDA_VSTD::__constexpr_isnan(__a) || _CUDA_VSTD::__constexpr_isnan(__b));
        bool __w_nonzero_nan = !__w_inf && !__w_nan && (_CUDA_VSTD::__constexpr_isnan(__c) || _CUDA_VSTD::__constexpr_isnan(__d));
        if (__z_nonzero_nan || __w_nonzero_nan) {
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
        }
    }
#endif // _LIBCUDACXX_STD_VER > 11 && defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)

    _Tp __ac = __a * __c;
    _Tp __bd = __b * __d;
    _Tp __ad = __a * __d;
    _Tp __bc = __b * __c;
    _Tp __x = __ac - __bd;
    _Tp __y = __ad + __bc;
#ifndef LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_MULTIPLICATION
    if (_CUDA_VSTD::__constexpr_isnan(__x) && _CUDA_VSTD::__constexpr_isnan(__y))
    {
        bool __recalc = false;
        if (_CUDA_VSTD::__constexpr_isinf(__a) || _CUDA_VSTD::__constexpr_isinf(__b))
        {
            __a = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__a) ? _Tp(1) : _Tp(0), __a);
            __b = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__b) ? _Tp(1) : _Tp(0), __b);
            if (_CUDA_VSTD::__constexpr_isnan(__c))
                __c = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __c);
            if (_CUDA_VSTD::__constexpr_isnan(__d))
                __d = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __d);
            __recalc = true;
        }
        if (_CUDA_VSTD::__constexpr_isinf(__c) || _CUDA_VSTD::__constexpr_isinf(__d))
        {
            __c = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__c) ? _Tp(1) : _Tp(0), __c);
            __d = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__d) ? _Tp(1) : _Tp(0), __d);
            if (_CUDA_VSTD::__constexpr_isnan(__a))
                __a = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __a);
            if (_CUDA_VSTD::__constexpr_isnan(__b))
                __b = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __b);
            __recalc = true;
        }
        if (!__recalc && (_CUDA_VSTD::__constexpr_isinf(__ac) || _CUDA_VSTD::__constexpr_isinf(__bd) ||
                          _CUDA_VSTD::__constexpr_isinf(__ad) || _CUDA_VSTD::__constexpr_isinf(__bc)))
        {
            if (_CUDA_VSTD::__constexpr_isnan(__a))
                __a = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __a);
            if (_CUDA_VSTD::__constexpr_isnan(__b))
                __b = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __b);
            if (_CUDA_VSTD::__constexpr_isnan(__c))
                __c = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __c);
            if (_CUDA_VSTD::__constexpr_isnan(__d))
                __d = _CUDA_VSTD::__constexpr_copysign(_Tp(0), __d);
            __recalc = true;
        }
        if (__recalc)
        {
            __x = _Tp(INFINITY) * (__a * __c - __b * __d);
            __y = _Tp(INFINITY) * (__a * __d + __b * __c);
        }
    }
#endif // LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_MULTIPLICATION
    return complex<_Tp>(__x, __y);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator*(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t *= __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator*(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__y);
    __t *= __x;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX
complex<_Tp>
operator/(const complex<_Tp>& __z, const complex<_Tp>& __w)
{
    int __ilogbw = 0;
    _Tp __a = __z.real();
    _Tp __b = __z.imag();
    _Tp __c = __w.real();
    _Tp __d = __w.imag();
    _Tp __logbw = _CUDA_VSTD::__constexpr_logb(_CUDA_VSTD::__constexpr_fmax(_CUDA_VSTD::__constexpr_fabs(__c), _CUDA_VSTD::__constexpr_fabs(__d)));
    if (_CUDA_VSTD::__constexpr_isfinite(__logbw))
    {
        __ilogbw = static_cast<int>(__logbw);
        __c = _CUDA_VSTD::__constexpr_scalbn(__c, -__ilogbw);
        __d = _CUDA_VSTD::__constexpr_scalbn(__d, -__ilogbw);
    }

#if _LIBCUDACXX_STD_VER > 11 && defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
    // Avoid floating point operations that are invalid during constant evaluation
    if (__libcpp_is_constant_evaluated()) {
        bool __z_zero = __a == _Tp(0) && __b == _Tp(0);
        bool __w_zero = __c == _Tp(0) && __d == _Tp(0);
        bool __z_inf = _CUDA_VSTD::__constexpr_isinf(__a) || _CUDA_VSTD::__constexpr_isinf(__b);
        bool __w_inf = _CUDA_VSTD::__constexpr_isinf(__c) || _CUDA_VSTD::__constexpr_isinf(__d);
        bool __z_nan = !__z_inf && (
            (_CUDA_VSTD::__constexpr_isnan(__a) && _CUDA_VSTD::__constexpr_isnan(__b))
            || (_CUDA_VSTD::__constexpr_isnan(__a) && __b == _Tp(0))
            || (__a == _Tp(0) && _CUDA_VSTD::__constexpr_isnan(__b))
        );
        bool __w_nan = !__w_inf && (
            (_CUDA_VSTD::__constexpr_isnan(__c) && _CUDA_VSTD::__constexpr_isnan(__d))
            || (_CUDA_VSTD::__constexpr_isnan(__c) && __d == _Tp(0))
            || (__c == _Tp(0) && _CUDA_VSTD::__constexpr_isnan(__d))
        );
        if ((__z_nan || __w_nan) || (__z_inf && __w_inf)) {
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
        }
        bool __z_nonzero_nan = !__z_inf && !__z_nan && (_CUDA_VSTD::__constexpr_isnan(__a) || _CUDA_VSTD::__constexpr_isnan(__b));
        bool __w_nonzero_nan = !__w_inf && !__w_nan && (_CUDA_VSTD::__constexpr_isnan(__c) || _CUDA_VSTD::__constexpr_isnan(__d));
        if (__z_nonzero_nan || __w_nonzero_nan) {
            if (__w_zero) {
                return complex<_Tp>(_Tp(numeric_limits<_Tp>::infinity()), _Tp(numeric_limits<_Tp>::infinity()));
            }
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
        }
        if (__w_inf) {
            return complex<_Tp>(_Tp(0), _Tp(0));
        }
        if (__z_inf) {
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::infinity()), _Tp(numeric_limits<_Tp>::infinity()));
        }
        if (__w_zero) {
            if (__z_zero) {
                return complex<_Tp>(_Tp(numeric_limits<_Tp>::quiet_NaN()), _Tp(0));
            }
            return complex<_Tp>(_Tp(numeric_limits<_Tp>::infinity()), _Tp(numeric_limits<_Tp>::infinity()));
        }
    }
#endif // _LIBCUDACXX_STD_VER > 11 && defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)

    _Tp __denom = __c * __c + __d * __d;
    _Tp __x = _CUDA_VSTD::__constexpr_scalbn((__a * __c + __b * __d) / __denom, -__ilogbw);
    _Tp __y = _CUDA_VSTD::__constexpr_scalbn((__b * __c - __a * __d) / __denom, -__ilogbw);
#ifndef LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_DIVISION
    if (_CUDA_VSTD::__constexpr_isnan(__x) && _CUDA_VSTD::__constexpr_isnan(__y))
    {
        if ((__denom == _Tp(0)) && (!_CUDA_VSTD::__constexpr_isnan(__a) || !_CUDA_VSTD::__constexpr_isnan(__b)))
        {
            __x = _CUDA_VSTD::__constexpr_copysign(_Tp(INFINITY), __c) * __a;
            __y = _CUDA_VSTD::__constexpr_copysign(_Tp(INFINITY), __c) * __b;
        } else if ((_CUDA_VSTD::__constexpr_isinf(__a) || _CUDA_VSTD::__constexpr_isinf(__b)) && _CUDA_VSTD::__constexpr_isfinite(__c) &&
                   _CUDA_VSTD::__constexpr_isfinite(__d)) {
            __a = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__a) ? _Tp(1) : _Tp(0), __a);
            __b = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__b) ? _Tp(1) : _Tp(0), __b);
            __x = _Tp(INFINITY) * (__a * __c + __b * __d);
            __y = _Tp(INFINITY) * (__b * __c - __a * __d);
        } else if (_CUDA_VSTD::__constexpr_isinf(__logbw) && __logbw > _Tp(0) && _CUDA_VSTD::__constexpr_isfinite(__a) &&
                   _CUDA_VSTD::__constexpr_isfinite(__b)) {
            __c = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__c) ? _Tp(1) : _Tp(0), __c);
            __d = _CUDA_VSTD::__constexpr_copysign(_CUDA_VSTD::__constexpr_isinf(__d) ? _Tp(1) : _Tp(0), __d);
            __x = _Tp(0) * (__a * __c + __b * __d);
            __y = _Tp(0) * (__b * __c - __a * __d);
        }
    }
#endif // LIBCUDACXX_ENABLE_SIMPLIFIED_COMPLEX_DIVISION
    return complex<_Tp>(__x, __y);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator/(const complex<_Tp>& __x, const _Tp& __y)
{
    return complex<_Tp>(__x.real() / __y, __x.imag() / __y);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator/(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t /= __y;
    return __t;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator+(const complex<_Tp>& __x)
{
    return __x;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
operator-(const complex<_Tp>& __x)
{
    return complex<_Tp>(-__x.real(), -__x.imag());
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return __x.real() == __y.real() && __x.imag() == __y.imag();
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator==(const complex<_Tp>& __x, const _Tp& __y)
{
    return __x.real() == __y && __x.imag() == 0;
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator==(const _Tp& __x, const complex<_Tp>& __y)
{
    return __x == __y.real() && 0 == __y.imag();
}

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
template <class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator==(const complex<_Tp>& __x, const ::std::complex<_Up>& __y) {
    return __x.real() == _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__y)
        && __x.imag() == _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__y);
}

template <class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator==(const ::std::complex<_Up>& __x, const complex<_Tp>& __y) {
    return __y.real() == _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL(__x)
        && __y.imag() == _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG(__x);
}
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator!=(const complex<_Tp>& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator!=(const _Tp& __x, const complex<_Tp>& __y)
{
    return !(__x == __y);
}

#if defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)
template <class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator!=(const complex<_Tp>& __x, const ::std::complex<_Up>& __y) {
    return !(__x == __y);
}

template <class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
bool
operator!=(const ::std::complex<_Up>& __x, const complex<_Tp>& __y) {
    return !(__x == __y);
}
#endif // defined(__cuda_std__) && !defined(_LIBCUDACXX_COMPILER_NVRTC) && !defined(_LIBCUDACXX_COMPILER_MSVC)

// 26.3.7 values:

template <class _Tp, bool = is_integral<_Tp>::value,
                     bool = is_floating_point<_Tp>::value
                     >
struct __libcpp_complex_overload_traits {};

// Integral Types
template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, true, false>
{
    typedef double _ValueType;
    typedef complex<double> _ComplexType;
};

// Floating point types
template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, false, true>
{
    typedef _Tp _ValueType;
    typedef complex<_Tp> _ComplexType;
};

// real

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
_Tp
real(const complex<_Tp>& __c)
{
    return __c.real();
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
real(_Tp __re)
{
    return __re;
}

// imag

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
_Tp
imag(const complex<_Tp>& __c)
{
    return __c.imag();
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
imag(_Tp)
{
    return 0;
}

// abs

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
_Tp
abs(const complex<_Tp>& __c)
{
    return _CUDA_VSTD::hypot(__c.real(), __c.imag());
}

// arg

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
_Tp
arg(const complex<_Tp>& __c)
{
    return _CUDA_VSTD::atan2(__c.imag(), __c.real());
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t<
    is_same<_Tp, long double>::value,
    long double
>
arg(_Tp __re)
{
    return _CUDA_VSTD::atan2l(0.L, __re);
}

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_integral<_Tp>::value || is_same<_Tp, double>::value,
    double
>
arg(_Tp __re)
{
    // integrals need to be promoted to double
    return _CUDA_VSTD::atan2(0., static_cast<double>(__re));
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t<
    is_same<_Tp, float>::value,
    float
>
arg(_Tp __re)
{
    return _CUDA_VSTD::atan2f(0.F, __re);
}

// norm

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
_Tp
norm(const complex<_Tp>& __c)
{
    if (_CUDA_VSTD::__constexpr_isinf(__c.real()))
        return _CUDA_VSTD::abs(__c.real());
    if (_CUDA_VSTD::__constexpr_isinf(__c.imag()))
        return _CUDA_VSTD::abs(__c.imag());
    return __c.real() * __c.real() + __c.imag() * __c.imag();
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
norm(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ValueType _ValueType;
    return static_cast<_ValueType>(__re) * __re;
}

// conj

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
complex<_Tp>
conj(const complex<_Tp>& __c)
{
    return complex<_Tp>(__c.real(), -__c.imag());
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
conj(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
    return _ComplexType(__re);
}



// proj

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
proj(const complex<_Tp>& __c)
{
    complex<_Tp> __r = __c;
    if (_CUDA_VSTD::__constexpr_isinf(__c.real()) || _CUDA_VSTD::__constexpr_isinf(__c.imag()))
        __r = complex<_Tp>(INFINITY, copysign(_Tp(0), __c.imag()));
    return __r;
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_floating_point<_Tp>::value,
    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
>
proj(_Tp __re)
{
    if (_CUDA_VSTD::__constexpr_isinf(__re))
        __re = _CUDA_VSTD::abs(__re);
    return complex<_Tp>(__re);
}

template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_integral<_Tp>::value,
    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
>
proj(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
    return _ComplexType(__re);
}

// polar

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
polar(const _Tp& __rho, const _Tp& __theta = _Tp())
{
    if (_CUDA_VSTD::__constexpr_isnan(__rho) || _CUDA_VSTD::signbit(__rho))
        return complex<_Tp>(_Tp(NAN), _Tp(NAN));
    if (_CUDA_VSTD::__constexpr_isnan(__theta))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__rho))
            return complex<_Tp>(__rho, __theta);
        return complex<_Tp>(__theta, __theta);
    }
    if (_CUDA_VSTD::__constexpr_isinf(__theta))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__rho))
            return complex<_Tp>(__rho, _Tp(NAN));
        return complex<_Tp>(_Tp(NAN), _Tp(NAN));
    }
    _Tp __x = __rho * _CUDA_VSTD::cos(__theta);
    if (_CUDA_VSTD::__constexpr_isnan(__x))
        __x = 0;
    _Tp __y = __rho * _CUDA_VSTD::sin(__theta);
    if (_CUDA_VSTD::__constexpr_isnan(__y))
        __y = 0;
    return complex<_Tp>(__x, __y);
}

// log

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
log(const complex<_Tp>& __x)
{
    return complex<_Tp>(_CUDA_VSTD::log(_CUDA_VSTD::abs(__x)), _CUDA_VSTD::arg(__x));
}

// log10

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
log10(const complex<_Tp>& __x)
{
    return _CUDA_VSTD::log(__x) / _CUDA_VSTD::log(_Tp(10));
}

// sqrt

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
sqrt(const complex<_Tp>& __x)
{
    if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        return complex<_Tp>(_Tp(INFINITY), __x.imag());
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (__x.real() > _Tp(0))
            return complex<_Tp>(__x.real(), _CUDA_VSTD::__constexpr_isnan(__x.imag()) ? __x.imag() : copysign(_Tp(0), __x.imag()));
        return complex<_Tp>(_CUDA_VSTD::__constexpr_isnan(__x.imag()) ? __x.imag() : _Tp(0), copysign(__x.real(), __x.imag()));
    }
    return _CUDA_VSTD::polar(_CUDA_VSTD::sqrt(_CUDA_VSTD::abs(__x)), _CUDA_VSTD::arg(__x) / _Tp(2));
}

// exp

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
exp(const complex<_Tp>& __x)
{
    _Tp __i = __x.imag();
    if (__i == 0) {
        return complex<_Tp>(_CUDA_VSTD::exp(__x.real()), copysign(_Tp(0), __x.imag()));
    }
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (__x.real() < _Tp(0))
        {
            if (!_CUDA_VSTD::__constexpr_isfinite(__i))
                __i = _Tp(1);
        }
        else if (__i == 0 || !_CUDA_VSTD::__constexpr_isfinite(__i))
        {
            if (_CUDA_VSTD::__constexpr_isinf(__i))
                __i = _Tp(NAN);
            return complex<_Tp>(__x.real(), __i);
        }
    }
    _Tp __e = _CUDA_VSTD::exp(__x.real());
    return complex<_Tp>(__e * _CUDA_VSTD::cos(__i), __e * _CUDA_VSTD::sin(__i));
}

// pow

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return _CUDA_VSTD::exp(__y * _CUDA_VSTD::log(__x));
}

template<class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<typename __promote<_Tp, _Up>::type>
pow(const complex<_Tp>& __x, const complex<_Up>& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return _CUDA_VSTD::pow(result_type(__x), result_type(__y));
}

template<class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_arithmetic<_Up>::value,
    complex<typename __promote<_Tp, _Up>::type>
>
pow(const complex<_Tp>& __x, const _Up& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return _CUDA_VSTD::pow(result_type(__x), result_type(__y));
}

template<class _Tp, class _Up>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_arithmetic<_Tp>::value,
    complex<typename __promote<_Tp, _Up>::type>
>
pow(const _Tp& __x, const complex<_Up>& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return _CUDA_VSTD::pow(result_type(__x), result_type(__y));
}

// __sqr, computes pow(x, 2)

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
__sqr(const complex<_Tp>& __x)
{
    return complex<_Tp>((__x.real() - __x.imag()) * (__x.real() + __x.imag()),
                        _Tp(2) * __x.real() * __x.imag());
}

// asinh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
asinh(const complex<_Tp>& __x)
{
    const _Tp __pi(static_cast<_Tp>(atan2(+0., -0.)));
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isnan(__x.imag()))
            return __x;
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
            return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
            return complex<_Tp>(__x.imag(), __x.real());
        if (__x.imag() == 0)
            return __x;
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        return complex<_Tp>(copysign(__x.imag(), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    complex<_Tp> __z = _CUDA_VSTD::log(__x + _CUDA_VSTD::sqrt(_CUDA_VSTD::__sqr(__x) + _Tp(1)));
    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
}

// acosh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
acosh(const complex<_Tp>& __x)
{
    const _Tp __pi(static_cast<_Tp>(atan2(+0., -0.)));
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isnan(__x.imag()))
            return complex<_Tp>(_CUDA_VSTD::abs(__x.real()), __x.imag());
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        {
            if (__x.real() > 0)
                return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
            else
                return complex<_Tp>(-__x.real(), copysign(__pi * _Tp(0.75), __x.imag()));
        }
        if (__x.real() < 0)
            return complex<_Tp>(-__x.real(), copysign(__pi, __x.imag()));
        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
            return complex<_Tp>(_CUDA_VSTD::abs(__x.imag()), __x.real());
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        return complex<_Tp>(_CUDA_VSTD::abs(__x.imag()), copysign(__pi/_Tp(2), __x.imag()));
    complex<_Tp> __z = _CUDA_VSTD::log(__x + _CUDA_VSTD::sqrt(_CUDA_VSTD::__sqr(__x) - _Tp(1)));
    return complex<_Tp>(copysign(__z.real(), _Tp(0)), copysign(__z.imag(), __x.imag()));
}

// atanh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
atanh(const complex<_Tp>& __x)
{
    const _Tp __pi(static_cast<_Tp>(atan2(+0., -0.)));
    if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
    {
        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.imag()))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__x.real()) || __x.real() == 0)
            return complex<_Tp>(copysign(_Tp(0), __x.real()), __x.imag());
        return complex<_Tp>(__x.imag(), __x.imag());
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.real()))
    {
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    }
    if (_CUDA_VSTD::abs(__x.real()) == _Tp(1) && __x.imag() == _Tp(0))
    {
        return complex<_Tp>(copysign(_Tp(INFINITY), __x.real()), copysign(_Tp(0), __x.imag()));
    }
    complex<_Tp> __z = _CUDA_VSTD::log((_Tp(1) + __x) / (_Tp(1) - __x)) / _Tp(2);
    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
}

// sinh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
sinh(const complex<_Tp>& __x)
{
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()) && !_CUDA_VSTD::__constexpr_isfinite(__x.imag()))
        return complex<_Tp>(__x.real(), _Tp(NAN));
    if (__x.real() == 0 && !_CUDA_VSTD::__constexpr_isfinite(__x.imag()))
        return complex<_Tp>(__x.real(), _Tp(NAN));
    if (__x.imag() == 0 && !_CUDA_VSTD::__constexpr_isfinite(__x.real()))
        return __x;
    return complex<_Tp>(_CUDA_VSTD::sinh(__x.real()) * _CUDA_VSTD::cos(__x.imag()), _CUDA_VSTD::cosh(__x.real()) * _CUDA_VSTD::sin(__x.imag()));
}

// cosh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
cosh(const complex<_Tp>& __x)
{
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()) && !_CUDA_VSTD::__constexpr_isfinite(__x.imag()))
        return complex<_Tp>(_CUDA_VSTD::abs(__x.real()), _Tp(NAN));
    if (__x.real() == 0 && !_CUDA_VSTD::__constexpr_isfinite(__x.imag()))
        return complex<_Tp>(_Tp(NAN), __x.real());
    if (__x.real() == 0 && __x.imag() == 0)
        return complex<_Tp>(_Tp(1), __x.imag());
    if (__x.imag() == 0 && !_CUDA_VSTD::__constexpr_isfinite(__x.real()))
        return complex<_Tp>(_CUDA_VSTD::abs(__x.real()), __x.imag());
    return complex<_Tp>(_CUDA_VSTD::cosh(__x.real()) * _CUDA_VSTD::cos(__x.imag()), _CUDA_VSTD::sinh(__x.real()) * _CUDA_VSTD::sin(__x.imag()));
}

// tanh

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
tanh(const complex<_Tp>& __x)
{
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (!_CUDA_VSTD::__constexpr_isfinite(__x.imag()))
            return complex<_Tp>(copysign(_Tp(1), __x.real()), _Tp(0));
        return complex<_Tp>(copysign(_Tp(1), __x.real()), copysign(_Tp(0), _CUDA_VSTD::sin(_Tp(2) * __x.imag())));
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.real()) && __x.imag() == 0)
        return __x;
    _Tp __2r(_Tp(2) * __x.real());
    _Tp __2i(_Tp(2) * __x.imag());
    _Tp __d(_CUDA_VSTD::cosh(__2r) + _CUDA_VSTD::cos(__2i));
    _Tp __2rsh(_CUDA_VSTD::sinh(__2r));
    if (_CUDA_VSTD::__constexpr_isinf(__2rsh) && _CUDA_VSTD::__constexpr_isinf(__d))
        return complex<_Tp>(__2rsh > _Tp(0) ? _Tp(1) : _Tp(-1),
                            __2i > _Tp(0) ? _Tp(0) : _Tp(-0.));
    return  complex<_Tp>(__2rsh/__d, _CUDA_VSTD::sin(__2i)/__d);
}

// asin

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
asin(const complex<_Tp>& __x)
{
    complex<_Tp> __z = _CUDA_VSTD::asinh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}

// acos

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
acos(const complex<_Tp>& __x)
{
    const _Tp __pi(static_cast<_Tp>(atan2(+0., -0.)));
    if (_CUDA_VSTD::__constexpr_isinf(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isnan(__x.imag()))
            return complex<_Tp>(__x.imag(), __x.real());
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        {
            if (__x.real() < _Tp(0))
                return complex<_Tp>(_Tp(0.75) * __pi, -__x.imag());
            return complex<_Tp>(_Tp(0.25) * __pi, -__x.imag());
        }
        if (__x.real() < _Tp(0))
            return complex<_Tp>(__pi, _CUDA_VSTD::signbit(__x.imag()) ? -__x.real() : __x.real());
        return complex<_Tp>(_Tp(0), _CUDA_VSTD::signbit(__x.imag()) ? __x.real() : -__x.real());
    }
    if (_CUDA_VSTD::__constexpr_isnan(__x.real()))
    {
        if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
            return complex<_Tp>(__x.real(), -__x.imag());
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (_CUDA_VSTD::__constexpr_isinf(__x.imag()))
        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
    if (__x.real() == 0 && (__x.imag() == 0 || _CUDA_VSTD::isnan(__x.imag())))
        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
    complex<_Tp> __z = _CUDA_VSTD::log(__x + _CUDA_VSTD::sqrt(_CUDA_VSTD::__sqr(__x) - _Tp(1)));
    if (_CUDA_VSTD::signbit(__x.imag()))
        return complex<_Tp>(_CUDA_VSTD::abs(__z.imag()), _CUDA_VSTD::abs(__z.real()));
    return complex<_Tp>(_CUDA_VSTD::abs(__z.imag()), -_CUDA_VSTD::abs(__z.real()));
}

// atan

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
atan(const complex<_Tp>& __x)
{
    complex<_Tp> __z = _CUDA_VSTD::atanh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}

// sin

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
sin(const complex<_Tp>& __x)
{
    complex<_Tp> __z = _CUDA_VSTD::sinh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}

// cos

template<class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
complex<_Tp>
cos(const complex<_Tp>& __x)
{
    return _CUDA_VSTD::cosh(complex<_Tp>(-__x.imag(), __x.real()));
}

// tan

template<class _Tp>
_LIBCUDACXX_INLINE_VISIBILITY complex<_Tp>
tan(const complex<_Tp>& __x)
{
    complex<_Tp> __z = _CUDA_VSTD::tanh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}

#ifndef __cuda_std__
#if !defined(_LIBCUDACXX_HAS_NO_LOCALIZATION)
template<class _Tp, class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
{
    if (__is.good())
    {
        _CUDA_VSTD::ws(__is);
        if (__is.peek() == _CharT('('))
        {
            __is.get();
            _Tp __r;
            __is >> __r;
            if (!__is.fail())
            {
                _CUDA_VSTD::ws(__is);
                _CharT __c = __is.peek();
                if (__c == _CharT(','))
                {
                    __is.get();
                    _Tp __i;
                    __is >> __i;
                    if (!__is.fail())
                    {
                        _CUDA_VSTD::ws(__is);
                        __c = __is.peek();
                        if (__c == _CharT(')'))
                        {
                            __is.get();
                            __x = complex<_Tp>(__r, __i);
                        }
                        else
                            __is.setstate(__is.failbit);
                    }
                    else
                        __is.setstate(__is.failbit);
                }
                else if (__c == _CharT(')'))
                {
                    __is.get();
                    __x = complex<_Tp>(__r, _Tp(0));
                }
                else
                    __is.setstate(__is.failbit);
            }
            else
                __is.setstate(__is.failbit);
        }
        else
        {
            _Tp __r;
            __is >> __r;
            if (!__is.fail())
                __x = complex<_Tp>(__r, _Tp(0));
            else
                __is.setstate(__is.failbit);
        }
    }
    else
        __is.setstate(__is.failbit);
    return __is;
}

template<class _Tp, class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
{
    basic_ostringstream<_CharT, _Traits> __s;
    __s.flags(__os.flags());
    __s.imbue(__os.getloc());
    __s.precision(__os.precision());
    __s << '(' << __x.real() << ',' << __x.imag() << ')';
    return __os << __s.str();
}
#endif // !_LIBCUDACXX_HAS_NO_LOCALIZATION
#endif // __cuda_std__

#if _LIBCUDACXX_STD_VER > 11 && defined(_LIBCUDACXX_HAS_STL_LITERALS)
// Literal suffix for complex number literals [complex.literals]
inline namespace literals
{
  inline namespace complex_literals
  {
#ifdef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<long double> operator""il(long double __im)
    {
        return { 0.0l, __im };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<long double> operator""il(unsigned long long __im)
    {
        return { 0.0l, static_cast<long double>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<double> operator""i(long double __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<double> operator""i(unsigned long long __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }


    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<float> operator""if(long double __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<float> operator""if(unsigned long long __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }
#else
    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<double> operator""i(double __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<double> operator""i(unsigned long long __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<float> operator""if(double __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }

    _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
    constexpr complex<float> operator""if(unsigned long long __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }
#endif
  } // namespace complex_literals
} // namespace literals
#endif

_LIBCUDACXX_END_NAMESPACE_STD

#undef _LIBCUDACXX_ACCESS_STD_COMPLEX_REAL
#undef _LIBCUDACXX_ACCESS_STD_COMPLEX_IMAG

#ifndef __cuda_std__
#include <__pragma_pop>
#endif //__cuda_std__

#endif // _LIBCUDACXX_COMPLEX
