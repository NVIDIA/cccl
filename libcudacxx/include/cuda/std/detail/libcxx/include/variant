// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_VARIANT
#define _LIBCUDACXX_VARIANT

/*
   variant synopsis

namespace std {

  // 20.7.2, class template variant
  template <class... Types>
  class variant {
  public:

    // 20.7.2.1, constructors
    constexpr variant() noexcept(see below);
    constexpr variant(const variant&);
    constexpr variant(variant&&) noexcept(see below);

    template <class T> constexpr variant(T&&) noexcept(see below);

    template <class T, class... Args>
    constexpr explicit variant(in_place_type_t<T>, Args&&...);

    template <class T, class U, class... Args>
    constexpr explicit variant(
        in_place_type_t<T>, initializer_list<U>, Args&&...);

    template <size_t I, class... Args>
    constexpr explicit variant(in_place_index_t<I>, Args&&...);

    template <size_t I, class U, class... Args>
    constexpr explicit variant(
        in_place_index_t<I>, initializer_list<U>, Args&&...);

    // 20.7.2.2, destructor
    ~variant();

    // 20.7.2.3, assignment
    constexpr variant& operator=(const variant&);
    constexpr variant& operator=(variant&&) noexcept(see below);

    template <class T> variant& operator=(T&&) noexcept(see below);

    // 20.7.2.4, modifiers
    template <class T, class... Args>
    T& emplace(Args&&...);

    template <class T, class U, class... Args>
    T& emplace(initializer_list<U>, Args&&...);

    template <size_t I, class... Args>
    variant_alternative_t<I, variant>& emplace(Args&&...);

    template <size_t I, class U, class...  Args>
    variant_alternative_t<I, variant>& emplace(initializer_list<U>, Args&&...);

    // 20.7.2.5, value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;

    // 20.7.2.6, swap
    void swap(variant&) noexcept(see below);
  };

  // 20.7.3, variant helper classes
  template <class T> struct variant_size; // undefined

  template <class T>
  inline constexpr size_t variant_size_v = variant_size<T>::value;

  template <class T> struct variant_size<const T>;
  template <class T> struct variant_size<volatile T>;
  template <class T> struct variant_size<const volatile T>;

  template <class... Types>
  struct variant_size<variant<Types...>>;

  template <size_t I, class T> struct variant_alternative; // undefined

  template <size_t I, class T>
  using variant_alternative_t = typename variant_alternative<I, T>::type;

  template <size_t I, class T> struct variant_alternative<I, const T>;
  template <size_t I, class T> struct variant_alternative<I, volatile T>;
  template <size_t I, class T> struct variant_alternative<I, const volatile T>;

  template <size_t I, class... Types>
  struct variant_alternative<I, variant<Types...>>;

  inline constexpr size_t variant_npos = -1;

  // 20.7.4, value access
  template <class T, class... Types>
  constexpr bool holds_alternative(const variant<Types...>&) noexcept;

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>&
  get(variant<Types...>&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>&&
  get(variant<Types...>&&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>> const&
  get(const variant<Types...>&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>> const&&
  get(const variant<Types...>&&);

  template <class T, class...  Types>
  constexpr T& get(variant<Types...>&);

  template <class T, class... Types>
  constexpr T&& get(variant<Types...>&&);

  template <class T, class... Types>
  constexpr const T& get(const variant<Types...>&);

  template <class T, class... Types>
  constexpr const T&& get(const variant<Types...>&&);

  template <size_t I, class... Types>
  constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
  get_if(variant<Types...>*) noexcept;

  template <size_t I, class... Types>
  constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
  get_if(const variant<Types...>*) noexcept;

  template <class T, class... Types>
  constexpr add_pointer_t<T>
  get_if(variant<Types...>*) noexcept;

  template <class T, class... Types>
  constexpr add_pointer_t<const T>
  get_if(const variant<Types...>*) noexcept;

  // 20.7.5, relational operators
  template <class... Types>
  constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);

  template <class... Types> requires (three_way_comparable<Types> && ...)
  constexpr common_comparison_category_t<compare_three_way_result_t<Types>...>
    operator<=>(const variant<Types...>&, const variant<Types...>&); // since
C++20

  // 20.7.6, visitation
  template <class Visitor, class... Variants>
  constexpr see below visit(Visitor&&, Variants&&...);

  template <class R, class Visitor, class... Variants>
  constexpr R visit(Visitor&&, Variants&&...); // since C++20

  // 20.7.7, class monostate
  struct monostate;

  // 20.7.8, monostate relational operators
  constexpr bool operator==(monostate, monostate) noexcept;
  constexpr bool operator!=(monostate, monostate) noexcept;             // until
C++20 constexpr bool operator<(monostate, monostate) noexcept;              //
until C++20 constexpr bool operator>(monostate, monostate) noexcept; // until
C++20 constexpr bool operator<=(monostate, monostate) noexcept;             //
until C++20 constexpr bool operator>=(monostate, monostate) noexcept; // until
C++20 constexpr strong_ordering operator<=>(monostate, monostate) noexcept; //
since C++20

  // 20.7.9, specialized algorithms
  template <class... Types>
  void swap(variant<Types...>&, variant<Types...>&) noexcept(see below);

  // 20.7.10, class bad_variant_access
  class bad_variant_access;

  // 20.7.11, hash support
  template <class T> struct hash;
  template <class... Types> struct hash<variant<Types...>>;
  template <> struct hash<monostate>;

} // namespace std

*/

#ifndef __cuda_std__
#  include <__config>
#endif // __cuda_std__

#include "__assert" // all public C++ headers provide the assertion handler
#include "__availability"
#ifndef _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR
#  include "__compare/common_comparison_category.h"
#  include "__compare/compare_three_way_result.h"
#  include "__compare/three_way_comparable.h"
#endif // _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR
#include "__functional/hash.h"
#include "__functional/invoke.h"
#include "__functional/operations.h"
#include "__functional/unary_function.h"
#include "__memory/construct_at.h"
#include "__memory/addressof.h"
#include "__tuple_dir/tuple_indices.h"
#include "__type_traits/add_const.h"
#include "__type_traits/add_cv.h"
#include "__type_traits/add_pointer.h"
#include "__type_traits/add_volatile.h"
#include "__type_traits/dependent_type.h"
#include "__type_traits/is_array.h"
#include "__type_traits/is_destructible.h"
#include "__type_traits/is_nothrow_move_constructible.h"
#include "__type_traits/is_trivially_copy_assignable.h"
#include "__type_traits/is_trivially_copy_constructible.h"
#include "__type_traits/is_trivially_destructible.h"
#include "__type_traits/is_trivially_move_assignable.h"
#include "__type_traits/is_trivially_move_constructible.h"
#include "__type_traits/is_void.h"
#include "__type_traits/remove_const.h"
#include "__type_traits/type_identity.h"
#include "__type_traits/void_t.h"
#include "__utility/declval.h"
#include "__utility/forward.h"
#include "__utility/in_place.h"
#include "__utility/move.h"
#include "__utility/swap.h"
#include "__variant/monostate.h"
#include "cstddef"
#include "cstdlib"
#include "initializer_list"
#include "tuple"
#include "version"

// [variant.syn]
#ifndef _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR
#  include "compare"
#endif

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#ifndef __cuda_std__
#  include <exception>

_LIBCUDACXX_BEGIN_NAMESPACE_STD_NOVERSION

class _LIBCUDACXX_EXCEPTION_ABI _LIBCUDACXX_AVAILABILITY_BAD_VARIANT_ACCESS bad_variant_access : public exception
{
public:
  const char* what() const noexcept override;
};

_LIBCUDACXX_END_NAMESPACE_STD_NOVERSION

#endif // __cuda_std__

#if _LIBCUDACXX_STD_VER >= 14

_LIBCUDACXX_BEGIN_NAMESPACE_STD

// Light N-dimensional array of function pointers. Used in place of
// _CUDA_VSTD::array to avoid adding a dependency.
template <class _Tp, size_t _Size>
struct __farray
{
  static_assert(_Size > 0, "N-dimensional array should never be empty in _CUDA_VSTD::visit");
  _Tp __buf_[_Size] = {};

  _LIBCUDACXX_INLINE_VISIBILITY constexpr const _Tp& operator[](size_t __n) const noexcept
  {
    return __buf_[__n];
  }
};

_LIBCUDACXX_NORETURN inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS void
__throw_bad_variant_access()
{
#  ifndef _LIBCUDACXX_NO_EXCEPTIONS
  throw bad_variant_access();
#  else
  _LIBCUDACXX_UNREACHABLE();
#  endif
}

template <class... _Types>
class _LIBCUDACXX_TEMPLATE_VIS variant;

template <class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_size;

template <class _Tp>
_LIBCUDACXX_INLINE_VAR constexpr size_t variant_size_v = variant_size<_Tp>::value;

template <class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_size<const _Tp> : variant_size<_Tp>
{};

template <class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_size<volatile _Tp> : variant_size<_Tp>
{};

template <class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_size<const volatile _Tp> : variant_size<_Tp>
{};

template <class... _Types>
struct _LIBCUDACXX_TEMPLATE_VIS variant_size<variant<_Types...>> : integral_constant<size_t, sizeof...(_Types)>
{};

template <size_t _Ip, class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_alternative;

template <size_t _Ip, class _Tp>
using variant_alternative_t = typename variant_alternative<_Ip, _Tp>::type;

template <size_t _Ip, class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_alternative<_Ip, const _Tp> : add_const<variant_alternative_t<_Ip, _Tp>>
{};

template <size_t _Ip, class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_alternative<_Ip, volatile _Tp> : add_volatile<variant_alternative_t<_Ip, _Tp>>
{};

template <size_t _Ip, class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS variant_alternative<_Ip, const volatile _Tp> : add_cv<variant_alternative_t<_Ip, _Tp>>
{};

template <size_t _Ip, class... _Types>
struct _LIBCUDACXX_TEMPLATE_VIS variant_alternative<_Ip, variant<_Types...>>
{
  static_assert(_Ip < sizeof...(_Types), "Index out of bounds in _CUDA_VSTD::variant_alternative<>");
  using type = __type_pack_element<_Ip, _Types...>;
};

_LIBCUDACXX_INLINE_VAR constexpr size_t variant_npos = static_cast<size_t>(-1);

_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 int __choose_index_type(unsigned int __num_elem)
{
  constexpr unsigned char __small   = static_cast<unsigned char>(-1);
  constexpr unsigned short __medium = static_cast<unsigned short>(-1);
  if (__num_elem < static_cast<unsigned int>(__small))
  {
    return 0;
  }
  if (__num_elem < static_cast<unsigned int>(__medium))
  {
    return 1;
  }
  return 2;
}

template <size_t _NumAlts>
using __variant_index_t =
#  ifndef _LIBCUDACXX_ABI_VARIANT_INDEX_TYPE_OPTIMIZATION
  unsigned int;
#  else
  __conditional_t<__choose_index_type(_NumAlts) == 0,
                  unsigned char,
                  __conditional_t<__choose_index_type(_NumAlts) == 1, unsigned short, unsigned int>>;
#  endif

template <class _IndexType>
constexpr _IndexType __variant_npos = static_cast<_IndexType>(-1);

template <class... _Types>
class _LIBCUDACXX_TEMPLATE_VIS variant;

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr variant<_Types...>& __as_variant(variant<_Types...>& __vs) noexcept
{
  return __vs;
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr const variant<_Types...>& __as_variant(const variant<_Types...>& __vs) noexcept
{
  return __vs;
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr variant<_Types...>&& __as_variant(variant<_Types...>&& __vs) noexcept
{
  return _CUDA_VSTD::move(__vs);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr const variant<_Types...>&& __as_variant(const variant<_Types...>&& __vs) noexcept
{
  return _CUDA_VSTD::move(__vs);
}

namespace __find_detail
{

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr size_t __find_index()
{
  constexpr bool __matches[] = {_LIBCUDACXX_TRAIT(is_same, _Tp, _Types)...};
  size_t __result            = __not_found;
  for (size_t __i = 0; __i < sizeof...(_Types); ++__i)
  {
    if (__matches[__i])
    {
      if (__result != __not_found)
      {
        return __ambiguous;
      }
      __result = __i;
    }
  }
  return __result;
}

template <size_t _Index>
struct __find_unambiguous_index_sfinae_impl : integral_constant<size_t, _Index>
{};

template <>
struct __find_unambiguous_index_sfinae_impl<__not_found>
{};

template <>
struct __find_unambiguous_index_sfinae_impl<__ambiguous>
{};

template <class _Tp, class... _Types>
struct __find_unambiguous_index_sfinae : __find_unambiguous_index_sfinae_impl<__find_index<_Tp, _Types...>()>
{};

} // namespace __find_detail

namespace __variant_detail
{

struct __valueless_t
{};

enum class _Trait
{
  _TriviallyAvailable,
  _Available,
  _Unavailable
};

template <typename _Tp, template <typename> class _IsTriviallyAvailable, template <typename> class _IsAvailable>
constexpr _Trait __trait =
  _IsTriviallyAvailable<_Tp>::value ? _Trait::_TriviallyAvailable
  : _IsAvailable<_Tp>::value
    ? _Trait::_Available
    : _Trait::_Unavailable;

_LIBCUDACXX_INLINE_VISIBILITY constexpr _Trait __common_trait(initializer_list<_Trait> __traits)
{
  _Trait __result = _Trait::_TriviallyAvailable;
  for (_Trait __t : __traits)
  {
    if (static_cast<int>(__t) > static_cast<int>(__result))
    {
      __result = __t;
    }
  }
  return __result;
}

template <typename... _Types>
struct __traits
{
  static constexpr _Trait __copy_constructible_trait =
    __variant_detail::__common_trait({__trait<_Types, is_trivially_copy_constructible, is_copy_constructible>...});

  static constexpr _Trait __move_constructible_trait =
    __variant_detail::__common_trait({__trait<_Types, is_trivially_move_constructible, is_move_constructible>...});

  static constexpr _Trait __copy_assignable_trait = __variant_detail::__common_trait(
    {__copy_constructible_trait, __trait<_Types, is_trivially_copy_assignable, is_copy_assignable>...});

  static constexpr _Trait __move_assignable_trait = __variant_detail::__common_trait(
    {__move_constructible_trait, __trait<_Types, is_trivially_move_assignable, is_move_assignable>...});

  static constexpr _Trait __destructible_trait =
    __variant_detail::__common_trait({__trait<_Types, is_trivially_destructible, is_destructible>...});
};

namespace __access
{

struct __union
{
  template <class _Vp>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<0>)
  {
    return _CUDA_VSTD::forward<_Vp>(__v).__head;
  }

  template <class _Vp, size_t _Ip>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<_Ip>)
  {
    return __get_alt(_CUDA_VSTD::forward<_Vp>(__v).__tail, in_place_index<_Ip - 1>);
  }
};

struct __base
{
  template <size_t _Ip, class _Vp>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto&& __get_alt(_Vp&& __v)
  {
    return __union::__get_alt(_CUDA_VSTD::forward<_Vp>(__v).__data, in_place_index<_Ip>);
  }
};

struct __variant
{
  template <size_t _Ip, class _Vp>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto&& __get_alt(_Vp&& __v)
  {
    return __base::__get_alt<_Ip>(_CUDA_VSTD::forward<_Vp>(__v).__impl_);
  }
};

} // namespace __access

namespace __visitation
{

struct __base
{
  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs)
  {
    constexpr auto __fdiagonal =
      __make_fdiagonal<_Visitor&&, decltype(_CUDA_VSTD::forward<_Vs>(__vs).__as_base())...>();
    return __fdiagonal[__index](_CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Vs>(__vs).__as_base()...);
  }

  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor, _Vs&&... __vs)
  {
    constexpr auto __fmatrix = __make_fmatrix<_Visitor&&, decltype(_CUDA_VSTD::forward<_Vs>(__vs).__as_base())...>();
    return __at(__fmatrix, __vs.index()...)(
      _CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Vs>(__vs).__as_base()...);
  }

private:
  template <class _Tp>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr const _Tp& __at(const _Tp& __elem)
  {
    return __elem;
  }

  template <class _Tp, size_t _Np, typename... _Indices>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto&&
  __at(const __farray<_Tp, _Np>& __elems, size_t __index, _Indices... __indices)
  {
    return __at(__elems[__index], __indices...);
  }

  template <class _Fp, class... _Fs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr void __std_visit_visitor_return_type_check()
  {
    static_assert(__all<_LIBCUDACXX_TRAIT(is_same, _Fp, _Fs)...>::value,
                  "`_CUDA_VSTD::visit` requires the visitor to have a single "
                  "return type.");
  }

  template <class... _Fs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_farray(_Fs&&... __fs)
  {
    __std_visit_visitor_return_type_check<__remove_cvref_t<_Fs>...>();
    using __result = __farray<common_type_t<__remove_cvref_t<_Fs>...>, sizeof...(_Fs)>;
    return __result{{_CUDA_VSTD::forward<_Fs>(__fs)...}};
  }

  template <size_t... _Is>
  struct __dispatcher
  {
    template <class _Fp, class... _Vs>
    _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto) __dispatch(_Fp __f, _Vs... __vs)
    {
      return _CUDA_VSTD::__invoke(static_cast<_Fp>(__f), __access::__base::__get_alt<_Is>(static_cast<_Vs>(__vs))...);
    }
  };

  template <class _Fp, class... _Vs, size_t... _Is>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_dispatch(index_sequence<_Is...>)
  {
    return __dispatcher<_Is...>::template __dispatch<_Fp, _Vs...>;
  }

  template <size_t _Ip, class _Fp, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_fdiagonal_impl()
  {
    return __make_dispatch<_Fp, _Vs...>(index_sequence<((void) __type_identity<_Vs>{}, _Ip)...>{});
  }

  template <class _Fp, class... _Vs, size_t... _Is>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_fdiagonal_impl(index_sequence<_Is...>)
  {
    return __base::__make_farray(__make_fdiagonal_impl<_Is, _Fp, _Vs...>()...);
  }

  template <class _Fp, class _Vp, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_fdiagonal()
  {
    constexpr size_t __np = __remove_cvref_t<_Vp>::__size();
    static_assert(__all<(__np == __remove_cvref_t<_Vs>::__size())...>::value, "");
    return __make_fdiagonal_impl<_Fp, _Vp, _Vs...>(_CUDA_VSTD::make_index_sequence<__np>{});
  }

  template <class _Fp, class... _Vs, size_t... _Is>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_fmatrix_impl(index_sequence<_Is...> __is)
  {
    return __make_dispatch<_Fp, _Vs...>(__is);
  }

  template <class _Fp, class... _Vs, size_t... _Is, size_t... _Js, class... _Ls>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto
  __make_fmatrix_impl(index_sequence<_Is...>, index_sequence<_Js...>, _Ls... __ls)
  {
    return __base::__make_farray(__make_fmatrix_impl<_Fp, _Vs...>(index_sequence<_Is..., _Js>{}, __ls...)...);
  }

  template <class _Fp, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_fmatrix()
  {
    return __make_fmatrix_impl<_Fp, _Vs...>(
      index_sequence<>{}, _CUDA_VSTD::make_index_sequence<__remove_cvref_t<_Vs>::__size()>{}...);
  }
};

struct __variant
{
  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs)
  {
    return __base::__visit_alt_at(
      __index, _CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Vs>(__vs).__impl_...);
  }

  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor, _Vs&&... __vs)
  {
    return __base::__visit_alt(
      _CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::__as_variant(_CUDA_VSTD::forward<_Vs>(__vs)).__impl_...);
  }

  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto)
  __visit_value_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs)
  {
    return __visit_alt_at(
      __index, __make_value_visitor(_CUDA_VSTD::forward<_Visitor>(__visitor)), _CUDA_VSTD::forward<_Vs>(__vs)...);
  }

  template <class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr decltype(auto) __visit_value(_Visitor&& __visitor, _Vs&&... __vs)
  {
    return __visit_alt(__make_value_visitor(_CUDA_VSTD::forward<_Visitor>(__visitor)),
                       _CUDA_VSTD::forward<_Vs>(__vs)...);
  }

  template <class _Rp, class _Visitor, class... _Vs>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr _Rp __visit_value(_Visitor&& __visitor, _Vs&&... __vs)
  {
    return __visit_alt(__make_value_visitor<_Rp>(_CUDA_VSTD::forward<_Visitor>(__visitor)),
                       _CUDA_VSTD::forward<_Vs>(__vs)...);
  }

private:
  template <class _Visitor, class... _Values>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr void __std_visit_exhaustive_visitor_check()
  {
    static_assert(_LIBCUDACXX_TRAIT(is_invocable, _Visitor, _Values...),
                  "`_CUDA_VSTD::visit` requires the visitor to be exhaustive.");
  }

  template <class _Visitor>
  struct __value_visitor
  {
    template <class... _Alts>
    _LIBCUDACXX_INLINE_VISIBILITY constexpr decltype(auto) operator()(_Alts&&... __alts) const
    {
      __std_visit_exhaustive_visitor_check<_Visitor, decltype((_CUDA_VSTD::forward<_Alts>(__alts).__value))...>();
      return _CUDA_VSTD::__invoke(
        _CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Alts>(__alts).__value...);
    }
    _Visitor&& __visitor;
  };

  template <class _Rp, class _Visitor>
  struct __value_visitor_return_type
  {
    template <class... _Alts>
    _LIBCUDACXX_INLINE_VISIBILITY constexpr _Rp operator()(_Alts&&... __alts) const
    {
      __std_visit_exhaustive_visitor_check<_Visitor, decltype((_CUDA_VSTD::forward<_Alts>(__alts).__value))...>();
      return _CUDA_VSTD::__invoke(
        _CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Alts>(__alts).__value...);
    }
    _Visitor&& __visitor;
  };

  template <class _Visitor>
  struct __value_visitor_return_type<void, _Visitor>
  {
    template <class... _Alts>
    _LIBCUDACXX_INLINE_VISIBILITY constexpr void operator()(_Alts&&... __alts) const
    {
      __std_visit_exhaustive_visitor_check<_Visitor, decltype((_CUDA_VSTD::forward<_Alts>(__alts).__value))...>();
      _CUDA_VSTD::__invoke(_CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Alts>(__alts).__value...);
    }
    _Visitor&& __visitor;
  };

  template <class _Visitor>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_value_visitor(_Visitor&& __visitor)
  {
    return __value_visitor<_Visitor>{_CUDA_VSTD::forward<_Visitor>(__visitor)};
  }

  template <class _Rp, class _Visitor>
  _LIBCUDACXX_INLINE_VISIBILITY static constexpr auto __make_value_visitor(_Visitor&& __visitor)
  {
    return __value_visitor_return_type<_Rp, _Visitor>{_CUDA_VSTD::forward<_Visitor>(__visitor)};
  }
};

} // namespace __visitation

template <size_t _Index, class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS __alt
{
  using __value_type = _Tp;

  template <class... _Args>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __alt(in_place_t, _Args&&... __args)
      : __value(_CUDA_VSTD::forward<_Args>(__args)...)
  {}

  __value_type __value;
};

template <_Trait _DestructibleTrait, size_t _Index, class... _Types>
union _LIBCUDACXX_TEMPLATE_VIS __union;

template <_Trait _DestructibleTrait, size_t _Index>
union _LIBCUDACXX_TEMPLATE_VIS __union<_DestructibleTrait, _Index>
{};

#  define _LIBCUDACXX_VARIANT_UNION(destructible_trait, destructor)                                      \
    template <size_t _Index, class _Tp, class... _Types>                                                 \
    union _LIBCUDACXX_TEMPLATE_VIS __union<destructible_trait, _Index, _Tp, _Types...>                   \
    {                                                                                                    \
    public:                                                                                              \
      _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __union(__valueless_t) noexcept                   \
          : __dummy{}                                                                                    \
      {}                                                                                                 \
                                                                                                         \
      template <class... _Args>                                                                          \
      _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __union(in_place_index_t<0>, _Args&&... __args)   \
          : __head(in_place, _CUDA_VSTD::forward<_Args>(__args)...)                                      \
      {}                                                                                                 \
                                                                                                         \
      template <size_t _Ip, class... _Args>                                                              \
      _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) \
          : __tail(in_place_index<_Ip - 1>, _CUDA_VSTD::forward<_Args>(__args)...)                       \
      {}                                                                                                 \
                                                                                                         \
      __union(const __union&) = default;                                                                 \
      __union(__union&&)      = default;                                                                 \
                                                                                                         \
      destructor;                                                                                        \
                                                                                                         \
      __union& operator=(const __union&) = default;                                                      \
      __union& operator=(__union&&)      = default;                                                      \
                                                                                                         \
    private:                                                                                             \
      char __dummy;                                                                                      \
      __alt<_Index, _Tp> __head;                                                                         \
      __union<destructible_trait, _Index + 1, _Types...> __tail;                                         \
                                                                                                         \
      friend struct __access::__union;                                                                   \
    }

_LIBCUDACXX_VARIANT_UNION(_Trait::_TriviallyAvailable, ~__union() = default;);
_LIBCUDACXX_VARIANT_UNION(_Trait::_Available, _LIBCUDACXX_INLINE_VISIBILITY ~__union(){});
_LIBCUDACXX_VARIANT_UNION(_Trait::_Unavailable, ~__union() = delete;);

#  undef _LIBCUDACXX_VARIANT_UNION

template <_Trait _DestructibleTrait, class... _Types>
class _LIBCUDACXX_TEMPLATE_VIS __base
{
public:
  using __index_t = __variant_index_t<sizeof...(_Types)>;

  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __base(__valueless_t __tag) noexcept
      : __data(__tag)
      , __index(__variant_npos<__index_t>)
  {}

  template <size_t _Ip, class... _Args>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr __base(in_place_index_t<_Ip>, _Args&&... __args)
      : __data(in_place_index<_Ip>, _CUDA_VSTD::forward<_Args>(__args)...)
      , __index(_Ip)
  {}

  _LIBCUDACXX_INLINE_VISIBILITY constexpr bool valueless_by_exception() const noexcept
  {
    return index() == variant_npos;
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr size_t index() const noexcept
  {
    return __index == __variant_npos<__index_t> ? variant_npos : __index;
  }

protected:
  _LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __as_base() &
  {
    return *this;
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __as_base() &&
  {
    return _CUDA_VSTD::move(*this);
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __as_base() const&
  {
    return *this;
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __as_base() const&&
  {
    return _CUDA_VSTD::move(*this);
  }

  _LIBCUDACXX_INLINE_VISIBILITY static constexpr size_t __size()
  {
    return sizeof...(_Types);
  }

  __union<_DestructibleTrait, 0, _Types...> __data;
  __index_t __index;

  friend struct __access::__base;
  friend struct __visitation::__base;
};

template <class _Traits, _Trait = _Traits::__destructible_trait>
class _LIBCUDACXX_TEMPLATE_VIS __dtor;

#  define _LIBCUDACXX_VARIANT_DESTRUCTOR(destructible_trait, destructor, destroy)  \
    template <class... _Types>                                                     \
    class _LIBCUDACXX_TEMPLATE_VIS __dtor<__traits<_Types...>, destructible_trait> \
        : public __base<destructible_trait, _Types...>                             \
    {                                                                              \
      using __base_type = __base<destructible_trait, _Types...>;                   \
      using __index_t   = typename __base_type::__index_t;                         \
                                                                                   \
      struct __visitor                                                             \
      {                                                                            \
        template <class _Alt>                                                      \
        _LIBCUDACXX_INLINE_VISIBILITY void operator()(_Alt& __alt) const noexcept  \
        {                                                                          \
          using __alt_type = __remove_cvref_t<decltype(__alt)>;                    \
          __alt.~__alt_type();                                                     \
        }                                                                          \
      };                                                                           \
                                                                                   \
    public:                                                                        \
      using __base_type::__base_type;                                              \
      using __base_type::operator=;                                                \
                                                                                   \
      __dtor(const __dtor&)                       = default;                       \
      __dtor(__dtor&&)                            = default;                       \
      destructor __dtor& operator=(const __dtor&) = default;                       \
      __dtor& operator=(__dtor&&)                 = default;                       \
                                                                                   \
    protected:                                                                     \
      inline destroy                                                               \
    }

_LIBCUDACXX_VARIANT_DESTRUCTOR(
  _Trait::_TriviallyAvailable, ~__dtor() = default;
  , _LIBCUDACXX_INLINE_VISIBILITY void __destroy() noexcept { this->__index = __variant_npos<__index_t>; });

_LIBCUDACXX_VARIANT_DESTRUCTOR(
  _Trait::_Available,
  _LIBCUDACXX_INLINE_VISIBILITY ~__dtor() { __destroy(); },
  _LIBCUDACXX_INLINE_VISIBILITY void __destroy() noexcept {
    if (!this->valueless_by_exception())
    {
      __visitation::__base::__visit_alt(__visitor{}, *this);
    }
    this->__index = __variant_npos<__index_t>;
  });

_LIBCUDACXX_VARIANT_DESTRUCTOR(_Trait::_Unavailable, ~__dtor() = delete;, void __destroy() noexcept = delete;);

#  undef _LIBCUDACXX_VARIANT_DESTRUCTOR

template <class _Traits>
class _LIBCUDACXX_TEMPLATE_VIS __ctor : public __dtor<_Traits>
{
  using __base_type = __dtor<_Traits>;

  struct __visitor
  {
    template <class _LeftAlt, class _RightAlt>
    _LIBCUDACXX_INLINE_VISIBILITY void operator()(_LeftAlt& __lhs_alt, _RightAlt&& __rhs_alt) const
    {
      __construct_alt(__lhs_alt, _CUDA_VSTD::forward<decltype(__rhs_alt)>(__rhs_alt).__value);
    }
  };

public:
  using __base_type::__base_type;
  using __base_type::operator=;

protected:
  template <size_t _Ip, class _Tp, class... _Args>
  _LIBCUDACXX_INLINE_VISIBILITY static _Tp& __construct_alt(__alt<_Ip, _Tp>& __a, _Args&&... __args)
  {
    __construct_at(_CUDA_VSTD::addressof(__a), in_place, _CUDA_VSTD::forward<_Args>(__args)...);
    return __a.__value;
  }

  template <class _Rhs>
  _LIBCUDACXX_INLINE_VISIBILITY static void __generic_construct(__ctor& __lhs, _Rhs&& __rhs)
  {
    __lhs.__destroy();
    if (!__rhs.valueless_by_exception())
    {
      __visitation::__base::__visit_alt_at(__rhs.index(), __visitor{}, __lhs, _CUDA_VSTD::forward<_Rhs>(__rhs));
      __lhs.__index = static_cast<decltype(__lhs.__index)>(__rhs.index());
    }
  }
};

template <class _Traits, _Trait = _Traits::__move_constructible_trait>
class _LIBCUDACXX_TEMPLATE_VIS __move_constructor;

#  define _LIBCUDACXX_VARIANT_MOVE_CONSTRUCTOR(move_constructible_trait, move_constructor)           \
    template <class... _Types>                                                                       \
    class _LIBCUDACXX_TEMPLATE_VIS __move_constructor<__traits<_Types...>, move_constructible_trait> \
        : public __ctor<__traits<_Types...>>                                                         \
    {                                                                                                \
      using __base_type = __ctor<__traits<_Types...>>;                                               \
                                                                                                     \
    public:                                                                                          \
      using __base_type::__base_type;                                                                \
      using __base_type::operator=;                                                                  \
                                                                                                     \
      __move_constructor(const __move_constructor&)            = default;                            \
      move_constructor ~__move_constructor()                   = default;                            \
      __move_constructor& operator=(const __move_constructor&) = default;                            \
      __move_constructor& operator=(__move_constructor&&)      = default;                            \
    }

_LIBCUDACXX_VARIANT_MOVE_CONSTRUCTOR(_Trait::_TriviallyAvailable,
                                     __move_constructor(__move_constructor&& __that) = default;);

_LIBCUDACXX_VARIANT_MOVE_CONSTRUCTOR(
  _Trait::_Available,
  _LIBCUDACXX_INLINE_VISIBILITY __move_constructor(__move_constructor&& __that) noexcept(
    __all<_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Types)...>::value)
  : __move_constructor(__valueless_t{}) { this->__generic_construct(*this, _CUDA_VSTD::move(__that)); });

_LIBCUDACXX_VARIANT_MOVE_CONSTRUCTOR(_Trait::_Unavailable, __move_constructor(__move_constructor&&) = delete;);

#  undef _LIBCUDACXX_VARIANT_MOVE_CONSTRUCTOR

template <class _Traits, _Trait = _Traits::__copy_constructible_trait>
class _LIBCUDACXX_TEMPLATE_VIS __copy_constructor;

#  define _LIBCUDACXX_VARIANT_COPY_CONSTRUCTOR(copy_constructible_trait, copy_constructor)           \
    template <class... _Types>                                                                       \
    class _LIBCUDACXX_TEMPLATE_VIS __copy_constructor<__traits<_Types...>, copy_constructible_trait> \
        : public __move_constructor<__traits<_Types...>>                                             \
    {                                                                                                \
      using __base_type = __move_constructor<__traits<_Types...>>;                                   \
                                                                                                     \
    public:                                                                                          \
      using __base_type::__base_type;                                                                \
      using __base_type::operator=;                                                                  \
                                                                                                     \
      copy_constructor __copy_constructor(__copy_constructor&&) = default;                           \
      ~__copy_constructor()                                     = default;                           \
      __copy_constructor& operator=(const __copy_constructor&)  = default;                           \
      __copy_constructor& operator=(__copy_constructor&&)       = default;                           \
    }

_LIBCUDACXX_VARIANT_COPY_CONSTRUCTOR(_Trait::_TriviallyAvailable,
                                     __copy_constructor(const __copy_constructor& __that) = default;);

_LIBCUDACXX_VARIANT_COPY_CONSTRUCTOR(
  _Trait::_Available, _LIBCUDACXX_INLINE_VISIBILITY __copy_constructor(const __copy_constructor& __that)
  : __copy_constructor(__valueless_t{}) { this->__generic_construct(*this, __that); });

_LIBCUDACXX_VARIANT_COPY_CONSTRUCTOR(_Trait::_Unavailable, __copy_constructor(const __copy_constructor&) = delete;);

#  undef _LIBCUDACXX_VARIANT_COPY_CONSTRUCTOR

template <class _Traits>
class _LIBCUDACXX_TEMPLATE_VIS __assignment : public __copy_constructor<_Traits>
{
  using __base_type = __copy_constructor<_Traits>;

  struct __visitor
  {
    __assignment* __this_;

    _LIBCUDACXX_INLINE_VISIBILITY constexpr __visitor(__assignment* __this) noexcept
        : __this_(__this)
    {}

    template <class _LeftAlt, class _RightAlt>
    _LIBCUDACXX_INLINE_VISIBILITY void operator()(_LeftAlt& __this_alt, _RightAlt&& __that_alt) const
    {
      __this_->__assign_alt(__this_alt, _CUDA_VSTD::forward<decltype(__that_alt)>(__that_alt).__value);
    }
  };

public:
  using __base_type::__base_type;
  using __base_type::operator=;

  template <size_t _Ip, class... _Args>
  _LIBCUDACXX_INLINE_VISIBILITY auto& __emplace(_Args&&... __args)
  {
    this->__destroy();
    auto& __res = this->__construct_alt(__access::__base::__get_alt<_Ip>(*this), _CUDA_VSTD::forward<_Args>(__args)...);
    this->__index = _Ip;
    return __res;
  }

protected:
  template <size_t _Ip, class _Tp, class _Arg>
  _LIBCUDACXX_INLINE_VISIBILITY void __assign_alt(__alt<_Ip, _Tp>& __a, _Arg&& __arg)
  {
    if (this->index() == _Ip)
    {
      __a.__value = _CUDA_VSTD::forward<_Arg>(__arg);
    }
    else
    {
      struct
      {
        _LIBCUDACXX_INLINE_VISIBILITY void operator()(true_type) const
        {
          __this->__emplace<_Ip>(_CUDA_VSTD::forward<_Arg>(__arg));
        }
        _LIBCUDACXX_INLINE_VISIBILITY void operator()(false_type) const
        {
          __this->__emplace<_Ip>(_Tp(_CUDA_VSTD::forward<_Arg>(__arg)));
        }
        __assignment* __this;
        _Arg&& __arg;
      } __impl{this, _CUDA_VSTD::forward<_Arg>(__arg)};
      __impl(integral_constant < bool,
             _LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, _Arg)
               || !_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Tp) > {});
    }
  }

  template <class _That>
  _LIBCUDACXX_INLINE_VISIBILITY void __generic_assign(_That&& __that)
  {
    if (this->valueless_by_exception() && __that.valueless_by_exception())
    {
      // do nothing.
    }
    else if (__that.valueless_by_exception())
    {
      this->__destroy();
    }
    else
    {
      __visitation::__base::__visit_alt_at(__that.index(), __visitor{this}, *this, _CUDA_VSTD::forward<_That>(__that));
    }
  }
};

template <class _Traits, _Trait = _Traits::__move_assignable_trait>
class _LIBCUDACXX_TEMPLATE_VIS __move_assignment;

#  define _LIBCUDACXX_VARIANT_MOVE_ASSIGNMENT(move_assignable_trait, move_assignment)            \
    template <class... _Types>                                                                   \
    class _LIBCUDACXX_TEMPLATE_VIS __move_assignment<__traits<_Types...>, move_assignable_trait> \
        : public __assignment<__traits<_Types...>>                                               \
    {                                                                                            \
      using __base_type = __assignment<__traits<_Types...>>;                                     \
                                                                                                 \
    public:                                                                                      \
      using __base_type::__base_type;                                                            \
      using __base_type::operator=;                                                              \
                                                                                                 \
      __move_assignment(const __move_assignment&)            = default;                          \
      __move_assignment(__move_assignment&&)                 = default;                          \
      ~__move_assignment()                                   = default;                          \
      __move_assignment& operator=(const __move_assignment&) = default;                          \
      move_assignment                                                                            \
    }

_LIBCUDACXX_VARIANT_MOVE_ASSIGNMENT(_Trait::_TriviallyAvailable,
                                    __move_assignment& operator=(__move_assignment&& __that) = default;);

_LIBCUDACXX_VARIANT_MOVE_ASSIGNMENT(
  _Trait::_Available,
  _LIBCUDACXX_INLINE_VISIBILITY __move_assignment&
  operator=(__move_assignment&& __that) noexcept(
    __all<(_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Types)
           && _LIBCUDACXX_TRAIT(is_nothrow_move_assignable, _Types))...>::value) {
    this->__generic_assign(_CUDA_VSTD::move(__that));
    return *this;
  });

_LIBCUDACXX_VARIANT_MOVE_ASSIGNMENT(_Trait::_Unavailable, __move_assignment& operator=(__move_assignment&&) = delete;);

#  undef _LIBCUDACXX_VARIANT_MOVE_ASSIGNMENT

template <class _Traits, _Trait = _Traits::__copy_assignable_trait>
class _LIBCUDACXX_TEMPLATE_VIS __copy_assignment;

#  define _LIBCUDACXX_VARIANT_COPY_ASSIGNMENT(copy_assignable_trait, copy_assignment)            \
    template <class... _Types>                                                                   \
    class _LIBCUDACXX_TEMPLATE_VIS __copy_assignment<__traits<_Types...>, copy_assignable_trait> \
        : public __move_assignment<__traits<_Types...>>                                          \
    {                                                                                            \
      using __base_type = __move_assignment<__traits<_Types...>>;                                \
                                                                                                 \
    public:                                                                                      \
      using __base_type::__base_type;                                                            \
      using __base_type::operator=;                                                              \
                                                                                                 \
      __copy_assignment(const __copy_assignment&)                       = default;               \
      __copy_assignment(__copy_assignment&&)                            = default;               \
      ~__copy_assignment()                                              = default;               \
      copy_assignment __copy_assignment& operator=(__copy_assignment&&) = default;               \
    }

_LIBCUDACXX_VARIANT_COPY_ASSIGNMENT(_Trait::_TriviallyAvailable,
                                    __copy_assignment& operator=(const __copy_assignment& __that) = default;);

_LIBCUDACXX_VARIANT_COPY_ASSIGNMENT(
  _Trait::_Available, _LIBCUDACXX_INLINE_VISIBILITY __copy_assignment& operator=(const __copy_assignment& __that) {
    this->__generic_assign(__that);
    return *this;
  });

_LIBCUDACXX_VARIANT_COPY_ASSIGNMENT(_Trait::_Unavailable,
                                    __copy_assignment& operator=(const __copy_assignment&) = delete;);

#  undef _LIBCUDACXX_VARIANT_COPY_ASSIGNMENT

template <class... _Types>
class _LIBCUDACXX_TEMPLATE_VIS __impl : public __copy_assignment<__traits<_Types...>>
{
  using __base_type = __copy_assignment<__traits<_Types...>>;

  struct __visitor
  {
    template <class _LeftAlt, class _RightAlt>
    _LIBCUDACXX_INLINE_VISIBILITY void operator()(_LeftAlt& __this_alt, _RightAlt& __that_alt) const
    {
      using _CUDA_VSTD::swap;
      swap(__this_alt.__value, __that_alt.__value);
    }
  };

public:
  using __base_type::__base_type; // get in_place_index_t constructor & friends
  __impl(__impl const&)            = default;
  __impl(__impl&&)                 = default;
  __impl& operator=(__impl const&) = default;
  __impl& operator=(__impl&&)      = default;

  template <size_t _Ip, class _Arg>
  _LIBCUDACXX_INLINE_VISIBILITY void __assign(_Arg&& __arg)
  {
    this->__assign_alt(__access::__base::__get_alt<_Ip>(*this), _CUDA_VSTD::forward<_Arg>(__arg));
  }

  inline _LIBCUDACXX_INLINE_VISIBILITY void __swap(__impl& __that)
  {
    if (this->valueless_by_exception() && __that.valueless_by_exception())
    {
      // do nothing.
    }
    else if (this->index() == __that.index())
    {
      __visitation::__base::__visit_alt_at(this->index(), __visitor{}, *this, __that);
    }
    else
    {
      __impl* __lhs = this;
      __impl* __rhs = _CUDA_VSTD::addressof(__that);
      if (__lhs->__move_nothrow() && !__rhs->__move_nothrow())
      {
        _CUDA_VSTD::swap(__lhs, __rhs);
      }
      __impl __tmp(_CUDA_VSTD::move(*__rhs));
#  ifndef _LIBCUDACXX_NO_EXCEPTIONS
      if constexpr (__all<_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Types)...>::value)
      {
        this->__generic_construct(*__rhs, _CUDA_VSTD::move(*__lhs));
      }
      else
      {
        // EXTENSION: When the move construction of `__lhs` into `__rhs` throws
        // and `__tmp` is nothrow move constructible then we move `__tmp` back
        // into `__rhs` and provide the strong exception safety guarantee.
        try
        {
          this->__generic_construct(*__rhs, _CUDA_VSTD::move(*__lhs));
        }
        catch (...)
        {
          if (__tmp.__move_nothrow())
          {
            this->__generic_construct(*__rhs, _CUDA_VSTD::move(__tmp));
          }
          throw;
        }
      }
#  else
      // this isn't consolidated with the `if constexpr` branch above due to
      // `throw` being ill-formed with exceptions disabled even when discarded.
      this->__generic_construct(*__rhs, _CUDA_VSTD::move(*__lhs));
#  endif
      this->__generic_construct(*__lhs, _CUDA_VSTD::move(__tmp));
    }
  }

private:
  inline _LIBCUDACXX_INLINE_VISIBILITY bool __move_nothrow() const
  {
    constexpr bool __results[] = {_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Types)...};
    return this->valueless_by_exception() || __results[this->index()];
  }
};

struct __no_narrowing_check
{
  template <class _Dest, class _Source>
  using _Apply = __type_identity<_Dest>;
};

struct __narrowing_check
{
  template <class _Dest, class _Source, class = void>
  struct __narrowing_check_impl
  {};

  template <class _Dest, class _Source>
  struct __narrowing_check_impl<_Dest, _Source, __void_t<decltype(_Dest{_CUDA_VSTD::declval<_Source>()})>>
  {
    using type = __type_identity<_Dest>;
  };

  template <class _Dest, class _Source>
  using _Apply _LIBCUDACXX_NODEBUG = typename __narrowing_check_impl<_Dest, _Source>::type;
};

template <class _Dest, class _Source>
using __check_for_narrowing _LIBCUDACXX_NODEBUG = typename _If<
#  ifdef _LIBCUDACXX_ENABLE_NARROWING_CONVERSIONS_IN_VARIANT
  false &&
#  endif
    _LIBCUDACXX_TRAIT(is_arithmetic, _Dest),
  __narrowing_check,
  __no_narrowing_check>::template _Apply<_Dest, _Source>;

template <class _Tp, size_t _Idx>
struct __overload
{
  template <class _Up>
  _LIBCUDACXX_INLINE_VISIBILITY auto operator()(_Tp, _Up&&) const -> __check_for_narrowing<_Tp, _Up>;
};

template <class _Tp, size_t>
struct __overload_bool
{
  template <class _Up, class _Ap = __remove_cvref_t<_Up>>
  _LIBCUDACXX_INLINE_VISIBILITY auto operator()(bool, _Up&&) const
    -> enable_if_t<_LIBCUDACXX_TRAIT(is_same, _Ap, bool), __type_identity<_Tp>>;
};

template <size_t _Idx>
struct __overload<bool, _Idx> : __overload_bool<bool, _Idx>
{};
template <size_t _Idx>
struct __overload<bool const, _Idx> : __overload_bool<bool const, _Idx>
{};
template <size_t _Idx>
struct __overload<bool volatile, _Idx> : __overload_bool<bool volatile, _Idx>
{};
template <size_t _Idx>
struct __overload<bool const volatile, _Idx> : __overload_bool<bool const volatile, _Idx>
{};

#  if _LIBCUDACXX_STD_VER > 14
template <class... _Bases>
struct __all_overloads : _Bases...
{
  _LIBCUDACXX_INLINE_VISIBILITY void operator()() const;
  using _Bases::operator()...;
};
#  else
template <class... _Bases>
struct __all_overloads;

template <class _Head, class _Next, class... _Bases>
struct __all_overloads<_Head, _Next, _Bases...>
    : _Head
    , __all_overloads<_Next, _Bases...>
{
  using _Head::operator();
  using __all_overloads<_Next, _Bases...>::operator();
};

template <class _Only>
struct __all_overloads<_Only> : _Only
{
  using _Only::operator();
};
#  endif

template <class IdxSeq>
struct __make_overloads_imp;

template <size_t... _Idx>
struct __make_overloads_imp<__tuple_indices<_Idx...>>
{
  template <class... _Types>
  using _Apply _LIBCUDACXX_NODEBUG = __all_overloads<__overload<_Types, _Idx>...>;
};

template <class... _Types>
using _MakeOverloads _LIBCUDACXX_NODEBUG =
  typename __make_overloads_imp<__make_indices_imp<sizeof...(_Types), 0>>::template _Apply<_Types...>;

template <class _Tp, class... _Types>
using __best_match_t = typename invoke_result_t<_MakeOverloads<_Types...>, _Tp, _Tp>::type;

struct __invalid_variant_constraints
{
  static constexpr bool __constructible         = false;
  static constexpr bool __nothrow_constructible = false;
  static constexpr bool __assignable            = false;
  static constexpr bool __nothrow_assignable    = false;
};

template <class... _Types>
struct __variant_constraints
{
  template <class _Arg, class _Tp = __best_match_t<_Arg, _Types...>>
  struct __match_construct
  {
    static constexpr size_t _Ip = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value;

    static constexpr bool __constructible         = _LIBCUDACXX_TRAIT(is_constructible, _Tp, _Arg);
    static constexpr bool __nothrow_constructible = _LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, _Arg);
  };

  template <size_t _Ip, class... _Args>
  struct __variadic_construct
  {
    using _Tp = variant_alternative_t<_Ip, variant<_Types...>>;

    static constexpr bool __constructible         = _LIBCUDACXX_TRAIT(is_constructible, _Tp, _Args...);
    static constexpr bool __nothrow_constructible = _LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, _Args...);
  };

  template <size_t _Ip, class _Up, class... _Args>
  struct __variadic_ilist_construct
  {
    using _Tp = variant_alternative_t<_Ip, variant<_Types...>>;

    static constexpr bool __constructible = _LIBCUDACXX_TRAIT(is_constructible, _Tp, initializer_list<_Up>&, _Args...);
    static constexpr bool __nothrow_constructible =
      _LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, initializer_list<_Up>&, _Args...);
  };

  template <class _Arg, class _Tp = __best_match_t<_Arg, _Types...>>
  struct __match_assign
  {
    static constexpr size_t _Ip = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value;

    static constexpr bool __assignable =
      _LIBCUDACXX_TRAIT(is_assignable, _Tp&, _Arg) && _LIBCUDACXX_TRAIT(is_constructible, _Tp, _Arg);
    static constexpr bool __nothrow_assignable =
      _LIBCUDACXX_TRAIT(is_nothrow_assignable, _Tp&, _Arg) && _LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, _Arg);
  };

  template <bool>
  struct __swappable
  {
    static constexpr bool __is_swappable =
      __all<(_LIBCUDACXX_TRAIT(is_move_constructible, _Types) && _LIBCUDACXX_TRAIT(is_swappable, _Types))...>::value;

    static constexpr bool __is_nothrow_swappable =
      __all<(_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Types)
             && _LIBCUDACXX_TRAIT(is_nothrow_swappable, _Types))...>::value;
  };
};
} // namespace __variant_detail

template <class... _Types>
class _LIBCUDACXX_TEMPLATE_VIS variant
    : private __sfinae_ctor_base<__all<_LIBCUDACXX_TRAIT(is_copy_constructible, _Types)...>::value,
                                 __all<_LIBCUDACXX_TRAIT(is_move_constructible, _Types)...>::value>
    , private __sfinae_assign_base<__all<(_LIBCUDACXX_TRAIT(is_copy_constructible, _Types)
                                          && _LIBCUDACXX_TRAIT(is_copy_assignable, _Types))...>::value,
                                   __all<(_LIBCUDACXX_TRAIT(is_move_constructible, _Types)
                                          && _LIBCUDACXX_TRAIT(is_move_assignable, _Types))...>::value>
{
  static_assert(0 < sizeof...(_Types), "variant must consist of at least one alternative.");

  static_assert(__all<!_LIBCUDACXX_TRAIT(is_array, _Types)...>::value,
                "variant can not have an array type as an alternative.");

  static_assert(__all<!_LIBCUDACXX_TRAIT(is_reference, _Types)...>::value,
                "variant can not have a reference type as an alternative.");

  static_assert(__all<!_LIBCUDACXX_TRAIT(is_void, _Types)...>::value,
                "variant can not have a void type as an alternative.");

  using __first_type  = variant_alternative_t<0, variant>;
  using __constraints = __variant_detail::__variant_constraints<_Types...>;

public:
  // Needs to be dependent to guard against incomplete types
  template <bool _Dummy = true,
            class       = enable_if_t<__dependent_type<is_default_constructible<__first_type>, _Dummy>::value>>
  _LIBCUDACXX_INLINE_VISIBILITY constexpr variant() noexcept(
    _LIBCUDACXX_TRAIT(is_nothrow_default_constructible, __first_type))
      : __impl_(in_place_index<0>)
  {}

  _LIBCUDACXX_HIDE_FROM_ABI constexpr variant(const variant&) = default;
  _LIBCUDACXX_HIDE_FROM_ABI constexpr variant(variant&&)      = default;

  template <class _Arg>
  using __match_construct =
    _If<!_LIBCUDACXX_TRAIT(is_same, __remove_cvref_t<_Arg>, variant)
          && !__is_inplace_type<__remove_cvref_t<_Arg>>::value //
          && !__is_inplace_index<__remove_cvref_t<_Arg>>::value,
        typename __constraints::template __match_construct<_Arg>,
        __variant_detail::__invalid_variant_constraints>;

  // CTAD fails if we do not SFINAE the empty variant away first
  template <class _Arg,
            class              = enable_if_t<sizeof...(_Types) != 0>,
            class _Constraints = __match_construct<_Arg>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY constexpr variant(_Arg&& __arg) noexcept(_Constraints::__nothrow_constructible)
      : __impl_(in_place_index<_Constraints::_Ip>, _CUDA_VSTD::forward<_Arg>(__arg))
  {}

  template <size_t _Ip, class... _Args>
  using __variadic_construct =
    _If<(_Ip < sizeof...(_Types)),
        typename __constraints::template __variadic_construct<_Ip, _Args...>,
        __variant_detail::__invalid_variant_constraints>;

  template <size_t _Ip,
            class... _Args,
            class _Constraints = __variadic_construct<_Ip, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr variant(in_place_index_t<_Ip>, _Args&&... __args) noexcept(
    _Constraints::__nothrow_constructible)
      : __impl_(in_place_index<_Ip>, _CUDA_VSTD::forward<_Args>(__args)...)
  {}

  template <size_t _Ip, class _Up, class... _Args>
  using __variadic_ilist_construct =
    _If<(_Ip < sizeof...(_Types)),
        typename __constraints::template __variadic_ilist_construct<_Ip, _Up, _Args...>,
        __variant_detail::__invalid_variant_constraints>;

  template <size_t _Ip,
            class _Up,
            class... _Args,
            class _Constraints = __variadic_ilist_construct<_Ip, _Up, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr variant(
    in_place_index_t<_Ip>, initializer_list<_Up> __il, _Args&&... __args) noexcept(_Constraints::__nothrow_constructible)
      : __impl_(in_place_index<_Ip>, __il, _CUDA_VSTD::forward<_Args>(__args)...)
  {}

  template <class _Tp,
            class... _Args,
            size_t _Ip         = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
            class _Constraints = __variadic_construct<_Ip, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr variant(in_place_type_t<_Tp>, _Args&&... __args) noexcept(
    _Constraints::__nothrow_constructible)
      : __impl_(in_place_index<_Ip>, _CUDA_VSTD::forward<_Args>(__args)...)
  {}

  template <class _Tp,
            class _Up,
            class... _Args,
            size_t _Ip         = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
            class _Constraints = __variadic_ilist_construct<_Ip, _Up, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY explicit constexpr variant(
    in_place_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args) noexcept(_Constraints::__nothrow_constructible)
      : __impl_(in_place_index<_Ip>, __il, _CUDA_VSTD::forward<_Args>(__args)...)
  {}

  _LIBCUDACXX_HIDE_FROM_ABI ~variant() = default;

  _LIBCUDACXX_HIDE_FROM_ABI constexpr variant& operator=(const variant&) = default;
  _LIBCUDACXX_HIDE_FROM_ABI constexpr variant& operator=(variant&&)      = default;

  template <class _Arg>
  using __match_assign =
    _If<!_LIBCUDACXX_TRAIT(is_same, __remove_cvref_t<_Arg>, variant),
        typename __constraints::template __match_assign<_Arg>,
        __variant_detail::__invalid_variant_constraints>;

  template <class _Arg, class _Constraints = __match_assign<_Arg>, class = enable_if_t<_Constraints::__assignable>>
  _LIBCUDACXX_INLINE_VISIBILITY variant& operator=(_Arg&& __arg) noexcept(_Constraints::__nothrow_assignable)
  {
    __impl_.template __assign<_Constraints::_Ip>(_CUDA_VSTD::forward<_Arg>(__arg));
    return *this;
  }

  template <size_t _Ip,
            class... _Args,
            class _Constraints = __variadic_construct<_Ip, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY typename _Constraints::_Tp& emplace(_Args&&... __args)
  {
    return __impl_.template __emplace<_Ip>(_CUDA_VSTD::forward<_Args>(__args)...);
  }

  template <size_t _Ip,
            class _Up,
            class... _Args,
            class _Constraints = __variadic_ilist_construct<_Ip, _Up, _Args...>,
            class              = enable_if_t<_Constraints::__constructible>>
  _LIBCUDACXX_INLINE_VISIBILITY typename _Constraints::_Tp& emplace(initializer_list<_Up> __il, _Args&&... __args)
  {
    return __impl_.template __emplace<_Ip>(__il, _CUDA_VSTD::forward<_Args>(__args)...);
  }

  template <class _Tp,
            class... _Args,
            size_t _Ip = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
            enable_if_t<_LIBCUDACXX_TRAIT(is_constructible, _Tp, _Args...), int> = 0>
  _LIBCUDACXX_INLINE_VISIBILITY _Tp& emplace(_Args&&... __args)
  {
    return __impl_.template __emplace<_Ip>(_CUDA_VSTD::forward<_Args>(__args)...);
  }

  template <class _Tp,
            class _Up,
            class... _Args,
            size_t _Ip = __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
            enable_if_t<_LIBCUDACXX_TRAIT(is_constructible, _Tp, initializer_list<_Up>&, _Args...), int> = 0>
  _LIBCUDACXX_INLINE_VISIBILITY _Tp& emplace(initializer_list<_Up> __il, _Args&&... __args)
  {
    return __impl_.template __emplace<_Ip>(__il, _CUDA_VSTD::forward<_Args>(__args)...);
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr bool valueless_by_exception() const noexcept
  {
    return __impl_.valueless_by_exception();
  }

  _LIBCUDACXX_INLINE_VISIBILITY constexpr size_t index() const noexcept
  {
    return __impl_.index();
  }

  // Needs to be dependent to guard against incomplete types
  template <bool _Dummy>
  using __swap_constraint =
    __dependent_type<typename __variant_detail::__variant_constraints<_Types...>::template __swappable<_Dummy>, _Dummy>;

  template <bool _Dummy       = true,
            class _Constraint = __swap_constraint<_Dummy>,
            class             = enable_if_t<_Constraint::__is_swappable>>
  _LIBCUDACXX_INLINE_VISIBILITY void swap(variant& __that) noexcept(_Constraint::__is_nothrow_swappable)
  {
    __impl_.__swap(__that.__impl_);
  }

private:
  __variant_detail::__impl<_Types...> __impl_;

  friend struct __variant_detail::__access::__variant;
  friend struct __variant_detail::__visitation::__variant;
};

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool __holds_alternative(const variant<_Types...>& __v) noexcept
{
  return __v.index() == _Ip;
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool holds_alternative(const variant<_Types...>& __v) noexcept
{
  return _CUDA_VSTD::__holds_alternative<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <size_t _Ip, class _Vp>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr auto&& __generic_get(_Vp&& __v)
{
  using __variant_detail::__access::__variant;
  if (!_CUDA_VSTD::__holds_alternative<_Ip>(__v))
  {
    __throw_bad_variant_access();
  }
  return __variant::__get_alt<_Ip>(_CUDA_VSTD::forward<_Vp>(__v)).__value;
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr variant_alternative_t<
  _Ip,
  variant<_Types...>>&
get(variant<_Types...>& __v)
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr variant_alternative_t<
  _Ip,
  variant<_Types...>>&&
get(variant<_Types...>&& __v)
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get<_Ip>(_CUDA_VSTD::move(__v));
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr const variant_alternative_t<
  _Ip,
  variant<_Types...>>&
get(const variant<_Types...>& __v)
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr const variant_alternative_t<
  _Ip,
  variant<_Types...>>&&
get(const variant<_Types...>&& __v)
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get<_Ip>(_CUDA_VSTD::move(__v));
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr _Tp&
get(variant<_Types...>& __v)
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr _Tp&&
get(variant<_Types...>&& __v)
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(_CUDA_VSTD::move(__v));
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr const _Tp&
get(const variant<_Types...>& __v)
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr const _Tp&&
get(const variant<_Types...>&& __v)
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(_CUDA_VSTD::move(__v));
}

template <size_t _Ip, class _Vp>
_LIBCUDACXX_INLINE_VISIBILITY constexpr auto* __generic_get_if(_Vp* __v) noexcept
{
  using __variant_detail::__access::__variant;
  return __v && _CUDA_VSTD::__holds_alternative<_Ip>(*__v)
         ? _CUDA_VSTD::addressof(__variant::__get_alt<_Ip>(*__v).__value)
         : nullptr;
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr add_pointer_t<variant_alternative_t<_Ip, variant<_Types...>>>
get_if(variant<_Types...>* __v) noexcept
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get_if<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr add_pointer_t<const variant_alternative_t<_Ip, variant<_Types...>>>
get_if(const variant<_Types...>* __v) noexcept
{
  static_assert(_Ip < sizeof...(_Types), "");
  static_assert(!_LIBCUDACXX_TRAIT(is_void, variant_alternative_t<_Ip, variant<_Types...>>), "");
  return _CUDA_VSTD::__generic_get_if<_Ip>(__v);
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr add_pointer_t<_Tp> get_if(variant<_Types...>* __v) noexcept
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr add_pointer_t<const _Tp> get_if(const variant<_Types...>* __v) noexcept
{
  static_assert(!_LIBCUDACXX_TRAIT(is_void, _Tp), "");
  return _CUDA_VSTD::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Operator>
struct __convert_to_bool
{
  template <class _T1, class _T2>
  _LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator()(_T1&& __t1, _T2&& __t2) const
  {
    static_assert(
      _LIBCUDACXX_TRAIT(
        is_convertible, decltype(_Operator{}(_CUDA_VSTD::forward<_T1>(__t1), _CUDA_VSTD::forward<_T2>(__t2))), bool),
      "the relational operator does not return a type which is "
      "implicitly convertible to bool");
    return _Operator{}(_CUDA_VSTD::forward<_T1>(__t1), _CUDA_VSTD::forward<_T2>(__t2));
  }
};

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator==(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index())
  {
    return false;
  }
  if (__lhs.valueless_by_exception())
  {
    return true;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<equal_to<>>{}, __lhs, __rhs);
}

#  ifndef _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR

template <class... _Types>
  requires(three_way_comparable<_Types> && ...)
_LIBCUDACXX_INLINE_VISIBILITY constexpr common_comparison_category_t<compare_three_way_result_t<_Types>...>
operator<=>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  using __result_t = common_comparison_category_t<compare_three_way_result_t<_Types>...>;
  if (__lhs.valueless_by_exception() && __rhs.valueless_by_exception())
  {
    return strong_ordering::equal;
  }
  if (__lhs.valueless_by_exception())
  {
    return strong_ordering::less;
  }
  if (__rhs.valueless_by_exception())
  {
    return strong_ordering::greater;
  }
  if (auto __c = __lhs.index() <=> __rhs.index(); __c != 0)
  {
    return __c;
  }
  auto __three_way = []<class _Type>(const _Type& __v, const _Type& __w) -> __result_t {
    return __v <=> __w;
  };
  return __variant::__visit_value_at(__lhs.index(), __three_way, __lhs, __rhs);
}

#  endif // !_LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator!=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index())
  {
    return true;
  }
  if (__lhs.valueless_by_exception())
  {
    return false;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<not_equal_to<>>{}, __lhs, __rhs);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator<(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception())
  {
    return false;
  }
  if (__lhs.valueless_by_exception())
  {
    return true;
  }
  if (__lhs.index() < __rhs.index())
  {
    return true;
  }
  if (__lhs.index() > __rhs.index())
  {
    return false;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<less<>>{}, __lhs, __rhs);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception())
  {
    return false;
  }
  if (__rhs.valueless_by_exception())
  {
    return true;
  }
  if (__lhs.index() > __rhs.index())
  {
    return true;
  }
  if (__lhs.index() < __rhs.index())
  {
    return false;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<greater<>>{}, __lhs, __rhs);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator<=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception())
  {
    return true;
  }
  if (__rhs.valueless_by_exception())
  {
    return false;
  }
  if (__lhs.index() < __rhs.index())
  {
    return true;
  }
  if (__lhs.index() > __rhs.index())
  {
    return false;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<less_equal<>>{}, __lhs, __rhs);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr bool operator>=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
{
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception())
  {
    return true;
  }
  if (__lhs.valueless_by_exception())
  {
    return false;
  }
  if (__lhs.index() > __rhs.index())
  {
    return true;
  }
  if (__lhs.index() < __rhs.index())
  {
    return false;
  }
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<greater_equal<>>{}, __lhs, __rhs);
}

template <class... _Vs>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr void
__throw_if_valueless(_Vs&&... __vs)
{
  int __unused[] = {
    (_CUDA_VSTD::__as_variant(__vs).valueless_by_exception() ? __throw_bad_variant_access() : void(), 0)..., 0};
  (void) __unused[0];
}

template <class _Visitor,
          class... _Vs,
          typename = void_t<decltype(_CUDA_VSTD::__as_variant(_CUDA_VSTD::declval<_Vs>()))...>>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr decltype(auto)
visit(_Visitor&& __visitor, _Vs&&... __vs)
{
  using __variant_detail::__visitation::__variant;
  _CUDA_VSTD::__throw_if_valueless(_CUDA_VSTD::forward<_Vs>(__vs)...);
  return __variant::__visit_value(_CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Vs>(__vs)...);
}

template <class _Rp,
          class _Visitor,
          class... _Vs,
          typename = void_t<decltype(_CUDA_VSTD::__as_variant(_CUDA_VSTD::declval<_Vs>()))...>>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_AVAILABILITY_THROW_BAD_VARIANT_ACCESS constexpr _Rp
visit(_Visitor&& __visitor, _Vs&&... __vs)
{
  using __variant_detail::__visitation::__variant;
  _CUDA_VSTD::__throw_if_valueless(_CUDA_VSTD::forward<_Vs>(__vs)...);
  return __variant::__visit_value<_Rp>(_CUDA_VSTD::forward<_Visitor>(__visitor), _CUDA_VSTD::forward<_Vs>(__vs)...);
}

template <class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY auto
swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs) noexcept(noexcept(__lhs.swap(__rhs)))
  -> decltype(__lhs.swap(__rhs))
{
  return __lhs.swap(__rhs);
}

#  ifndef __cuda_std__
template <class... _Types>
struct _LIBCUDACXX_TEMPLATE_VIS hash<__enable_hash_helper<variant<_Types...>, remove_const_t<_Types>...>>
{
  using argument_type = variant<_Types...>;
  using result_type   = size_t;

  _LIBCUDACXX_INLINE_VISIBILITY result_type operator()(const argument_type& __v) const
  {
    using __variant_detail::__visitation::__variant;
    size_t __res =
      __v.valueless_by_exception()
        ? 299792458 // Random value chosen by the universe upon creation
        : __variant::__visit_alt(
          [](const auto& __alt) {
            using __alt_type   = __remove_cvref_t<decltype(__alt)>;
            using __value_type = remove_const_t<typename __alt_type::__value_type>;
            return hash<__value_type>{}(__alt.__value);
          },
          __v);
    return _CUDA_VSTD::__hash_combine(__res, hash<size_t>{}(__v.index()));
  }
};
#  endif // __cuda_std__

// __unchecked_get is the same as _CUDA_VSTD::get, except, it is UB to use it
// with the wrong type whereas _CUDA_VSTD::get will throw or returning nullptr.
// This makes it faster than _CUDA_VSTD::get.
template <size_t _Ip, class _Vp>
_LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __unchecked_get(_Vp&& __v) noexcept
{
  using __variant_detail::__access::__variant;
  return __variant::__get_alt<_Ip>(_CUDA_VSTD::forward<_Vp>(__v)).__value;
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __unchecked_get(const variant<_Types...>& __v) noexcept
{
  return _CUDA_VSTD::__unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
_LIBCUDACXX_INLINE_VISIBILITY constexpr auto&& __unchecked_get(variant<_Types...>& __v) noexcept
{
  return _CUDA_VSTD::__unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

_LIBCUDACXX_END_NAMESPACE_STD

#endif // _LIBCUDACXX_STD_VER >= 14

#endif // _LIBCUDACXX_VARIANT
