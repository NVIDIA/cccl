// -*- C++ -*-
//===---------------------------- cmath -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_CMATH
#define _LIBCUDACXX_CMATH

/*
    cmath synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

namespace std
{

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

double       hypot(double x, double y, double z);                // C++17
float        hypot(float x, float y, float z);                   // C++17
long double  hypot(long double x, long double y, long double z); // C++17

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

}  // std

*/

#ifndef __cuda_std__
#include <__config>
#endif // __cuda_std__

#if !defined(__CUDACC_RTC__) || !defined(__cuda_std__)
#include <math.h>
#endif

#if defined(__cuda_std__) && defined(_LIBCUDACXX_COMPILER_NVHPC)
#include <cmath>
#endif

#include "limits"
#include "type_traits"
#include "version"

#ifndef __cuda_std__
#include <__pragma_push>
#endif // __cuda_std__

#ifdef __cuda_std__
#include <cuda_fp16.h>
#ifndef _LIBCUDACXX_HAS_NO_NVBF16
#include <cuda_bf16.h>
#endif
#endif

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#ifdef _LIBCUDACXX_COMPILER_NVRTC
#include "climits"
#define INFINITY __builtin_huge_val()
#define NAN      __builtin_nan()
#endif

_LIBCUDACXX_BEGIN_NAMESPACE_STD

using ::signbit;
using ::isfinite;
using ::isinf;
using ::isnan;

using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;

using ::log;
using ::logf;

using ::hypot;
using ::hypotf;

#ifndef _AIX
using ::abs;
#endif

#ifndef _LIBCUDACXX_COMPILER_NVRTC

using ::fpclassify;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;

using ::isunordered;

using ::float_t;
using ::double_t;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;

#endif // _LIBCUDACXX_COMPILER_NVRTC

#if _CCCL_STD_VER > 2014 && !defined(__cuda_std__)
inline _LIBCUDACXX_INLINE_VISIBILITY float       hypot(       float x,       float y,       float z ) { return sqrt(x*x + y*y + z*z); }
inline _LIBCUDACXX_INLINE_VISIBILITY double      hypot(      double x,      double y,      double z ) { return sqrt(x*x + y*y + z*z); }
#ifdef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
inline _LIBCUDACXX_INLINE_VISIBILITY long double hypot( long double x, long double y, long double z ) { return sqrt(x*x + y*y + z*z); }
#endif

template <class _A1, class _A2, class _A3>
inline _LIBCUDACXX_INLINE_VISIBILITY
__enable_if_t
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}
#endif

#ifndef _LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS
#define _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
#else
#define _LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX
#endif // _LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS

#ifdef __cuda_std__

inline _LIBCUDACXX_INLINE_VISIBILITY
__half sin(__half __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hsin(__v);),
        ({
            float __vf = __v;
            __vf = _CUDA_VSTD::sin(__vf);
            __half_raw __ret_repr = __float2half_rn(__vf);

            uint16_t __repr = __half_raw(__v).x;
            switch (__repr) {
            case 12979:
            case 45747:
                __ret_repr.x += 1;
                break;

            case 23728:
            case 56496:
                __ret_repr.x -= 1;
                break;

            default:
                ;
            }

            return __ret_repr;
        })
    )
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 sin(__nv_bfloat16 __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hsin(__v);),
        (return __nv_bfloat16(_CUDA_VSTD::sin(float(__v)));)
    )
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half sinh(__half __v)
{
    return __half(_CUDA_VSTD::sinh(float(__v)));
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 sinh(__nv_bfloat16 __v)
{
    return __nv_bfloat16(_CUDA_VSTD::sinh(float(__v)));
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half cos(__half __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hcos(__v);),
        ({
            float __vf = __v;
            __vf = _CUDA_VSTD::cos(__vf);
            __half_raw __ret_repr = __float2half_rn(__vf);

            uint16_t __repr = __half_raw(__v).x;
            switch (__repr) {
            case 11132:
            case 43900:
                __ret_repr.x += 1;
                break;

            default:
                ;
            }

            return __ret_repr;
        })
    )
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 cos(__nv_bfloat16 __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hcos(__v);),
        (return __nv_bfloat16(_CUDA_VSTD::cos(float(__v)));)
    )
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half cosh(__half __v)
{
    return __half(_CUDA_VSTD::cosh(float(__v)));
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 cosh(__nv_bfloat16 __v)
{
    return __nv_bfloat16(_CUDA_VSTD::cosh(float(__v)));
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half exp(__half __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hexp(__v);),
        ({
            float __vf = __v;
            __vf = _CUDA_VSTD::exp(__vf);
            __half_raw __ret_repr = __float2half_rn(__vf);

            uint16_t __repr = __half_raw(__v).x;
            switch (__repr) {
            case 8057:
            case 9679:
                __ret_repr.x -= 1;
                break;

            default:
                ;
            }

            return __ret_repr;
        })
    )
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 exp(__nv_bfloat16 __v)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hexp(__v);),
        (return __nv_bfloat16(_CUDA_VSTD::exp(float(__v)));)
    )
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
bool signbit(__half __v)
{
    return ::signbit(__half2float(__v));
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool signbit(__nv_bfloat16 __v)
{
    return ::signbit(__bfloat162float(__v));
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half atan2(__half __x, __half __y)
{
    return __half(_CUDA_VSTD::atan2(float(__x), float(__y)));
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 atan2(__nv_bfloat16 __x, __nv_bfloat16 __y)
{
    return __nv_bfloat16(_CUDA_VSTD::atan2(float(__x), float(__y)));
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half log(__half __x)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hlog(__x);),
        ({
            float __vf = __x;
            __vf = _CUDA_VSTD::log(__vf);
            __half_raw __ret_repr = __float2half_rn(__vf);

            uint16_t __repr = __half_raw(__x).x;
            switch (__repr) {
            case 7544:
                __ret_repr.x -= 1;
                break;

            default:
                ;
            }

            return __ret_repr;
        })
    )
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 log(__nv_bfloat16 __x)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hlog(__x);),
        (return __nv_bfloat16(_CUDA_VSTD::log(float(__x)));)
    )
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half sqrt(__half __x)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hsqrt(__x);),
        (return __half(_CUDA_VSTD::sqrt(float(__x)));)
    )
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 sqrt(__nv_bfloat16 __x)
{
    NV_IF_ELSE_TARGET(NV_IS_DEVICE,
        (return hsqrt(__x);),
        (return __nv_bfloat16(_CUDA_VSTD::sqrt(float(__x)));)
    )
}
#endif
#endif

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<is_floating_point<_A1>::value, bool>
__constexpr_isnan(_A1 __lcpp_x) noexcept
{
#if defined(_LIBCUDACXX_CUDACC_BELOW_11_8)
    return __isnan(__lcpp_x);
#elif __has_builtin(__builtin_isnan)
    return __builtin_isnan(__lcpp_x);
#else
    return isnan(__lcpp_x);
#endif
}

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<!is_floating_point<_A1>::value, bool>
__constexpr_isnan(_A1 __lcpp_x) noexcept
{
    return isnan(__lcpp_x);
}

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isnan(__half __x) noexcept
{
    return __hisnan(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
bool isnan(__half __v)
{
    return __constexpr_isnan(__v);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isnan(__nv_bfloat16 __x) noexcept
{
    return __hisnan(__x);
}
#endif

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool isnan(__nv_bfloat16 __v)
{
    return __constexpr_isnan(__v);
}
#endif
#endif

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<is_floating_point<_A1>::value, bool>
__constexpr_isinf(_A1 __lcpp_x) noexcept
{
#if defined(_LIBCUDACXX_CUDACC_BELOW_11_8)
    return __isinf(__lcpp_x);
#elif __has_builtin(__builtin_isinf)
    return __builtin_isinf(__lcpp_x);
#else
    return isinf(__lcpp_x);
#endif
}

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<!is_floating_point<_A1>::value, bool>
__constexpr_isinf(_A1 __lcpp_x) noexcept
{
    return isinf(__lcpp_x);
}

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isinf(__half __x) noexcept {
#if _LIBCUDACXX_STD_VER >= 20
    // There's some sort of a bug with C++20 here.
    // XXX nvbug number pending
    return !__hisnan(__x) && __hisnan(__x - __x);
#else
    return __hisinf(__x) != 0;
#endif
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isinf(__nv_bfloat16 __x) noexcept {
#if _LIBCUDACXX_STD_VER >= 20
    // There's some sort of a bug with C++20 here.
    // XXX nvbug number pending
    return !__hisnan(__x) && __hisnan(__x - __x);
#else
    return __hisinf(__x) != 0;
#endif
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
bool isinf(__half __v)
{
    return __constexpr_isinf(__v);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool isinf(__nv_bfloat16 __v)
{
    return __constexpr_isinf(__v);
}
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
__half hypot(__half __x, __half __y)
{
    return __half(_CUDA_VSTD::hypot(float(__x), float(__y)));
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 hypot(__nv_bfloat16 __x, __nv_bfloat16 __y)
{
    return __nv_bfloat16(_CUDA_VSTD::hypot(float(__x), float(__y)));
}
#endif
#endif

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<is_floating_point<_A1>::value, bool>
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{
#if defined(_LIBCUDACXX_CUDACC_BELOW_11_8)
    return !__isinf(__lcpp_x) && !__isnan(__lcpp_x);
#elif __has_builtin(__builtin_isfinite)
    return __builtin_isfinite(__lcpp_x);
#else
    return isfinite(__lcpp_x);
#endif
}

template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr __enable_if_t<!is_floating_point<_A1>::value, bool>
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{
    return isfinite(__lcpp_x);
}

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isfinite(__half __x) noexcept {
    return !__constexpr_isnan(__x) && !__constexpr_isinf(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
bool isfinite(__half __v)
{
    return __constexpr_isfinite(__v);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
bool __constexpr_isfinite(__nv_bfloat16 __x) noexcept {
    return !__constexpr_isnan(__x) && !__constexpr_isinf(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
bool isfinite(__nv_bfloat16 __v)
{
    return __constexpr_isfinite(__v);
}
#endif
#endif

#if defined(_MSC_VER) || defined(__CUDACC_RTC__) || defined(_LIBCUDACXX_COMPILER_CLANG_CUDA)
template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
_A1 __constexpr_copysign(_A1 __x, _A1 __y) noexcept
{
    return copysign(__x, __y);
}
#else
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 float __constexpr_copysign(float __x, float __y) noexcept {
    return __builtin_copysignf(__x, __y);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 double __constexpr_copysign(double __x, double __y) noexcept {
    return __builtin_copysign(__x, __y);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 long double __constexpr_copysign(long double __x, long double __y) noexcept {
    return __builtin_copysignl(__x, __y);
}

template <class _A1, class _A2>
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 typename __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value,
                                __promote<_A1, _A2> >::type
    __constexpr_copysign(_A1 __x, _A2 __y) noexcept {
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
    return __builtin_copysign((__result_type)__x, (__result_type)__y);
}
#endif // !_MSC_VER

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
__half __constexpr_copysign(__half __x, __half __y) noexcept
{
    return __half(_CUDA_VSTD::copysign(float(__x), float(__y)));
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__half copysign(__half __x, __half __y)
{
    return __constexpr_copysign(__x, __y);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 __constexpr_copysign(__nv_bfloat16 __x, __nv_bfloat16 __y) noexcept
{
    return __nv_bfloat16(_CUDA_VSTD::copysign(float(__x), float(__y)));
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 copysign(__nv_bfloat16 __x, __nv_bfloat16 __y)
{
    return __constexpr_copysign(__x, __y);
}
#endif
#endif

#if defined(_MSC_VER) || defined(__CUDACC_RTC__) || defined(_LIBCUDACXX_COMPILER_CLANG_CUDA)
template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
_A1 __constexpr_fabs(_A1 __x) noexcept
{
    return fabs(__x);
}
#else
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 float __constexpr_fabs(float __x) noexcept {
    return __builtin_fabsf(__x);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 double __constexpr_fabs(double __x) noexcept {
    return __builtin_fabs(__x);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 long double __constexpr_fabs(long double __x) noexcept {
    return __builtin_fabsl(__x);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11 double __constexpr_fabs(_Tp __x) noexcept {
    return __builtin_fabs(static_cast<double>(__x));
}
#endif // !_MSC_VER

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
__half __constexpr_fabs(__half __x) noexcept
{
    return __habs(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__half fabs(__half __x)
{
    return __constexpr_fabs(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__half abs(__half __x)
{
    return __constexpr_fabs(__x);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 __constexpr_fabs(__nv_bfloat16 __x) noexcept
{
    return __habs(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 fabs(__nv_bfloat16 __x)
{
    return __constexpr_fabs(__x);
}

inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 abs(__nv_bfloat16 __x)
{
    return __constexpr_fabs(__x);
}
#endif
#endif

#if defined(_MSC_VER) || defined(__CUDACC_RTC__) || defined(_LIBCUDACXX_COMPILER_CLANG_CUDA)
template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
_A1 __constexpr_fmax(_A1 __x, _A1 __y) noexcept
{
    return fmax(__x, __y);
}
#else
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX float __constexpr_fmax(float __x, float __y) noexcept {
#if defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED) && !defined(_LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS)
  if (_LIBCUDACXX_IS_CONSTANT_EVALUATED()) {
    if (__constexpr_isnan(__x))
      return __y;
    if (__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
#endif // defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
  return __builtin_fmaxf(__x, __y);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX double __constexpr_fmax(double __x, double __y) noexcept {
#if defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED) && !defined(_LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS)
  if (_LIBCUDACXX_IS_CONSTANT_EVALUATED()) {
    if (__constexpr_isnan(__x))
      return __y;
    if (__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
#endif // defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
  return __builtin_fmax(__x, __y);
}

inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX long double __constexpr_fmax(long double __x, long double __y) noexcept {
#if defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED) && !defined(_LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS)
  if (_LIBCUDACXX_IS_CONSTANT_EVALUATED()) {
    if (__constexpr_isnan(__x))
      return __y;
    if (__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
#endif // defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
  return __builtin_fmax(__x, __y);
}

template <class _Tp, class _Up, __enable_if_t<is_arithmetic<_Tp>::value && is_arithmetic<_Up>::value, int> = 0>
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX typename __promote<_Tp, _Up>::type
__constexpr_fmax(_Tp __x, _Up __y) noexcept {
  using __result_type = typename __promote<_Tp, _Up>::type;
  return _CUDA_VSTD::__constexpr_fmax(static_cast<__result_type>(__x), static_cast<__result_type>(__y));
}
#endif // !_MSC_VER

#ifdef __cuda_std__
inline _LIBCUDACXX_INLINE_VISIBILITY
__half __constexpr_fmax(__half __x, __half __y) noexcept
{
    return __hmax(__x, __y);
}

#ifndef _LIBCUDACXX_HAS_NO_NVBF16
inline _LIBCUDACXX_INLINE_VISIBILITY
__nv_bfloat16 __constexpr_fmax(__nv_bfloat16 __x, __nv_bfloat16 __y) noexcept
{
    return __hmax(__x, __y);
}
#endif
#endif

#if defined(_MSC_VER) || defined(__CUDACC_RTC__) || defined(_LIBCUDACXX_COMPILER_CLANG_CUDA)
template <class _A1>
_LIBCUDACXX_INLINE_VISIBILITY
_A1 __constexpr_logb(_A1 __x)
{
    return logb(__x);
}
#else
template <class _Tp>
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX _Tp __constexpr_logb(_Tp __x) {
#if defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED) && !defined(_LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS)
  if (_LIBCUDACXX_IS_CONSTANT_EVALUATED()) {
    if (__x == _Tp(0)) {
      // raise FE_DIVBYZERO
      return -numeric_limits<_Tp>::infinity();
    }

    if (__constexpr_isinf(__x))
      return numeric_limits<_Tp>::infinity();

    if (__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    __x = __constexpr_fabs(__x);
    unsigned long long __exp = 0;
    while (__x >= _Tp(numeric_limits<_Tp>::radix)) {
      __x /= numeric_limits<_Tp>::radix;
      __exp += 1;
    }
    return _Tp(__exp);
  }
#endif // defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
  return __builtin_logb(__x);
}
#endif // !_MSVC

#if defined(_MSC_VER) || defined(__CUDACC_RTC__) || defined(_LIBCUDACXX_COMPILER_CLANG_CUDA)
template <class _Tp>
inline _LIBCUDACXX_INLINE_VISIBILITY
_Tp __constexpr_scalbn(_Tp __x, int __i) {
    return static_cast<_Tp>(scalbn(static_cast<double>(__x), __i));
}

template <>
inline _LIBCUDACXX_INLINE_VISIBILITY
float __constexpr_scalbn<float>(float __x, int __i) {
    return scalbnf(__x, __i);
}

template <>
inline _LIBCUDACXX_INLINE_VISIBILITY
double __constexpr_scalbn<double>(double __x, int __i) {
    return scalbn(__x, __i);
}

#ifndef _LIBCUDACXX_HAS_NO_LONG_DOUBLE
template <>
inline _LIBCUDACXX_INLINE_VISIBILITY
long double __constexpr_scalbn<long double>(long double __x, int __i) {
    return scalbnl(__x, __i);
}
#endif // _LIBCUDACXX_HAS_NO_LONG_DOUBLE
#else
template <class _Tp>
inline _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY
_LIBCUDACXX_CONSTEXPR_AFTER_CXX11_COMPLEX _Tp __constexpr_scalbn(_Tp __x, int __exp) {
#if defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED) && !defined(_LIBCUDACXX_HAS_NO_CONSTEXPR_COMPLEX_OPERATIONS)
 if (_LIBCUDACXX_IS_CONSTANT_EVALUATED()) {
    if (__x == _Tp(0))
      return __x;

    if (__constexpr_isinf(__x))
      return __x;

    if (_Tp(__exp) == _Tp(0))
      return __x;

    if (__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    _Tp __mult(1);
    if (__exp > 0) {
      __mult = numeric_limits<_Tp>::radix;
      --__exp;
    } else {
      ++__exp;
      __exp = -__exp;
      __mult /= numeric_limits<_Tp>::radix;
    }

    while (__exp > 0) {
      if (!(__exp & 1)) {
        __mult *= __mult;
        __exp >>= 1;
      } else {
        __x *= __mult;
        --__exp;
      }
    }
    return __x;
  }
#endif // defined(_LIBCUDACXX_IS_CONSTANT_EVALUATED)
  return __builtin_scalbn(__x, __exp);
}
#endif // !_MSC_VER

#if _CCCL_STD_VER > 2017
template <typename _Fp>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr _Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept {
    if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
        return __t * __b + (1 - __t) * __a;

    if (__t == 1) return __b;
    const _Fp __x = __a + __t * (__b - __a);
    if (__t > 1 == __b > __a)
    	return __b < __x ? __x : __b;
    else
    	return __x < __b ? __x : __b;
}

_LIBCUDACXX_INLINE_VISIBILITY
constexpr float
lerp(float __a, float __b, float __t)                   noexcept { return __lerp(__a, __b, __t); }

_LIBCUDACXX_INLINE_VISIBILITY
constexpr double
lerp(double __a, double __b, double __t)                noexcept { return __lerp(__a, __b, __t); }

_LIBCUDACXX_INLINE_VISIBILITY
constexpr long double
lerp(long double __a, long double __b, long double __t) noexcept { return __lerp(__a, __b, __t); }

#endif // _CCCL_STD_VER > 2017

template <class _IntT, class _FloatT,
    bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),
    int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>
_LIBCUDACXX_INLINE_VISIBILITY
constexpr _IntT __max_representable_int_for_float() noexcept {
  static_assert(is_floating_point<_FloatT>::value, "must be a floating point type");
  static_assert(is_integral<_IntT>::value, "must be an integral type");
  static_assert(numeric_limits<_FloatT>::radix == 2, "FloatT has incorrect radix");
#ifdef _LIBCUDACXX_HAS_COMPLEX_LONG_DOUBLE
  static_assert((_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value
                 || _IsSame<_FloatT,long double>::value), "unsupported floating point type");
#else
  static_assert((_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value),
                 "unsupported floating point type");
#endif
  return _FloatBigger ? numeric_limits<_IntT>::max() :  (numeric_limits<_IntT>::max() >> _Bits << _Bits);
}

// Convert a floating point number to the specified integral type after
// clamping to the integral types representable range.
//
// The behavior is undefined if `__r` is NaN.
template <class _IntT, class _RealT>
_LIBCUDACXX_INLINE_VISIBILITY
_IntT __clamp_to_integral(_RealT __r) noexcept {
  using _Lim = _CUDA_VSTD::numeric_limits<_IntT>;
  const _IntT _MaxVal = _CUDA_VSTD::__max_representable_int_for_float<_IntT, _RealT>();
  if (__r >= ::nextafter(static_cast<_RealT>(_MaxVal), INFINITY)) {
    return _Lim::max();
  } else if (__r <= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast<_IntT>(__r);
}

_LIBCUDACXX_END_NAMESPACE_STD

#ifndef __cuda_std__
#include <__pragma_pop>
#endif // __cuda_std__

#endif  // _LIBCUDACXX_CMATH
