//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_ALGORITHM
#define _LIBCUDACXX_ALGORITHM

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/__algorithm/adjacent_find.h>
#include <cuda/std/__algorithm/all_of.h>
#include <cuda/std/__algorithm/any_of.h>
#include <cuda/std/__algorithm/binary_search.h>
#include <cuda/std/__algorithm/clamp.h>
#include <cuda/std/__algorithm/comp.h>
#include <cuda/std/__algorithm/comp_ref_type.h>
#include <cuda/std/__algorithm/copy.h>
#include <cuda/std/__algorithm/copy_backward.h>
#include <cuda/std/__algorithm/copy_if.h>
#include <cuda/std/__algorithm/copy_n.h>
#include <cuda/std/__algorithm/count.h>
#include <cuda/std/__algorithm/count_if.h>
#include <cuda/std/__algorithm/equal.h>
#include <cuda/std/__algorithm/equal_range.h>
#include <cuda/std/__algorithm/fill.h>
#include <cuda/std/__algorithm/fill_n.h>
#include <cuda/std/__algorithm/find.h>
#include <cuda/std/__algorithm/find_end.h>
#include <cuda/std/__algorithm/find_first_of.h>
#include <cuda/std/__algorithm/find_if.h>
#include <cuda/std/__algorithm/find_if_not.h>
#include <cuda/std/__algorithm/for_each.h>
#include <cuda/std/__algorithm/for_each_n.h>
#include <cuda/std/__algorithm/generate.h>
#include <cuda/std/__algorithm/generate_n.h>
#include <cuda/std/__algorithm/half_positive.h>
#include <cuda/std/__algorithm/includes.h>
#ifdef _CCCL_HAS_SORTING_ALGORITHMS
#  include <cuda/std/__algorithm/inplace_merge.h>
#endif // _CCCL_HAS_SORTING_ALGORITHMS
#include <cuda/std/__algorithm/is_heap.h>
#include <cuda/std/__algorithm/is_heap_until.h>
#include <cuda/std/__algorithm/is_partitioned.h>
#include <cuda/std/__algorithm/is_permutation.h>
#include <cuda/std/__algorithm/is_sorted.h>
#include <cuda/std/__algorithm/is_sorted_until.h>
#include <cuda/std/__algorithm/iter_swap.h>
#include <cuda/std/__algorithm/iterator_operations.h>
#include <cuda/std/__algorithm/lexicographical_compare.h>
#include <cuda/std/__algorithm/lower_bound.h>
#include <cuda/std/__algorithm/make_heap.h>
#include <cuda/std/__algorithm/make_projected.h>
#include <cuda/std/__algorithm/max.h>
#include <cuda/std/__algorithm/max_element.h>
#include <cuda/std/__algorithm/merge.h>
#include <cuda/std/__algorithm/min.h>
#include <cuda/std/__algorithm/min_element.h>
#include <cuda/std/__algorithm/minmax.h>
#include <cuda/std/__algorithm/minmax_element.h>
#include <cuda/std/__algorithm/mismatch.h>
#include <cuda/std/__algorithm/move.h>
#include <cuda/std/__algorithm/move_backward.h>
#include <cuda/std/__algorithm/next_permutation.h>
#include <cuda/std/__algorithm/none_of.h>
#include <cuda/std/__algorithm/partial_sort.h>
#include <cuda/std/__algorithm/partial_sort_copy.h>
#include <cuda/std/__algorithm/partition.h>
#include <cuda/std/__algorithm/partition_copy.h>
#include <cuda/std/__algorithm/partition_point.h>
#include <cuda/std/__algorithm/pop_heap.h>
#include <cuda/std/__algorithm/prev_permutation.h>
#include <cuda/std/__algorithm/push_heap.h>
#include <cuda/std/__algorithm/ranges_for_each.h>
#include <cuda/std/__algorithm/ranges_for_each_n.h>
#include <cuda/std/__algorithm/ranges_iterator_concept.h>
#include <cuda/std/__algorithm/ranges_min.h>
#include <cuda/std/__algorithm/ranges_min_element.h>
#include <cuda/std/__algorithm/remove.h>
#include <cuda/std/__algorithm/remove_copy.h>
#include <cuda/std/__algorithm/remove_copy_if.h>
#include <cuda/std/__algorithm/remove_if.h>
#include <cuda/std/__algorithm/replace.h>
#include <cuda/std/__algorithm/replace_copy.h>
#include <cuda/std/__algorithm/replace_copy_if.h>
#include <cuda/std/__algorithm/replace_if.h>
#include <cuda/std/__algorithm/reverse.h>
#include <cuda/std/__algorithm/reverse_copy.h>
#include <cuda/std/__algorithm/rotate.h>
#include <cuda/std/__algorithm/rotate_copy.h>
#include <cuda/std/__algorithm/sample.h>
#include <cuda/std/__algorithm/search.h>
#include <cuda/std/__algorithm/search_n.h>
#include <cuda/std/__algorithm/set_difference.h>
#include <cuda/std/__algorithm/set_intersection.h>
#include <cuda/std/__algorithm/set_symmetric_difference.h>
#include <cuda/std/__algorithm/set_union.h>
#include <cuda/std/__algorithm/shift_left.h>
#include <cuda/std/__algorithm/shift_right.h>
#include <cuda/std/__algorithm/shuffle.h>
#include <cuda/std/__algorithm/sift_down.h>
#ifdef _CCCL_HAS_SORTING_ALGORITHMS
#  include <cuda/std/__algorithm/sort.h>
#endif // _CCCL_HAS_SORTING_ALGORITHMS
#include <cuda/std/__algorithm/sort_heap.h>
#include <cuda/std/__algorithm/stable_partition.h>
#ifdef _CCCL_HAS_SORTING_ALGORITHMS
#  include <cuda/std/__algorithm/stable_sort.h>
#endif // _CCCL_HAS_SORTING_ALGORITHMS
#include <cuda/std/__algorithm/swap_ranges.h>
#include <cuda/std/__algorithm/transform.h>
#include <cuda/std/__algorithm/unique.h>
#include <cuda/std/__algorithm/unique_copy.h>
#include <cuda/std/__algorithm/upper_bound.h>
#include <cuda/std/__iterator/distance.h>
#include <cuda/std/__iterator/iterator_traits.h>
#include <cuda/std/__iterator/move_iterator.h>
#include <cuda/std/__iterator/next.h>
#include <cuda/std/__iterator/prev.h>
#include <cuda/std/__iterator/reverse_iterator.h>
#include <cuda/std/__iterator/wrap_iter.h>
#include <cuda/std/__memory/destruct_n.h>
#include <cuda/std/__memory/temporary_buffer.h>
#include <cuda/std/__random/linear_congruential_engine.h>
#include <cuda/std/__random/uniform_int_distribution.h>
#include <cuda/std/__type_traits/common_type.h>
#include <cuda/std/__type_traits/enable_if.h>
#include <cuda/std/__type_traits/is_integral.h>
#include <cuda/std/__type_traits/is_same.h>
#include <cuda/std/__type_traits/is_trivially_copy_assignable.h>
#include <cuda/std/__type_traits/make_unsigned.h>
#include <cuda/std/__type_traits/remove_const.h>
#include <cuda/std/bit>
#include <cuda/std/climits>
#include <cuda/std/cstddef>
#include <cuda/std/functional>
#include <cuda/std/initializer_list>
#include <cuda/std/type_traits>
#include <cuda/std/version>

#include <cuda/std/__cccl/prologue.h>

_CCCL_BEGIN_NAMESPACE_CUDA_STD

#ifndef __cuda_std__

// nth_element

template <class _Compare, class _RandomAccessIterator>
_CCCL_HOST_DEVICE void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
  // _Compare is known to be a reference type
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  const difference_type __limit = 7;
  while (true)
  {
  __restart:
    if (__nth == __last)
    {
      return;
    }
    difference_type __len = __last - __first;
    switch (__len)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (__comp(*--__last, *__first))
        {
          swap(*__first, *__last);
        }
        return;
      case 3: {
        _RandomAccessIterator __m = __first;
        ::cuda::std::__sort3<_Compare>(__first, ++__m, --__last, __comp);
        return;
      }
    }
    if (__len <= __limit)
    {
      __selection_sort<_Compare>(__first, __last, __comp);
      return;
    }
    // __len > __limit >= 3
    _RandomAccessIterator __m   = __first + __len / 2;
    _RandomAccessIterator __lm1 = __last;
    unsigned __n_swaps          = ::cuda::std::__sort3<_Compare>(__first, __m, --__lm1, __comp);
    // *__m is median
    // partition [__first, __m) < *__m and *__m <= [__m, __last)
    // (this inhibits tossing elements equivalent to __m around unnecessarily)
    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;
    // j points beyond range to be tested, *__lm1 is known to be <= *__m
    // The search going up is known to be guarded but the search coming down isn't.
    // Prime the downward search with a guard.
    if (!__comp(*__i, *__m)) // if *__first == *__m
    {
      // *__first == *__m, *__first doesn't go in first part
      // manually guard downward moving __j against __i
      while (true)
      {
        if (__i == --__j)
        {
          // *__first == *__m, *__m <= all other elements
          // Partition instead into [__first, __i) == *__first and *__first < [__i, __last)
          ++__i; // __first + 1
          __j = __last;
          if (!__comp(*__first, *--__j)) // we need a guard if *__first == *(__last-1)
          {
            while (true)
            {
              if (__i == __j)
              {
                return; // [__first, __last) all equivalent elements
              }
              if (__comp(*__first, *__i))
              {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }
          // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
          if (__i == __j)
          {
            return;
          }
          while (true)
          {
            while (!__comp(*__first, *__i))
            {
              ++__i;
            }
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
            {
              break;
            }
            swap(*__i, *__j);
            ++__n_swaps;
            ++__i;
          }
          // [__first, __i) == *__first and *__first < [__i, __last)
          // The first part is sorted,
          if (__nth < __i)
          {
            return;
          }
          // __nth_element the second part
          // __nth_element<_Compare>(__i, __nth, __last, __comp);
          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m))
        {
          swap(*__i, *__j);
          ++__n_swaps;
          break; // found guard for downward moving __j, now use unguarded partition
        }
      }
    }
    ++__i;
    // j points beyond range to be tested, *__lm1 is known to be <= *__m
    // if not yet partitioned...
    if (__i < __j)
    {
      // known that *(__i - 1) < *__m
      while (true)
      {
        // __m still guards upward moving __i
        while (__comp(*__i, *__m))
        {
          ++__i;
        }
        // It is now known that a guard exists for downward moving __j
        while (!__comp(*--__j, *__m))
          ;
        if (__i >= __j)
        {
          break;
        }
        swap(*__i, *__j);
        ++__n_swaps;
        // It is known that __m != __j
        // If __m just moved, follow it
        if (__m == __i)
        {
          __m = __j;
        }
        ++__i;
      }
    }
    // [__first, __i) < *__m and *__m <= [__i, __last)
    if (__i != __m && __comp(*__m, *__i))
    {
      swap(*__i, *__m);
      ++__n_swaps;
    }
    // [__first, __i) < *__i and *__i <= [__i+1, __last)
    if (__nth == __i)
    {
      return;
    }
    if (__n_swaps == 0)
    {
      // We were given a perfectly partitioned sequence.  Coincidence?
      if (__nth < __i)
      {
        // Check for [__first, __i) already sorted
        __j = __m = __first;
        while (++__j != __i)
        {
          if (__comp(*__j, *__m))
          {
            // not yet sorted, so sort
            goto not_sorted;
          }
          __m = __j;
        }
        // [__first, __i) sorted
        return;
      }
      else
      {
        // Check for [__i, __last) already sorted
        __j = __m = __i;
        while (++__j != __last)
        {
          if (__comp(*__j, *__m))
          {
            // not yet sorted, so sort
            goto not_sorted;
          }
          __m = __j;
        }
        // [__i, __last) sorted
        return;
      }
    }
  not_sorted:
    // __nth_element on range containing __nth
    if (__nth < __i)
    {
      // __nth_element<_Compare>(__first, __nth, __i, __comp);
      __last = __i;
    }
    else
    {
      // __nth_element<_Compare>(__i+1, __nth, __last, __comp);
      __first = ++__i;
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
_CCCL_API inline void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
  using _Comp_ref = __comp_ref_type<_Compare>;
  __nth_element<_Comp_ref>(__first, __nth, __last, __comp);
}

template <class _RandomAccessIterator>
_CCCL_API inline void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
  ::cuda::std::nth_element(__first, __nth, __last, __less{});
}

#endif

_CCCL_END_NAMESPACE_CUDA_STD

#include <cuda/std/__cccl/epilogue.h>

#endif // _LIBCUDACXX_ALGORITHM
