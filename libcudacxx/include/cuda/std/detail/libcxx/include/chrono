// -*- C++ -*-
//===---------------------------- chrono ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_CHRONO
#define _LIBCUDACXX_CHRONO

/*
    chrono synopsis

namespace std
{
namespace chrono
{

template <class ToDuration, class Rep, class Period>
constexpr
ToDuration
duration_cast(const duration<Rep, Period>& fd);

template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};

template <class Rep> inline constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<Rep>::value;                       // C++17

template <class Rep>
struct duration_values
{
public:
    static constexpr Rep zero(); // noexcept in C++20
    static constexpr Rep max();  // noexcept in C++20
    static constexpr Rep min();  // noexcept in C++20
};

// duration

template <class Rep, class Period = ratio<1>>
class duration
{
    static_assert(!__is_cuda_std_duration_v<Rep>, "A duration representation can not be a duration");
    static_assert(__is_cuda_std_ratio_v<Period>, "Second template parameter of duration must be a std::ratio");
    static_assert(Period::num > 0, "duration period must be positive");
public:
    typedef Rep rep;
    typedef typename _Period::type period;

    constexpr duration() = default;
    template <class Rep2>
        constexpr explicit duration(const Rep2& r,
            typename enable_if
            <
               is_convertible<Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)
            >::type* = 0);

    // conversions
    template <class Rep2, class Period2>
        constexpr duration(const duration<Rep2, Period2>& d,
            typename enable_if
            <
                treat_as_floating_point<rep>::value ||
                ratio_divide<Period2, period>::type::den == 1
            >::type* = 0);

    // observer

    constexpr rep count() const;

    // arithmetic

    constexpr common_type<duration>::type  operator+() const;
    constexpr common_type<duration>::type  operator-() const;
    constexpr duration& operator++();    // constexpr in C++17
    constexpr duration  operator++(int); // constexpr in C++17
    constexpr duration& operator--();    // constexpr in C++17
    constexpr duration  operator--(int); // constexpr in C++17

    constexpr duration& operator+=(const duration& d);  // constexpr in C++17
    constexpr duration& operator-=(const duration& d);  // constexpr in C++17

    duration& operator*=(const rep& rhs);       // constexpr in C++17
    duration& operator/=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const duration& rhs);  // constexpr in C++17

    // special values

    static constexpr duration zero(); // noexcept in C++20
    static constexpr duration min();  // noexcept in C++20
    static constexpr duration max();  // noexcept in C++20
};

typedef duration<long long,         nano> nanoseconds;
typedef duration<long long,        micro> microseconds;
typedef duration<long long,        milli> milliseconds;
typedef duration<long long              > seconds;
typedef duration<     long, ratio<  60> > minutes;
typedef duration<     long, ratio<3600> > hours;

template <class Clock, class Duration = typename Clock::duration>
class time_point
{
public:
    typedef Clock                     clock;
    typedef Duration                  duration;
    typedef typename duration::rep    rep;
    typedef typename duration::period period;
private:
    duration d_;  // exposition only

public:
    time_point();  // has value "epoch" // constexpr in C++14
    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14

    // conversions
    template <class Duration2>
       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14

    // observer

    duration time_since_epoch() const; // constexpr in C++14

    // arithmetic

    time_point& operator+=(const duration& d); // constexpr in C++17
    time_point& operator-=(const duration& d); // constexpr in C++17

    // special values

    static constexpr time_point min();  // noexcept in C++20
    static constexpr time_point max();  // noexcept in C++20
};

} // chrono

// common_type traits
template <class Rep1, class Period1, class Rep2, class Period2>
  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {


template<class T> struct is_clock;  // C++20
template<class T> inline constexpr bool is_clock_v = is_clock<T>::value;   // C++20


// duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const Rep1& s, const duration<Rep2, Period>& d);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator/(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<Rep1, Rep2>::type
  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration_cast
template <class ToDuration, class Rep, class Period>
  ToDuration duration_cast(const duration<Rep, Period>& d);

template <class ToDuration, class Rep, class Period>
    constexpr ToDuration floor(const duration<Rep, Period>& d);    // C++17
template <class ToDuration, class Rep, class Period>
    constexpr ToDuration ceil(const duration<Rep, Period>& d);     // C++17
template <class ToDuration, class Rep, class Period>
    constexpr ToDuration round(const duration<Rep, Period>& d);    // C++17

// duration I/O is elsewhere

// time_point arithmetic (all constexpr in C++14)
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Clock, class Duration2>
  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Clock, class Duration1, class Duration2>
  typename common_type<Duration1, Duration2>::type
  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point comparisons (all constexpr in C++14)
template <class Clock, class Duration1, class Duration2>
   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point_cast (constexpr in C++14)

template <class ToDuration, class Clock, class Duration>
  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    floor(const time_point<Clock, Duration>& tp);                  // C++17

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    ceil(const time_point<Clock, Duration>& tp);                   // C++17

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    round(const time_point<Clock, Duration>& tp);                  // C++17

template <class Rep, class Period>
    constexpr duration<Rep, Period> abs(duration<Rep, Period> d);  // C++17

// Clocks

class system_clock
{
public:
    typedef microseconds                     duration;
    typedef duration::rep                    rep;
    typedef duration::period                 period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady =            false; // constexpr in C++14

    static time_point now() noexcept;
    static time_t     to_time_t  (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};

template <class Duration>
  using sys_time  = time_point<system_clock, Duration>; // C++20
using sys_seconds = sys_time<seconds>;                  // C++20
using sys_days    = sys_time<days>;                     // C++20

class utc_clock;                                        // C++20

template <class Duration>
  using utc_time  = time_point<utc_clock, Duration>;    // C++20
using utc_seconds = utc_time<seconds>;                  // C++20

class tai_clock;                                        // C++20

template <class Duration>
  using tai_time  = time_point<tai_clock, Duration>;    // C++20
using tai_seconds = tai_time<seconds>;                  // C++20

class file_clock;                                       // C++20

template<class Duration>
  using file_time = time_point<file_clock, Duration>;   // C++20

class steady_clock
{
public:
    typedef nanoseconds                                   duration;
    typedef duration::rep                                 rep;
    typedef duration::period                              period;
    typedef chrono::time_point<steady_clock, duration>    time_point;
    static const bool is_steady =                         true; // constexpr in C++14

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;

// 25.7.8, local time           // C++20
struct local_t {};
template<class Duration>
  using local_time  = time_point<local_t, Duration>;
using local_seconds = local_time<seconds>;
using local_days    = local_time<days>;

// 25.7.9, time_point conversions template<class DestClock, class SourceClock>    // C++20
struct clock_time_conversion;

template<class DestClock, class SourceClock, class Duration>
  auto clock_cast(const time_point<SourceClock, Duration>& t);

// 25.8.2, class last_spec    // C++20
struct last_spec;

// 25.8.3, class day          // C++20

class day;
constexpr bool operator==(const day& x, const day& y) noexcept;
constexpr bool operator!=(const day& x, const day& y) noexcept;
constexpr bool operator< (const day& x, const day& y) noexcept;
constexpr bool operator> (const day& x, const day& y) noexcept;
constexpr bool operator<=(const day& x, const day& y) noexcept;
constexpr bool operator>=(const day& x, const day& y) noexcept;
constexpr day  operator+(const day&  x, const days& y) noexcept;
constexpr day  operator+(const days& x, const day&  y) noexcept;
constexpr day  operator-(const day&  x, const days& y) noexcept;
constexpr days operator-(const day&  x, const day&  y) noexcept;

// 25.8.4, class month    // C++20
class month;
constexpr bool operator==(const month& x, const month& y) noexcept;
constexpr bool operator!=(const month& x, const month& y) noexcept;
constexpr bool operator< (const month& x, const month& y) noexcept;
constexpr bool operator> (const month& x, const month& y) noexcept;
constexpr bool operator<=(const month& x, const month& y) noexcept;
constexpr bool operator>=(const month& x, const month& y) noexcept;
constexpr month  operator+(const month&  x, const months& y) noexcept;
constexpr month  operator+(const months& x,  const month& y) noexcept;
constexpr month  operator-(const month&  x, const months& y) noexcept;
constexpr months operator-(const month&  x,  const month& y) noexcept;

// 25.8.5, class year    // C++20
class year;
constexpr bool operator==(const year& x, const year& y) noexcept;
constexpr bool operator!=(const year& x, const year& y) noexcept;
constexpr bool operator< (const year& x, const year& y) noexcept;
constexpr bool operator> (const year& x, const year& y) noexcept;
constexpr bool operator<=(const year& x, const year& y) noexcept;
constexpr bool operator>=(const year& x, const year& y) noexcept;
constexpr year  operator+(const year&  x, const years& y) noexcept;
constexpr year  operator+(const years& x, const year&  y) noexcept;
constexpr year  operator-(const year&  x, const years& y) noexcept;
constexpr years operator-(const year&  x, const year&  y) noexcept;

// 25.8.6, class weekday    // C++20
class weekday;

constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
constexpr bool operator!=(const weekday& x, const weekday& y) noexcept;
constexpr weekday operator+(const weekday& x, const days&    y) noexcept;
constexpr weekday operator+(const days&    x, const weekday& y) noexcept;
constexpr weekday operator-(const weekday& x, const days&    y) noexcept;
constexpr days    operator-(const weekday& x, const weekday& y) noexcept;

// 25.8.7, class weekday_indexed    // C++20

class weekday_indexed;
constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
constexpr bool operator!=(const weekday_indexed& x, const weekday_indexed& y) noexcept;

// 25.8.8, class weekday_last    // C++20
class weekday_last;

constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
constexpr bool operator!=(const weekday_last& x, const weekday_last& y) noexcept;

// 25.8.9, class month_day    // C++20
class month_day;

constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
constexpr bool operator!=(const month_day& x, const month_day& y) noexcept;
constexpr bool operator< (const month_day& x, const month_day& y) noexcept;
constexpr bool operator> (const month_day& x, const month_day& y) noexcept;
constexpr bool operator<=(const month_day& x, const month_day& y) noexcept;
constexpr bool operator>=(const month_day& x, const month_day& y) noexcept;


// 25.8.10, class month_day_last    // C++20
class month_day_last;

constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator!=(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator< (const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator> (const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator<=(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator>=(const month_day_last& x, const month_day_last& y) noexcept;

// 25.8.11, class month_weekday    // C++20
class month_weekday;

constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
constexpr bool operator!=(const month_weekday& x, const month_weekday& y) noexcept;

// 25.8.12, class month_weekday_last    // C++20
class month_weekday_last;

constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
constexpr bool operator!=(const month_weekday_last& x, const month_weekday_last& y) noexcept;


// 25.8.13, class year_month    // C++20
class year_month;

constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
constexpr bool operator!=(const year_month& x, const year_month& y) noexcept;
constexpr bool operator< (const year_month& x, const year_month& y) noexcept;
constexpr bool operator> (const year_month& x, const year_month& y) noexcept;
constexpr bool operator<=(const year_month& x, const year_month& y) noexcept;
constexpr bool operator>=(const year_month& x, const year_month& y) noexcept;

constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
constexpr months operator-(const year_month& x, const year_month& y) noexcept;
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;

// 25.8.14, class year_month_day class    // C++20
year_month_day;

constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator!=(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator< (const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator> (const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator<=(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator>=(const year_month_day& x, const year_month_day& y) noexcept;

constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;


// 25.8.15, class year_month_day_last    // C++20
class year_month_day_last;

constexpr bool operator==(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator!=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator< (const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator> (const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator<=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator>=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;

constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
  operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
constexpr year_month_day_last
  operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const years& dy) noexcept;

// 25.8.16, class year_month_weekday    // C++20
class year_month_weekday;

constexpr bool operator==(const year_month_weekday& x,
                          const year_month_weekday& y) noexcept;
constexpr bool operator!=(const year_month_weekday& x,
                          const year_month_weekday& y) noexcept;

constexpr year_month_weekday
  operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
  operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
  operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
constexpr year_month_weekday
  operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
  operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
  operator-(const year_month_weekday& ymwd, const years& dy) noexcept;

// 25.8.17, class year_month_weekday_last    // C++20
class year_month_weekday_last;

constexpr bool operator==(const year_month_weekday_last& x,
                          const year_month_weekday_last& y) noexcept;
constexpr bool operator!=(const year_month_weekday_last& x,
                          const year_month_weekday_last& y) noexcept;
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
  operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
constexpr year_month_weekday_last
  operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;

// 25.8.18, civil calendar conventional syntax operators    // C++20
constexpr year_month
  operator/(const year& y, const month& m) noexcept;
constexpr year_month
  operator/(const year& y, int m) noexcept;
constexpr month_day
  operator/(const month& m, const day& d) noexcept;
constexpr month_day
  operator/(const month& m, int d) noexcept;
constexpr month_day
  operator/(int m, const day& d) noexcept;
constexpr month_day
  operator/(const day& d, const month& m) noexcept;
constexpr month_day
  operator/(const day& d, int m) noexcept;
constexpr month_day_last
  operator/(const month& m, last_spec) noexcept;
constexpr month_day_last
  operator/(int m, last_spec) noexcept;
constexpr month_day_last
  operator/(last_spec, const month& m) noexcept;
constexpr month_day_last
  operator/(last_spec, int m) noexcept;
constexpr month_weekday
  operator/(const month& m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
  operator/(int m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
  operator/(const weekday_indexed& wdi, const month& m) noexcept;
constexpr month_weekday
  operator/(const weekday_indexed& wdi, int m) noexcept;
constexpr month_weekday_last
  operator/(const month& m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
  operator/(int m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
  operator/(const weekday_last& wdl, const month& m) noexcept;
constexpr month_weekday_last
  operator/(const weekday_last& wdl, int m) noexcept;
constexpr year_month_day
  operator/(const year_month& ym, const day& d) noexcept;
constexpr year_month_day
  operator/(const year_month& ym, int d) noexcept;
constexpr year_month_day
  operator/(const year& y, const month_day& md) noexcept;
constexpr year_month_day
  operator/(int y, const month_day& md) noexcept;
constexpr year_month_day
  operator/(const month_day& md, const year& y) noexcept;
constexpr year_month_day
  operator/(const month_day& md, int y) noexcept;
constexpr year_month_day_last
  operator/(const year_month& ym, last_spec) noexcept;
constexpr year_month_day_last
  operator/(const year& y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
  operator/(int y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
  operator/(const month_day_last& mdl, const year& y) noexcept;
constexpr year_month_day_last
  operator/(const month_day_last& mdl, int y) noexcept;
constexpr year_month_weekday
  operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
constexpr year_month_weekday
  operator/(const year& y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
  operator/(int y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
  operator/(const month_weekday& mwd, const year& y) noexcept;
constexpr year_month_weekday
  operator/(const month_weekday& mwd, int y) noexcept;
constexpr year_month_weekday_last
  operator/(const year_month& ym, const weekday_last& wdl) noexcept;
constexpr year_month_weekday_last
  operator/(const year& y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
  operator/(int y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, const year& y) noexcept;
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, int y) noexcept;

// 26.9, class template hh_mm_ss
template <class Duration>
class hh_mm_ss
{
    bool            is_neg; // exposition only
    chrono::hours   h;      // exposition only
    chrono::minutes m;      // exposition only
    chrono::seconds s;      // exposition only
    precision       ss;     // exposition only

public:
    static unsigned constexpr fractional_width = see below;
    using precision                            = see below;

    constexpr hh_mm_ss() noexcept : hh_mm_ss{Duration::zero()} {}
    constexpr explicit hh_mm_ss(Duration d) noexcept;

    constexpr bool is_negative() const noexcept;
    constexpr chrono::hours hours() const noexcept;
    constexpr chrono::minutes minutes() const noexcept;
    constexpr chrono::seconds seconds() const noexcept;
    constexpr precision subseconds() const noexcept;

    constexpr explicit operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;
};

template <class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, hh_mm_ss<Duration> const& hms);

// 26.10, 12/24 hour functions
constexpr bool is_am(hours const& h) noexcept;
constexpr bool is_pm(hours const& h) noexcept;
constexpr hours make12(const hours& h) noexcept;
constexpr hours make24(const hours& h, bool is_pm) noexcept;


// 25.10.2, time zone database     // C++20
struct tzdb;
class tzdb_list;

// 25.10.2.3, time zone database access    // C++20
const tzdb& get_tzdb();
tzdb_list& get_tzdb_list();
const time_zone* locate_zone(string_view tz_name);
const time_zone* current_zone();

// 25.10.2.4, remote time zone database support    // C++20
const tzdb& reload_tzdb();
string remote_version();

// 25.10.3, exception classes    // C++20
class nonexistent_local_time;
class ambiguous_local_time;

// 25.10.4, information classes    // C++20
struct sys_info;
struct local_info;

// 25.10.5, class time_zone    // C++20
enum class choose {earliest, latest};
class time_zone;
bool operator==(const time_zone& x, const time_zone& y) noexcept;
bool operator!=(const time_zone& x, const time_zone& y) noexcept;
bool operator<(const time_zone& x, const time_zone& y) noexcept;
bool operator>(const time_zone& x, const time_zone& y) noexcept;
bool operator<=(const time_zone& x, const time_zone& y) noexcept;
bool operator>=(const time_zone& x, const time_zone& y) noexcept;

// 25.10.6, class template zoned_traits    // C++20
template<class T> struct zoned_traits;

// 25.10.7, class template zoned_time    // C++20
template<class Duration, class TimeZonePtr = const time_zone*> class zoned_time;
using zoned_seconds = zoned_time<seconds>;

template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);
template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator!=(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);

// 25.10.8, leap second support    // C++20
class leap;

bool operator==(const leap& x, const leap& y);
bool operator!=(const leap& x, const leap& y);
bool operator< (const leap& x, const leap& y);
bool operator> (const leap& x, const leap& y);
bool operator<=(const leap& x, const leap& y);
bool operator>=(const leap& x, const leap& y);
template<class Duration>
  bool operator==(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator==(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator!=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator!=(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator< (const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator< (const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator> (const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator> (const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator<=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator<=(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator>=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator>=(const sys_time<Duration>& x, const leap& y);

// 25.10.9, class link    // C++20
class link;
bool operator==(const link& x, const link& y);
bool operator!=(const link& x, const link& y);
bool operator< (const link& x, const link& y);
bool operator> (const link& x, const link& y);
bool operator<=(const link& x, const link& y);
bool operator>=(const link& x, const link& y);

// 25.11, formatting    // C++20
template<class charT, class Streamable>
  basic_string<charT>
    format(const charT* fmt, const Streamable& s);

template<class charT, class Streamable>
  basic_string<charT>
    format(const locale& loc, const charT* fmt, const Streamable& s);

template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);

template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const locale& loc, const basic_string<charT, traits, Alloc>& fmt,
           const Streamable& s);

// 25.12, parsing    // C++20
template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          minutes& offset);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev, minutes& offset);

// calendrical constants
inline constexpr last_spec                              last{};       // C++20
inline constexpr chrono::weekday                        Sunday{0};    // C++20
inline constexpr chrono::weekday                        Monday{1};    // C++20
inline constexpr chrono::weekday                        Tuesday{2};   // C++20
inline constexpr chrono::weekday                        Wednesday{3}; // C++20
inline constexpr chrono::weekday                        Thursday{4};  // C++20
inline constexpr chrono::weekday                        Friday{5};    // C++20
inline constexpr chrono::weekday                        Saturday{6};  // C++20

inline constexpr chrono::month                          January{1};   // C++20
inline constexpr chrono::month                          February{2};  // C++20
inline constexpr chrono::month                          March{3};     // C++20
inline constexpr chrono::month                          April{4};     // C++20
inline constexpr chrono::month                          May{5};       // C++20
inline constexpr chrono::month                          June{6};      // C++20
inline constexpr chrono::month                          July{7};      // C++20
inline constexpr chrono::month                          August{8};    // C++20
inline constexpr chrono::month                          September{9}; // C++20
inline constexpr chrono::month                          October{10};  // C++20
inline constexpr chrono::month                          November{11}; // C++20
inline constexpr chrono::month                          December{12}; // C++20
}  // chrono

inline namespace literals {
  inline namespace chrono_literals {
constexpr chrono::hours                                 operator ""h(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<3600,1>> operator ""h(long double); // C++14
constexpr chrono::minutes                               operator ""min(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<60,1>>   operator ""min(long double); // C++14
constexpr chrono::seconds                               operator ""s(unsigned long long); // C++14
constexpr chrono::duration<unspecified >                operator ""s(long double); // C++14
constexpr chrono::milliseconds                          operator ""ms(unsigned long long); // C++14
constexpr chrono::duration<unspecified , milli>         operator ""ms(long double); // C++14
constexpr chrono::microseconds                          operator ""us(unsigned long long); // C++14
constexpr chrono::duration<unspecified , micro>         operator ""us(long double); // C++14
constexpr chrono::nanoseconds                           operator ""ns(unsigned long long); // C++14
constexpr chrono::duration<unspecified , nano>          operator ""ns(long double); // C++14
constexpr chrono::day                                   operator ""d(unsigned long long d) noexcept; // C++20
constexpr chrono::year                                  operator ""y(unsigned long long y) noexcept; // C++20
}  // chrono_literals
}  // literals

}  // std
*/

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#ifdef __cuda_std__
#  if !_CCCL_COMPILER(NVRTC)
#    include <chrono>
#  endif // _CCCL_COMPILER(NVRTC)
#endif // __cuda_std__

#if _CCCL_CUDA_COMPILATION()
#  include <cuda/__ptx/instructions/get_sreg.h>
#endif // _CCCL_CUDA_COMPILATION()
#include <cuda/std/__chrono/calendar.h>
#include <cuda/std/__chrono/day.h>
#include <cuda/std/__chrono/duration.h>
#include <cuda/std/__chrono/file_clock.h>
#include <cuda/std/__chrono/high_resolution_clock.h>
#include <cuda/std/__chrono/month.h>
#include <cuda/std/__chrono/steady_clock.h>
#include <cuda/std/__chrono/system_clock.h>
#include <cuda/std/__chrono/time_point.h>
#include <cuda/std/__chrono/year.h>
#include <cuda/std/__type_traits/common_type.h>
#include <cuda/std/__type_traits/enable_if.h>
#include <cuda/std/__type_traits/integral_constant.h>
#include <cuda/std/__type_traits/is_convertible.h>
#include <cuda/std/__type_traits/is_floating_point.h>
#include <cuda/std/ctime>
#include <cuda/std/limits>
#include <cuda/std/ratio>

// standard-mandated includes
// TODO: Fix CPOs in split H/D compilation or inform users of what may happen
// #include <cuda/std/concepts>
#include <cuda/std/version>

#include <cuda/std/__cccl/prologue.h>

// Silence NVCC warnings `long double` arising from chrono floating pointer
// user-defined literals which are defined in terms of `long double`.

// FIXME: There is currently no way to disable this diagnostic in a fine-grained
// fashion; if you include this header, the diagnostic will be suppressed
// throughout the translation unit. The alternative is loosing (conforming)
// chrono user-defined literals; this seems like the lesser of two evils, so...
_CCCL_BEGIN_NV_DIAG_SUPPRESS(cuda_demote_unsupported_floating_point)

#define _LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T double

_CCCL_BEGIN_NAMESPACE_CUDA_STD

namespace chrono
{
class weekday_indexed;
class weekday_last;

class weekday
{
private:
  unsigned char __wd;

public:
  _CCCL_HIDE_FROM_ABI weekday() = default;
  _CCCL_API explicit constexpr weekday(unsigned __val) noexcept
      : __wd(static_cast<unsigned char>(__val == 7 ? 0 : __val))
  {}
  _CCCL_API constexpr weekday(const sys_days& __sysd) noexcept
      : __wd(__weekday_from_days(__sysd.time_since_epoch().count()))
  {}
  _CCCL_API explicit constexpr weekday(const local_days& __locd) noexcept
      : __wd(__weekday_from_days(__locd.time_since_epoch().count()))
  {}

  _CCCL_API constexpr weekday& operator++() noexcept
  {
    __wd = (__wd == 6 ? 0 : __wd + 1);
    return *this;
  }
  _CCCL_API constexpr weekday operator++(int) noexcept
  {
    weekday __tmp = *this;
    ++(*this);
    return __tmp;
  }
  _CCCL_API constexpr weekday& operator--() noexcept
  {
    __wd = (__wd == 0 ? 6 : __wd - 1);
    return *this;
  }
  _CCCL_API constexpr weekday operator--(int) noexcept
  {
    weekday __tmp = *this;
    --(*this);
    return __tmp;
  }
  _CCCL_API constexpr weekday& operator+=(const days& __dd) noexcept;
  _CCCL_API constexpr weekday& operator-=(const days& __dd) noexcept;
  _CCCL_API constexpr unsigned c_encoding() const noexcept
  {
    return __wd;
  }
  _CCCL_API constexpr unsigned iso_encoding() const noexcept
  {
    return __wd == 0u ? 7 : __wd;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __wd <= 6;
  }
  _CCCL_API constexpr weekday_indexed operator[](unsigned __index) const noexcept;
  _CCCL_API constexpr weekday_last operator[](last_spec) const noexcept;

  _CCCL_API static constexpr unsigned char __weekday_from_days(int __days) noexcept;
};

// https://howardhinnant.github.io/date_algorithms.html#weekday_from_days
_CCCL_API constexpr unsigned char weekday::__weekday_from_days(int __days) noexcept
{
  return static_cast<unsigned char>(static_cast<unsigned>(__days >= -4 ? (__days + 4) % 7 : (__days + 5) % 7 + 6));
}

_CCCL_API constexpr bool operator==(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return __lhs.c_encoding() == __rhs.c_encoding();
}

_CCCL_API constexpr bool operator!=(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr bool operator<(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return __lhs.c_encoding() < __rhs.c_encoding();
}

_CCCL_API constexpr bool operator>(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const weekday& __lhs, const weekday& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

_CCCL_API constexpr weekday operator+(const weekday& __lhs, const days& __rhs) noexcept
{
  auto const __mu = static_cast<long long>(__lhs.c_encoding()) + __rhs.count();
  auto const __yr = (__mu >= 0 ? __mu : __mu - 6) / 7;
  return weekday{static_cast<unsigned>(__mu - __yr * 7)};
}

_CCCL_API constexpr weekday operator+(const days& __lhs, const weekday& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr weekday operator-(const weekday& __lhs, const days& __rhs) noexcept
{
  return __lhs + -__rhs;
}

_CCCL_API constexpr days operator-(const weekday& __lhs, const weekday& __rhs) noexcept
{
  // casts are required to work around nvcc bug 3145483
  const int __wdu = static_cast<int>(__lhs.c_encoding()) - static_cast<int>(__rhs.c_encoding());
  const int __wk  = (__wdu >= 0 ? __wdu : __wdu - 6) / 7;
  return days{__wdu - __wk * 7};
}

_CCCL_API constexpr weekday& weekday::operator+=(const days& __dd) noexcept
{
  *this = *this + __dd;
  return *this;
}

_CCCL_API constexpr weekday& weekday::operator-=(const days& __dd) noexcept
{
  *this = *this - __dd;
  return *this;
}

class weekday_indexed
{
private:
  ::cuda::std::chrono::weekday __wd;
  unsigned char __idx;

public:
  _CCCL_HIDE_FROM_ABI weekday_indexed() = default;
  _CCCL_API constexpr weekday_indexed(const ::cuda::std::chrono::weekday& __wdval, unsigned __idxval) noexcept
      : __wd{__wdval}
      , __idx(static_cast<unsigned char>(__idxval))
  {}
  _CCCL_API constexpr ::cuda::std::chrono::weekday weekday() const noexcept
  {
    return __wd;
  }
  _CCCL_API constexpr unsigned index() const noexcept
  {
    return __idx;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __wd.ok() && __idx >= 1 && __idx <= 5;
  }
};

_CCCL_API constexpr bool operator==(const weekday_indexed& __lhs, const weekday_indexed& __rhs) noexcept
{
  return __lhs.weekday() == __rhs.weekday() && __lhs.index() == __rhs.index();
}

_CCCL_API constexpr bool operator!=(const weekday_indexed& __lhs, const weekday_indexed& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

class weekday_last
{
private:
  ::cuda::std::chrono::weekday __wd;

public:
  _CCCL_API explicit constexpr weekday_last(const ::cuda::std::chrono::weekday& __val) noexcept
      : __wd{__val}
  {}
  _CCCL_API constexpr ::cuda::std::chrono::weekday weekday() const noexcept
  {
    return __wd;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __wd.ok();
  }
};

_CCCL_API constexpr bool operator==(const weekday_last& __lhs, const weekday_last& __rhs) noexcept
{
  return __lhs.weekday() == __rhs.weekday();
}

_CCCL_API constexpr bool operator!=(const weekday_last& __lhs, const weekday_last& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr weekday_indexed weekday::operator[](unsigned __index) const noexcept
{
  return weekday_indexed{*this, __index};
}

_CCCL_API constexpr weekday_last weekday::operator[](last_spec) const noexcept
{
  return weekday_last{*this};
}

inline constexpr weekday Sunday{0};
inline constexpr weekday Monday{1};
inline constexpr weekday Tuesday{2};
inline constexpr weekday Wednesday{3};
inline constexpr weekday Thursday{4};
inline constexpr weekday Friday{5};
inline constexpr weekday Saturday{6};

class month_day
{
private:
  chrono::month __m;
  chrono::day __d;

public:
  _CCCL_HIDE_FROM_ABI month_day() = default;
  _CCCL_API constexpr month_day(const chrono::month& __mval, const chrono::day& __dval) noexcept
      : __m{__mval}
      , __d{__dval}
  {}
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::day day() const noexcept
  {
    return __d;
  }
  _CCCL_API constexpr bool ok() const noexcept;
};

_CCCL_API constexpr bool month_day::ok() const noexcept
{
  if (!__m.ok())
  {
    return false;
  }
  const unsigned __dval = static_cast<unsigned>(__d);
  if (__dval < 1 || __dval > 31)
  {
    return false;
  }
  if (__dval <= 29)
  {
    return true;
  }
  //  Now we've got either 30 or 31
  const unsigned __mval = static_cast<unsigned>(__m);
  if (__mval == 2)
  {
    return false;
  }
  if (__mval == 4 || __mval == 6 || __mval == 9 || __mval == 11)
  {
    return __dval == 30;
  }
  return true;
}

_CCCL_API constexpr bool operator==(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return __lhs.month() == __rhs.month() && __lhs.day() == __rhs.day();
}

_CCCL_API constexpr bool operator!=(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr month_day operator/(const month& __lhs, const day& __rhs) noexcept
{
  return month_day{__lhs, __rhs};
}

_CCCL_API constexpr month_day operator/(const day& __lhs, const month& __rhs) noexcept
{
  return __rhs / __lhs;
}

_CCCL_API constexpr month_day operator/(const month& __lhs, int __rhs) noexcept
{
  return __lhs / day(__rhs);
}

_CCCL_API constexpr month_day operator/(int __lhs, const day& __rhs) noexcept
{
  return month(__lhs) / __rhs;
}

_CCCL_API constexpr month_day operator/(const day& __lhs, int __rhs) noexcept
{
  return month(__rhs) / __lhs;
}

_CCCL_API constexpr bool operator<(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return __lhs.month() != __rhs.month() ? __lhs.month() < __rhs.month() : __lhs.day() < __rhs.day();
}

_CCCL_API constexpr bool operator>(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const month_day& __lhs, const month_day& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

class month_day_last
{
private:
  chrono::month __m;

public:
  _CCCL_API explicit constexpr month_day_last(const chrono::month& __val) noexcept
      : __m{__val}
  {}
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __m.ok();
  }
};

_CCCL_API constexpr bool operator==(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return __lhs.month() == __rhs.month();
}

_CCCL_API constexpr bool operator!=(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr bool operator<(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return __lhs.month() < __rhs.month();
}

_CCCL_API constexpr bool operator>(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const month_day_last& __lhs, const month_day_last& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

_CCCL_API constexpr month_day_last operator/(const month& __lhs, last_spec) noexcept
{
  return month_day_last{__lhs};
}

_CCCL_API constexpr month_day_last operator/(last_spec, const month& __rhs) noexcept
{
  return month_day_last{__rhs};
}

_CCCL_API constexpr month_day_last operator/(int __lhs, last_spec) noexcept
{
  return month_day_last{month(__lhs)};
}

_CCCL_API constexpr month_day_last operator/(last_spec, int __rhs) noexcept
{
  return month_day_last{month(__rhs)};
}

class month_weekday
{
private:
  chrono::month __m;
  chrono::weekday_indexed __wdi;

public:
  _CCCL_HIDE_FROM_ABI month_weekday() = default;
  _CCCL_API constexpr month_weekday(const chrono::month& __mval, const chrono::weekday_indexed& __wdival) noexcept
      : __m{__mval}
      , __wdi{__wdival}
  {}
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::weekday_indexed weekday_indexed() const noexcept
  {
    return __wdi;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __m.ok() && __wdi.ok();
  }
};

_CCCL_API constexpr bool operator==(const month_weekday& __lhs, const month_weekday& __rhs) noexcept
{
  return __lhs.month() == __rhs.month() && __lhs.weekday_indexed() == __rhs.weekday_indexed();
}

_CCCL_API constexpr bool operator!=(const month_weekday& __lhs, const month_weekday& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr month_weekday operator/(const month& __lhs, const weekday_indexed& __rhs) noexcept
{
  return month_weekday{__lhs, __rhs};
}

_CCCL_API constexpr month_weekday operator/(int __lhs, const weekday_indexed& __rhs) noexcept
{
  return month_weekday{month(__lhs), __rhs};
}

_CCCL_API constexpr month_weekday operator/(const weekday_indexed& __lhs, const month& __rhs) noexcept
{
  return month_weekday{__rhs, __lhs};
}

_CCCL_API constexpr month_weekday operator/(const weekday_indexed& __lhs, int __rhs) noexcept
{
  return month_weekday{month(__rhs), __lhs};
}

class month_weekday_last
{
  chrono::month __m;
  chrono::weekday_last __wdl;

public:
  _CCCL_API constexpr month_weekday_last(const chrono::month& __mval, const chrono::weekday_last& __wdlval) noexcept
      : __m{__mval}
      , __wdl{__wdlval}
  {}
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::weekday_last weekday_last() const noexcept
  {
    return __wdl;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __m.ok() && __wdl.ok();
  }
};

_CCCL_API constexpr bool operator==(const month_weekday_last& __lhs, const month_weekday_last& __rhs) noexcept
{
  return __lhs.month() == __rhs.month() && __lhs.weekday_last() == __rhs.weekday_last();
}

_CCCL_API constexpr bool operator!=(const month_weekday_last& __lhs, const month_weekday_last& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr month_weekday_last operator/(const month& __lhs, const weekday_last& __rhs) noexcept
{
  return month_weekday_last{__lhs, __rhs};
}

_CCCL_API constexpr month_weekday_last operator/(int __lhs, const weekday_last& __rhs) noexcept
{
  return month_weekday_last{month(__lhs), __rhs};
}

_CCCL_API constexpr month_weekday_last operator/(const weekday_last& __lhs, const month& __rhs) noexcept
{
  return month_weekday_last{__rhs, __lhs};
}

_CCCL_API constexpr month_weekday_last operator/(const weekday_last& __lhs, int __rhs) noexcept
{
  return month_weekday_last{month(__rhs), __lhs};
}

class year_month
{
  chrono::year __y;
  chrono::month __m;

public:
  _CCCL_HIDE_FROM_ABI year_month() = default;
  _CCCL_API constexpr year_month(const chrono::year& __yval, const chrono::month& __mval) noexcept
      : __y{__yval}
      , __m{__mval}
  {}
  _CCCL_API constexpr chrono::year year() const noexcept
  {
    return __y;
  }
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr year_month& operator+=(const months& __dm) noexcept
  {
    this->__m += __dm;
    return *this;
  }
  _CCCL_API constexpr year_month& operator-=(const months& __dm) noexcept
  {
    this->__m -= __dm;
    return *this;
  }
  _CCCL_API constexpr year_month& operator+=(const years& __dy) noexcept
  {
    this->__y += __dy;
    return *this;
  }
  _CCCL_API constexpr year_month& operator-=(const years& __dy) noexcept
  {
    this->__y -= __dy;
    return *this;
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __y.ok() && __m.ok();
  }
};

_CCCL_API constexpr year_month operator/(const year& __y, const month& __m) noexcept
{
  return year_month{__y, __m};
}

_CCCL_API constexpr year_month operator/(const year& __y, int __m) noexcept
{
  return year_month{__y, month(__m)};
}

_CCCL_API constexpr bool operator==(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return __lhs.year() == __rhs.year() && __lhs.month() == __rhs.month();
}

_CCCL_API constexpr bool operator!=(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr bool operator<(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return __lhs.year() != __rhs.year() ? __lhs.year() < __rhs.year() : __lhs.month() < __rhs.month();
}

_CCCL_API constexpr bool operator>(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

_CCCL_API constexpr year_month operator+(const year_month& __lhs, const months& __rhs) noexcept
{
  int __dmi      = static_cast<int>(static_cast<unsigned>(__lhs.month())) - 1 + __rhs.count();
  const int __dy = (__dmi >= 0 ? __dmi : __dmi - 11) / 12;
  __dmi          = __dmi - __dy * 12 + 1;
  return (__lhs.year() + years(__dy)) / month(static_cast<unsigned>(__dmi));
}

_CCCL_API constexpr year_month operator+(const months& __lhs, const year_month& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month operator+(const year_month& __lhs, const years& __rhs) noexcept
{
  return (__lhs.year() + __rhs) / __lhs.month();
}

_CCCL_API constexpr year_month operator+(const years& __lhs, const year_month& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr months operator-(const year_month& __lhs, const year_month& __rhs) noexcept
{
  return (__lhs.year() - __rhs.year())
       + months(static_cast<unsigned>(__lhs.month()) - static_cast<unsigned>(__rhs.month()));
}

_CCCL_API constexpr year_month operator-(const year_month& __lhs, const months& __rhs) noexcept
{
  return __lhs + -__rhs;
}

_CCCL_API constexpr year_month operator-(const year_month& __lhs, const years& __rhs) noexcept
{
  return __lhs + -__rhs;
}

class year_month_day_last;

class year_month_day
{
private:
  chrono::year __y;
  chrono::month __m;
  chrono::day __d;

public:
  _CCCL_HIDE_FROM_ABI year_month_day() = default;
  _CCCL_API constexpr year_month_day(
    const chrono::year& __yval, const chrono::month& __mval, const chrono::day& __dval) noexcept
      : __y{__yval}
      , __m{__mval}
      , __d{__dval}
  {}
  _CCCL_API constexpr year_month_day(const year_month_day_last& __ymdl) noexcept;
  _CCCL_API constexpr year_month_day(const sys_days& __sysd) noexcept
      : year_month_day(__from_days(__sysd.time_since_epoch()))
  {}
  _CCCL_API explicit constexpr year_month_day(const local_days& __locd) noexcept
      : year_month_day(__from_days(__locd.time_since_epoch()))
  {}

  _CCCL_API constexpr year_month_day& operator+=(const months& __dm) noexcept;
  _CCCL_API constexpr year_month_day& operator-=(const months& __dm) noexcept;
  _CCCL_API constexpr year_month_day& operator+=(const years& __dy) noexcept;
  _CCCL_API constexpr year_month_day& operator-=(const years& __dy) noexcept;

  _CCCL_API constexpr chrono::year year() const noexcept
  {
    return __y;
  }
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::day day() const noexcept
  {
    return __d;
  }
  _CCCL_API constexpr operator sys_days() const noexcept
  {
    return sys_days{__to_days()};
  }
  _CCCL_API explicit constexpr operator local_days() const noexcept
  {
    return local_days{__to_days()};
  }

  _CCCL_API constexpr bool ok() const noexcept;

  _CCCL_API static constexpr year_month_day __from_days(days __d) noexcept;
  _CCCL_API constexpr days __to_days() const noexcept;
};

// https://howardhinnant.github.io/date_algorithms.html#civil_from_days
_CCCL_API constexpr year_month_day year_month_day::__from_days(days __d) noexcept
{
  static_assert(std::numeric_limits<unsigned>::digits >= 18, "");
  static_assert(std::numeric_limits<int>::digits >= 20, "");
  const int __z        = __d.count() + 719468;
  const int __era      = (__z >= 0 ? __z : __z - 146096) / 146097;
  const unsigned __doe = static_cast<unsigned>(__z - __era * 146097); // [0, 146096]
  const unsigned __yoe = (__doe - __doe / 1460 + __doe / 36524 - __doe / 146096) / 365; // [0, 399]
  const int __yr       = static_cast<int>(__yoe) + __era * 400;
  const unsigned __doy = __doe - (365 * __yoe + __yoe / 4 - __yoe / 100); // [0, 365]
  const unsigned __mp  = (5 * __doy + 2) / 153; // [0, 11]
  const unsigned __dy  = __doy - (153 * __mp + 2) / 5 + 1; // [1, 31]
  const unsigned __mth = __mp + static_cast<unsigned>(__mp < 10 ? 3 : -9); // [1, 12]
  return year_month_day{chrono::year{__yr + (__mth <= 2)}, chrono::month{__mth}, chrono::day{__dy}};
}

// https://howardhinnant.github.io/date_algorithms.html#days_from_civil
_CCCL_API constexpr days year_month_day::__to_days() const noexcept
{
  static_assert(std::numeric_limits<unsigned>::digits >= 18, "");
  static_assert(std::numeric_limits<int>::digits >= 20, "");

  // nvcc doesn't allow ODR using constexpr globals. Therefore,
  // make a temporary initialized from the global
  auto constexpr __Feb = February;
  const int __yr       = static_cast<int>(__y) - (__m <= __Feb);
  const unsigned __mth = static_cast<unsigned>(__m);
  const unsigned __dy  = static_cast<unsigned>(__d);

  const int __era      = (__yr >= 0 ? __yr : __yr - 399) / 400;
  const unsigned __yoe = static_cast<unsigned>(__yr - __era * 400); // [0, 399]
  const unsigned __doy =
    static_cast<unsigned>((153 * (__mth + static_cast<unsigned>(__mth > 2 ? -3 : 9)) + 2) / 5 + __dy - 1); // [0, 365]
  const unsigned __doe = __yoe * 365 + __yoe / 4 - __yoe / 100 + __doy; // [0, 146096]
  return days{__era * 146097 + static_cast<int>(__doe) - 719468};
}

_CCCL_API constexpr bool operator==(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  return __lhs.year() == __rhs.year() && __lhs.month() == __rhs.month() && __lhs.day() == __rhs.day();
}

_CCCL_API constexpr bool operator!=(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr bool operator<(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  if (__lhs.year() < __rhs.year())
  {
    return true;
  }
  if (__lhs.year() > __rhs.year())
  {
    return false;
  }
  if (__lhs.month() < __rhs.month())
  {
    return true;
  }
  if (__lhs.month() > __rhs.month())
  {
    return false;
  }
  return __lhs.day() < __rhs.day();
}

_CCCL_API constexpr bool operator>(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const year_month_day& __lhs, const year_month_day& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

_CCCL_API constexpr year_month_day operator/(const year_month& __lhs, const day& __rhs) noexcept
{
  return year_month_day{__lhs.year(), __lhs.month(), __rhs};
}

_CCCL_API constexpr year_month_day operator/(const year_month& __lhs, int __rhs) noexcept
{
  return __lhs / day(__rhs);
}

_CCCL_API constexpr year_month_day operator/(const year& __lhs, const month_day& __rhs) noexcept
{
  return __lhs / __rhs.month() / __rhs.day();
}

_CCCL_API constexpr year_month_day operator/(int __lhs, const month_day& __rhs) noexcept
{
  return year(__lhs) / __rhs;
}

_CCCL_API constexpr year_month_day operator/(const month_day& __lhs, const year& __rhs) noexcept
{
  return __rhs / __lhs;
}

_CCCL_API constexpr year_month_day operator/(const month_day& __lhs, int __rhs) noexcept
{
  return year(__rhs) / __lhs;
}

_CCCL_API constexpr year_month_day operator+(const year_month_day& __lhs, const months& __rhs) noexcept
{
  return (__lhs.year() / __lhs.month() + __rhs) / __lhs.day();
}

_CCCL_API constexpr year_month_day operator+(const months& __lhs, const year_month_day& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_day operator-(const year_month_day& __lhs, const months& __rhs) noexcept
{
  return __lhs + -__rhs;
}

_CCCL_API constexpr year_month_day operator+(const year_month_day& __lhs, const years& __rhs) noexcept
{
  return (__lhs.year() + __rhs) / __lhs.month() / __lhs.day();
}

_CCCL_API constexpr year_month_day operator+(const years& __lhs, const year_month_day& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_day operator-(const year_month_day& __lhs, const years& __rhs) noexcept
{
  return __lhs + -__rhs;
}

_CCCL_API constexpr year_month_day& year_month_day::operator+=(const months& __dm) noexcept
{
  *this = *this + __dm;
  return *this;
}
_CCCL_API constexpr year_month_day& year_month_day::operator-=(const months& __dm) noexcept
{
  *this = *this - __dm;
  return *this;
}
_CCCL_API constexpr year_month_day& year_month_day::operator+=(const years& __dy) noexcept
{
  *this = *this + __dy;
  return *this;
}
_CCCL_API constexpr year_month_day& year_month_day::operator-=(const years& __dy) noexcept
{
  *this = *this - __dy;
  return *this;
}

class year_month_day_last
{
private:
  chrono::year __y;
  chrono::month_day_last __mdl;

public:
  _CCCL_API constexpr year_month_day_last(const year& __yval, const month_day_last& __mdlval) noexcept
      : __y{__yval}
      , __mdl{__mdlval}
  {}

  _CCCL_API constexpr year_month_day_last& operator+=(const months& __m) noexcept;
  _CCCL_API constexpr year_month_day_last& operator-=(const months& __m) noexcept;
  _CCCL_API constexpr year_month_day_last& operator+=(const years& __y) noexcept;
  _CCCL_API constexpr year_month_day_last& operator-=(const years& __y) noexcept;

  _CCCL_API constexpr chrono::year year() const noexcept
  {
    return __y;
  }
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __mdl.month();
  }
  _CCCL_API constexpr chrono::month_day_last month_day_last() const noexcept
  {
    return __mdl;
  }
  _CCCL_API constexpr chrono::day day() const noexcept;
  _CCCL_API constexpr operator sys_days() const noexcept
  {
    return sys_days{year() / month() / day()};
  }
  _CCCL_API explicit constexpr operator local_days() const noexcept
  {
    return local_days{year() / month() / day()};
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __y.ok() && __mdl.ok();
  }
};

_CCCL_API constexpr chrono::day year_month_day_last::day() const noexcept
{
  constexpr chrono::day __d[] = {
    chrono::day(31),
    chrono::day(28),
    chrono::day(31),
    chrono::day(30),
    chrono::day(31),
    chrono::day(30),
    chrono::day(31),
    chrono::day(31),
    chrono::day(30),
    chrono::day(31),
    chrono::day(30),
    chrono::day(31)};

  // nvcc doesn't allow ODR using constexpr globals. Therefore,
  // make a temporary initialized from the global
  auto constexpr __Feb = February;
  return month() != __Feb || !__y.is_leap() ? __d[static_cast<unsigned>(month()) - 1] : chrono::day{29};
}

_CCCL_API constexpr bool operator==(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  return __lhs.year() == __rhs.year() && __lhs.month_day_last() == __rhs.month_day_last();
}

_CCCL_API constexpr bool operator!=(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr bool operator<(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  if (__lhs.year() < __rhs.year())
  {
    return true;
  }
  if (__lhs.year() > __rhs.year())
  {
    return false;
  }
  return __lhs.month_day_last() < __rhs.month_day_last();
}

_CCCL_API constexpr bool operator>(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  return __rhs < __lhs;
}

_CCCL_API constexpr bool operator<=(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  return !(__rhs < __lhs);
}

_CCCL_API constexpr bool operator>=(const year_month_day_last& __lhs, const year_month_day_last& __rhs) noexcept
{
  return !(__lhs < __rhs);
}

_CCCL_API constexpr year_month_day_last operator/(const year_month& __lhs, last_spec) noexcept
{
  return year_month_day_last{__lhs.year(), month_day_last{__lhs.month()}};
}

_CCCL_API constexpr year_month_day_last operator/(const year& __lhs, const month_day_last& __rhs) noexcept
{
  return year_month_day_last{__lhs, __rhs};
}

_CCCL_API constexpr year_month_day_last operator/(int __lhs, const month_day_last& __rhs) noexcept
{
  return year_month_day_last{year{__lhs}, __rhs};
}

_CCCL_API constexpr year_month_day_last operator/(const month_day_last& __lhs, const year& __rhs) noexcept
{
  return __rhs / __lhs;
}

_CCCL_API constexpr year_month_day_last operator/(const month_day_last& __lhs, int __rhs) noexcept
{
  return year{__rhs} / __lhs;
}

_CCCL_API constexpr year_month_day_last operator+(const year_month_day_last& __lhs, const months& __rhs) noexcept
{
  return (__lhs.year() / __lhs.month() + __rhs) / last;
}

_CCCL_API constexpr year_month_day_last operator+(const months& __lhs, const year_month_day_last& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_day_last operator-(const year_month_day_last& __lhs, const months& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_day_last operator+(const year_month_day_last& __lhs, const years& __rhs) noexcept
{
  return year_month_day_last{__lhs.year() + __rhs, __lhs.month_day_last()};
}

_CCCL_API constexpr year_month_day_last operator+(const years& __lhs, const year_month_day_last& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_day_last operator-(const year_month_day_last& __lhs, const years& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_day_last& year_month_day_last::operator+=(const months& __dm) noexcept
{
  *this = *this + __dm;
  return *this;
}
_CCCL_API constexpr year_month_day_last& year_month_day_last::operator-=(const months& __dm) noexcept
{
  *this = *this - __dm;
  return *this;
}
_CCCL_API constexpr year_month_day_last& year_month_day_last::operator+=(const years& __dy) noexcept
{
  *this = *this + __dy;
  return *this;
}
_CCCL_API constexpr year_month_day_last& year_month_day_last::operator-=(const years& __dy) noexcept
{
  *this = *this - __dy;
  return *this;
}

_CCCL_API constexpr year_month_day::year_month_day(const year_month_day_last& __ymdl) noexcept
    : __y{__ymdl.year()}
    , __m{__ymdl.month()}
    , __d{__ymdl.day()}
{}

_CCCL_API constexpr bool year_month_day::ok() const noexcept
{
  if (!__y.ok() || !__m.ok())
  {
    return false;
  }
  return chrono::day{1} <= __d && __d <= (__y / __m / last).day();
}

class year_month_weekday
{
  chrono::year __y;
  chrono::month __m;
  chrono::weekday_indexed __wdi;

public:
  _CCCL_HIDE_FROM_ABI year_month_weekday() = default;
  _CCCL_API constexpr year_month_weekday(
    const chrono::year& __yval, const chrono::month& __mval, const chrono::weekday_indexed& __wdival) noexcept
      : __y{__yval}
      , __m{__mval}
      , __wdi{__wdival}
  {}
  _CCCL_API constexpr year_month_weekday(const sys_days& __sysd) noexcept
      : year_month_weekday(__from_days(__sysd.time_since_epoch()))
  {}
  _CCCL_API explicit constexpr year_month_weekday(const local_days& __locd) noexcept
      : year_month_weekday(__from_days(__locd.time_since_epoch()))
  {}
  _CCCL_API constexpr year_month_weekday& operator+=(const months& m) noexcept;
  _CCCL_API constexpr year_month_weekday& operator-=(const months& m) noexcept;
  _CCCL_API constexpr year_month_weekday& operator+=(const years& y) noexcept;
  _CCCL_API constexpr year_month_weekday& operator-=(const years& y) noexcept;

  _CCCL_API constexpr chrono::year year() const noexcept
  {
    return __y;
  }
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::weekday weekday() const noexcept
  {
    return __wdi.weekday();
  }
  _CCCL_API constexpr unsigned index() const noexcept
  {
    return __wdi.index();
  }
  _CCCL_API constexpr chrono::weekday_indexed weekday_indexed() const noexcept
  {
    return __wdi;
  }

  _CCCL_API constexpr operator sys_days() const noexcept
  {
    return sys_days{__to_days()};
  }
  _CCCL_API explicit constexpr operator local_days() const noexcept
  {
    return local_days{__to_days()};
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    if (!__y.ok() || !__m.ok() || !__wdi.ok())
    {
      return false;
    }
    //  TODO: make sure it's a valid date
    return true;
  }

  _CCCL_API static constexpr year_month_weekday __from_days(days __d) noexcept;
  _CCCL_API constexpr days __to_days() const noexcept;
};

_CCCL_API constexpr year_month_weekday year_month_weekday::__from_days(days __d) noexcept
{
  const sys_days __sysd{__d};
  const chrono::weekday __wd = chrono::weekday(__sysd);
  const year_month_day __ymd = year_month_day(__sysd);
  return year_month_weekday{__ymd.year(), __ymd.month(), __wd[(static_cast<unsigned>(__ymd.day()) - 1) / 7 + 1]};
}

_CCCL_API constexpr days year_month_weekday::__to_days() const noexcept
{
  const sys_days __sysd = sys_days(__y / __m / 1);
  return (__sysd + (__wdi.weekday() - chrono::weekday(__sysd) + days{(__wdi.index() - 1) * 7})).time_since_epoch();
}

_CCCL_API constexpr bool operator==(const year_month_weekday& __lhs, const year_month_weekday& __rhs) noexcept
{
  return __lhs.year() == __rhs.year() && __lhs.month() == __rhs.month()
      && __lhs.weekday_indexed() == __rhs.weekday_indexed();
}

_CCCL_API constexpr bool operator!=(const year_month_weekday& __lhs, const year_month_weekday& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr year_month_weekday operator/(const year_month& __lhs, const weekday_indexed& __rhs) noexcept
{
  return year_month_weekday{__lhs.year(), __lhs.month(), __rhs};
}

_CCCL_API constexpr year_month_weekday operator/(const year& __lhs, const month_weekday& __rhs) noexcept
{
  return year_month_weekday{__lhs, __rhs.month(), __rhs.weekday_indexed()};
}

_CCCL_API constexpr year_month_weekday operator/(int __lhs, const month_weekday& __rhs) noexcept
{
  return year(__lhs) / __rhs;
}

_CCCL_API constexpr year_month_weekday operator/(const month_weekday& __lhs, const year& __rhs) noexcept
{
  return __rhs / __lhs;
}

_CCCL_API constexpr year_month_weekday operator/(const month_weekday& __lhs, int __rhs) noexcept
{
  return year(__rhs) / __lhs;
}

_CCCL_API constexpr year_month_weekday operator+(const year_month_weekday& __lhs, const months& __rhs) noexcept
{
  return (__lhs.year() / __lhs.month() + __rhs) / __lhs.weekday_indexed();
}

_CCCL_API constexpr year_month_weekday operator+(const months& __lhs, const year_month_weekday& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_weekday operator-(const year_month_weekday& __lhs, const months& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_weekday operator+(const year_month_weekday& __lhs, const years& __rhs) noexcept
{
  return year_month_weekday{__lhs.year() + __rhs, __lhs.month(), __lhs.weekday_indexed()};
}

_CCCL_API constexpr year_month_weekday operator+(const years& __lhs, const year_month_weekday& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_weekday operator-(const year_month_weekday& __lhs, const years& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_weekday& year_month_weekday::operator+=(const months& __dm) noexcept
{
  *this = *this + __dm;
  return *this;
}
_CCCL_API constexpr year_month_weekday& year_month_weekday::operator-=(const months& __dm) noexcept
{
  *this = *this - __dm;
  return *this;
}
_CCCL_API constexpr year_month_weekday& year_month_weekday::operator+=(const years& __dy) noexcept
{
  *this = *this + __dy;
  return *this;
}
_CCCL_API constexpr year_month_weekday& year_month_weekday::operator-=(const years& __dy) noexcept
{
  *this = *this - __dy;
  return *this;
}

class year_month_weekday_last
{
private:
  chrono::year __y;
  chrono::month __m;
  chrono::weekday_last __wdl;

public:
  _CCCL_API constexpr year_month_weekday_last(
    const chrono::year& __yval, const chrono::month& __mval, const chrono::weekday_last& __wdlval) noexcept
      : __y{__yval}
      , __m{__mval}
      , __wdl{__wdlval}
  {}
  _CCCL_API constexpr year_month_weekday_last& operator+=(const months& __dm) noexcept;
  _CCCL_API constexpr year_month_weekday_last& operator-=(const months& __dm) noexcept;
  _CCCL_API constexpr year_month_weekday_last& operator+=(const years& __dy) noexcept;
  _CCCL_API constexpr year_month_weekday_last& operator-=(const years& __dy) noexcept;

  _CCCL_API constexpr chrono::year year() const noexcept
  {
    return __y;
  }
  _CCCL_API constexpr chrono::month month() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::weekday weekday() const noexcept
  {
    return __wdl.weekday();
  }
  _CCCL_API constexpr chrono::weekday_last weekday_last() const noexcept
  {
    return __wdl;
  }
  _CCCL_API constexpr operator sys_days() const noexcept
  {
    return sys_days{__to_days()};
  }
  _CCCL_API explicit constexpr operator local_days() const noexcept
  {
    return local_days{__to_days()};
  }
  _CCCL_API constexpr bool ok() const noexcept
  {
    return __y.ok() && __m.ok() && __wdl.ok();
  }

  _CCCL_API constexpr days __to_days() const noexcept;
};

_CCCL_API constexpr days year_month_weekday_last::__to_days() const noexcept
{
  const sys_days __last = sys_days{__y / __m / last};
  return (__last - (chrono::weekday{__last} - __wdl.weekday())).time_since_epoch();
}

_CCCL_API constexpr bool operator==(const year_month_weekday_last& __lhs, const year_month_weekday_last& __rhs) noexcept
{
  return __lhs.year() == __rhs.year() && __lhs.month() == __rhs.month() && __lhs.weekday_last() == __rhs.weekday_last();
}

_CCCL_API constexpr bool operator!=(const year_month_weekday_last& __lhs, const year_month_weekday_last& __rhs) noexcept
{
  return !(__lhs == __rhs);
}

_CCCL_API constexpr year_month_weekday_last operator/(const year_month& __lhs, const weekday_last& __rhs) noexcept
{
  return year_month_weekday_last{__lhs.year(), __lhs.month(), __rhs};
}

_CCCL_API constexpr year_month_weekday_last operator/(const year& __lhs, const month_weekday_last& __rhs) noexcept
{
  return year_month_weekday_last{__lhs, __rhs.month(), __rhs.weekday_last()};
}

_CCCL_API constexpr year_month_weekday_last operator/(int __lhs, const month_weekday_last& __rhs) noexcept
{
  return year(__lhs) / __rhs;
}

_CCCL_API constexpr year_month_weekday_last operator/(const month_weekday_last& __lhs, const year& __rhs) noexcept
{
  return __rhs / __lhs;
}

_CCCL_API constexpr year_month_weekday_last operator/(const month_weekday_last& __lhs, int __rhs) noexcept
{
  return year(__rhs) / __lhs;
}

_CCCL_API constexpr year_month_weekday_last operator+(const year_month_weekday_last& __lhs, const months& __rhs) noexcept
{
  return (__lhs.year() / __lhs.month() + __rhs) / __lhs.weekday_last();
}

_CCCL_API constexpr year_month_weekday_last operator+(const months& __lhs, const year_month_weekday_last& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_weekday_last operator-(const year_month_weekday_last& __lhs, const months& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_weekday_last operator+(const year_month_weekday_last& __lhs, const years& __rhs) noexcept
{
  return year_month_weekday_last{__lhs.year() + __rhs, __lhs.month(), __lhs.weekday_last()};
}

_CCCL_API constexpr year_month_weekday_last operator+(const years& __lhs, const year_month_weekday_last& __rhs) noexcept
{
  return __rhs + __lhs;
}

_CCCL_API constexpr year_month_weekday_last operator-(const year_month_weekday_last& __lhs, const years& __rhs) noexcept
{
  return __lhs + (-__rhs);
}

_CCCL_API constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const months& __dm) noexcept
{
  *this = *this + __dm;
  return *this;
}
_CCCL_API constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const months& __dm) noexcept
{
  *this = *this - __dm;
  return *this;
}
_CCCL_API constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const years& __dy) noexcept
{
  *this = *this + __dy;
  return *this;
}
_CCCL_API constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const years& __dy) noexcept
{
  *this = *this - __dy;
  return *this;
}

[[nodiscard]] _CCCL_API constexpr unsigned __hh_mm_ss_width(uint64_t __n, uint64_t __d = 10, unsigned __w = 0)
{
  if (__n >= 2 && __d != 0 && __w < 19)
  {
    return 1 + __hh_mm_ss_width(__n, __d % __n * 10, __w + 1);
  }
  return 0;
}

template <class _Duration>
class hh_mm_ss
{
private:
  static_assert(__is_cuda_std_duration_v<_Duration>, "template parameter of hh_mm_ss must be a std::chrono::duration");
  using __CommonType = typename common_type<_Duration, chrono::seconds>::type;

  _CCCL_API static constexpr uint64_t __pow10(unsigned __exp)
  {
    uint64_t __ret = 1;
    for (unsigned __i = 0; __i < __exp; ++__i)
    {
      __ret *= 10U;
    }
    return __ret;
  }

public:
  static unsigned constexpr fractional_width =
    __hh_mm_ss_width(__CommonType::period::den) < 19 ? __hh_mm_ss_width(__CommonType::period::den) : 6u;
  using precision = duration<typename __CommonType::rep, ratio<1, __pow10(fractional_width)>>;

  _CCCL_API constexpr hh_mm_ss() noexcept
      : hh_mm_ss{_Duration::zero()}
  {}

  _CCCL_API constexpr explicit hh_mm_ss(_Duration __d) noexcept
      : __is_neg(__d < _Duration(0))
      , __h(duration_cast<chrono::hours>(abs(__d)))
      , __m(duration_cast<chrono::minutes>(abs(__d) - hours()))
      , __s(duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))
      , __f(duration_cast<precision>(abs(__d) - hours() - minutes() - seconds()))
  {}

  _CCCL_API constexpr bool is_negative() const noexcept
  {
    return __is_neg;
  }
  _CCCL_API constexpr chrono::hours hours() const noexcept
  {
    return __h;
  }
  _CCCL_API constexpr chrono::minutes minutes() const noexcept
  {
    return __m;
  }
  _CCCL_API constexpr chrono::seconds seconds() const noexcept
  {
    return __s;
  }
  _CCCL_API constexpr precision subseconds() const noexcept
  {
    return __f;
  }

  _CCCL_API constexpr precision to_duration() const noexcept
  {
    auto __dur = __h + __m + __s + __f;
    return __is_neg ? -__dur : __dur;
  }

  _CCCL_API constexpr explicit operator precision() const noexcept
  {
    return to_duration();
  }

private:
  bool __is_neg;
  chrono::hours __h;
  chrono::minutes __m;
  chrono::seconds __s;
  precision __f;
};

_CCCL_API constexpr bool is_am(const hours& __h) noexcept
{
  return __h >= hours(0) && __h < hours(12);
}
_CCCL_API constexpr bool is_pm(const hours& __h) noexcept
{
  return __h >= hours(12) && __h < hours(24);
}

_CCCL_API constexpr hours make12(const hours& __h) noexcept
{
  if (__h == hours(0))
  {
    return hours(12);
  }
  else if (__h <= hours(12))
  {
    return __h;
  }
  else
  {
    return __h - hours(12);
  }
}

_CCCL_API constexpr hours make24(const hours& __h, bool __is_pm) noexcept
{
  if (__is_pm)
  {
    return __h == hours(12) ? __h : __h + hours(12);
  }
  else
  {
    return __h == hours(12) ? hours(0) : __h;
  }
}
} // namespace chrono

// GCC 5 and 6 warn (and then error) on us using the standard reserved UDL names,
// but have no way of disabling that. Use the system_header pragma on those GCC versions
// for the remainder of this file, even if it has been requested to disable the pragma
// earlier.
#if _CCCL_COMPILER(GCC, >=, 5) && _CCCL_COMPILER(GCC, <, 7)
#  pragma GCC system_header
#endif

_CCCL_DIAG_PUSH
_CCCL_DIAG_SUPPRESS_GCC("-Wliteral-suffix")
_CCCL_DIAG_SUPPRESS_CLANG("-Wuser-defined-literals")
_CCCL_DIAG_SUPPRESS_NVHPC(lit_suffix_no_underscore)
_CCCL_DIAG_SUPPRESS_MSVC(4455) // literal suffix identifiers that do not start with an underscore are reserved
_CCCL_BEGIN_NV_DIAG_SUPPRESS(2506) // a user-provided literal suffix must begin with "_"

// Suffixes for duration literals [time.duration.literals]
inline namespace literals
{
inline namespace chrono_literals
{
_CCCL_API constexpr chrono::hours operator""h(unsigned long long __h)
{
  return chrono::hours(static_cast<chrono::hours::rep>(__h));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, ratio<3600, 1>> operator""h(long double __h)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, ratio<3600, 1>>(__h);
}

_CCCL_API constexpr chrono::minutes operator""min(unsigned long long __m)
{
  return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, ratio<60, 1>> operator""min(long double __m)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, ratio<60, 1>>(__m);
}

_CCCL_API constexpr chrono::seconds operator""s(unsigned long long __s)
{
  return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T> operator""s(long double __s)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T>(__s);
}

_CCCL_API constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
{
  return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, milli> operator""ms(long double __ms)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, milli>(__ms);
}

_CCCL_API constexpr chrono::microseconds operator""us(unsigned long long __us)
{
  return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, micro> operator""us(long double __us)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, micro>(__us);
}

_CCCL_API constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
{
  return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
}

_CCCL_API constexpr chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, nano> operator""ns(long double __ns)
{
  return chrono::duration<_LIBCUDACXX_CHRONO_LITERAL_INTERNAL_T, nano>(__ns);
}

#if _LIBCUDACXX_HAS_CXX20_CHRONO_LITERALS()
_CCCL_API constexpr chrono::day operator""d(unsigned long long __d) noexcept
{
  return chrono::day(static_cast<unsigned>(__d));
}

_CCCL_API constexpr chrono::year operator""y(unsigned long long __y) noexcept
{
  return chrono::year(static_cast<int>(__y));
}
#endif // _LIBCUDACXX_HAS_CXX20_CHRONO_LITERALS()
} // namespace chrono_literals
} // namespace literals

_CCCL_END_NV_DIAG_SUPPRESS()
_CCCL_DIAG_POP

namespace chrono
{ // hoist the literals into namespace std::chrono
using namespace literals::chrono_literals;
}

_CCCL_END_NAMESPACE_CUDA_STD

#ifndef __cuda_std__

_CCCL_BEGIN_NAMESPACE_FILESYSTEM
struct _FilesystemClock
{
#  if _CCCL_HAS_INT128()
  using rep    = __int128_t;
  using period = nano;
#  else // ^^^ _CCCL_HAS_INT128() ^^^ / vvv !_CCCL_HAS_INT128() vvv
  using rep    = long long;
  using period = nano;
#  endif // !_CCCL_HAS_INT128()

  using duration   = chrono::duration<rep, period>;
  using time_point = chrono::time_point<_FilesystemClock>;

  _CCCL_VISIBILITY_DEFAULT static constexpr const bool is_steady = false;

  _CCCL_API inline static time_point now() noexcept;

  _CCCL_API inline static time_t to_time_t(const time_point& __t) noexcept
  {
    using __secs = chrono::duration<rep>;
    return time_t(chrono::duration_cast<__secs>(__t.time_since_epoch()).count());
  }

  _CCCL_API inline static time_point from_time_t(time_t __t) noexcept
  {
    using __secs = chrono::duration<rep>;
    return time_point(__secs(__t));
  }
};
_CCCL_END_NAMESPACE_FILESYSTEM
#endif // __cuda_std__

_CCCL_END_NV_DIAG_SUPPRESS()

#include <cuda/std/__cccl/epilogue.h>

#endif // _LIBCUDACXX_CHRONO
