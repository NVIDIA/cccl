// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCUDACXX_ARRAY
#define _LIBCUDACXX_ARRAY

/*
    array synopsis

namespace std
{
template <class T, size_t N >
struct array
{
    // types:
    typedef T & reference;
    typedef const T & const_reference;
    typedef implementation defined iterator;
    typedef implementation defined const_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef cuda::std::reverse_iterator<iterator> reverse_iterator;
    typedef cuda::std::reverse_iterator<const_iterator> const_reverse_iterator;

    // No explicit construct/copy/destroy for aggregate type
    void fill(const T& u);                                      // constexpr in C++20
    void swap(array& a) noexcept(is_nothrow_swappable_v<T>);    // constexpr in C++20

    // iterators:
    iterator begin() noexcept;                                  // constexpr in C++17
    const_iterator begin() const noexcept;                      // constexpr in C++17
    iterator end() noexcept;                                    // constexpr in C++17
    const_iterator end() const noexcept;                        // constexpr in C++17

    reverse_iterator rbegin() noexcept;                         // constexpr in C++17
    const_reverse_iterator rbegin() const noexcept;             // constexpr in C++17
    reverse_iterator rend() noexcept;                           // constexpr in C++17
    const_reverse_iterator rend() const noexcept;               // constexpr in C++17

    const_iterator cbegin() const noexcept;                     // constexpr in C++17
    const_iterator cend() const noexcept;                       // constexpr in C++17
    const_reverse_iterator crbegin() const noexcept;            // constexpr in C++17
    const_reverse_iterator crend() const noexcept;              // constexpr in C++17

    // capacity:
    constexpr size_type size() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr bool empty() const noexcept;

    // element access:
    reference operator[](size_type n);                          // constexpr in C++17
    const_reference operator[](size_type n) const;              // constexpr in C++14
    reference at(size_type n);                                  // constexpr in C++17
    const_reference at(size_type n) const;                      // constexpr in C++14

    reference front();                                          // constexpr in C++17
    const_reference front() const;                              // constexpr in C++14
    reference back();                                           // constexpr in C++17
    const_reference back() const;                               // constexpr in C++14

    T* data() noexcept;                                         // constexpr in C++17
    const T* data() const noexcept;                             // constexpr in C++17
};

template <class T, class... U>
  array(T, U...) -> array<T, 1 + sizeof...(U)>;                 // C++17

template <class T, size_t N>
  bool operator==(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator!=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator<(const array<T,N>& x, const array<T,N>& y);     // constexpr in C++20
template <class T, size_t N>
  bool operator>(const array<T,N>& x, const array<T,N>& y);     // constexpr in C++20
template <class T, size_t N>
  bool operator<=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator>=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20

template <class T, size_t N >
  void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y))); // constexpr in C++20

template <class T, size_t N>
  constexpr array<remove_cv_t<T>, N> to_array(T (&a)[N]);  // C++20
template <class T, size_t N>
  constexpr array<remove_cv_t<T>, N> to_array(T (&&a)[N]); // C++20

template <class T> struct tuple_size;
template <size_t I, class T> struct tuple_element;
template <class T, size_t N> struct tuple_size<array<T, N>>;
template <size_t I, class T, size_t N> struct tuple_element<I, array<T, N>>;
template <size_t I, class T, size_t N> T& get(array<T, N>&) noexcept;               // constexpr in C++14
template <size_t I, class T, size_t N> const T& get(const array<T, N>&) noexcept;   // constexpr in C++14
template <size_t I, class T, size_t N> T&& get(array<T, N>&&) noexcept;             // constexpr in C++14
template <size_t I, class T, size_t N> const T&& get(const array<T, N>&&) noexcept; // constexpr in C++14

}  // std

*/

#ifndef __cuda_std__
#  include <__config>
#endif // __cuda_std__

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include "__algorithm/equal.h"
#include "__algorithm/fill_n.h"
#include "__algorithm/lexicographical_compare.h"
#include "__algorithm/swap_ranges.h"
#include "__assert" // all public C++ headers provide the assertion handler
#include "__iterator/reverse_iterator.h"
#include "__tuple_dir/sfinae_helpers.h"
#include "__type_traits/conditional.h"
#include "__type_traits/is_array.h"
#include "__type_traits/is_const.h"
#include "__type_traits/is_constructible.h"
#include "__type_traits/is_move_constructible.h"
#include "__type_traits/is_nothrow_constructible.h"
#include "__type_traits/is_nothrow_move_constructible.h"
#include "__type_traits/is_same.h"
#include "__type_traits/is_swappable.h"
#include "__type_traits/remove_cv.h"
#include "__utility/integer_sequence.h"
#include "__utility/move.h"
#include "__utility/unreachable.h"
#include "cstdint"
#include "cstdlib"
#include "limits"
#include "stdexcept"
#include "version"

// standard-mandated includes
#include "version"

// [iterator.range]
#include "__iterator/access.h"
#include "__iterator/data.h"
#include "__iterator/empty.h"
#include "__iterator/reverse_access.h"
#include "__iterator/size.h"

// [array.syn]
#ifndef _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR
#  include <compare>
#endif // _LIBCUDACXX_HAS_NO_SPACESHIP_OPERATOR
#include "initializer_list"

// [tuple.helper]
#include "__tuple_dir/tuple_element.h"
#include "__tuple_dir/tuple_size.h"

_LIBCUDACXX_BEGIN_NAMESPACE_STD

template <class _Tp, size_t _Size>
struct _LIBCUDACXX_TEMPLATE_VIS array
{
  // types:
  typedef array __self;
  typedef _Tp value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _CUDA_VSTD::reverse_iterator<iterator> reverse_iterator;
  typedef _CUDA_VSTD::reverse_iterator<const_iterator> const_reverse_iterator;

  _Tp __elems_[_Size];

  // No explicit construct/copy/destroy for aggregate type
  _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void fill(const value_type& __u)
  {
    _CUDA_VSTD::fill_n(__elems_, _Size, __u);
  }

  _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void
  swap(array& __a) noexcept(__is_nothrow_swappable<_Tp>::value)
  {
    _CUDA_VSTD::swap_ranges(__elems_, __elems_ + _Size, __a.data());
  }

  // iterators:
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 iterator begin() noexcept
  {
    return iterator(__elems_);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  begin() const noexcept
  {
    return const_iterator(__elems_);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 iterator end() noexcept
  {
    return iterator(__elems_ + _Size);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  end() const noexcept
  {
    return const_iterator(__elems_ + _Size);
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 reverse_iterator
  rbegin() noexcept
  {
    return reverse_iterator(end());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  rbegin() const noexcept
  {
    return const_reverse_iterator(end());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 reverse_iterator
  rend() noexcept
  {
    return reverse_iterator(begin());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  rend() const noexcept
  {
    return const_reverse_iterator(begin());
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  cbegin() const noexcept
  {
    return begin();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  cend() const noexcept
  {
    return end();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  crbegin() const noexcept
  {
    return rbegin();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  crend() const noexcept
  {
    return rend();
  }

  // capacity:
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY constexpr size_type size() const noexcept
  {
    return _Size;
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY constexpr size_type max_size() const noexcept
  {
    return _Size;
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY constexpr bool empty() const noexcept
  {
    return _Size == 0;
  }

  // element access:
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference
  operator[](size_type __n) noexcept
  {
    _LIBCUDACXX_ASSERT(__n < _Size, "out-of-bounds access in std::array<T, N>");
    return __elems_[__n];
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  operator[](size_type __n) const noexcept
  {
    _LIBCUDACXX_ASSERT(__n < _Size, "out-of-bounds access in std::array<T, N>");
    return __elems_[__n];
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference at(size_type __n)
  {
    if (__n >= _Size)
    {
      __throw_out_of_range("array::at");
    }
    return __elems_[__n];
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  at(size_type __n) const
  {
    if (__n >= _Size)
    {
      __throw_out_of_range("array::at");
    }
    return __elems_[__n];
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference front() noexcept
  {
    return (*this)[0];
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  front() const noexcept
  {
    return (*this)[0];
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference back() noexcept
  {
    return (*this)[_Size - 1];
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  back() const noexcept
  {
    return (*this)[_Size - 1];
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 value_type* data() noexcept
  {
    return __elems_;
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const value_type*
  data() const noexcept
  {
    return __elems_;
  }
};

template <class _Tp>
struct _LIBCUDACXX_TEMPLATE_VIS array<_Tp, 0>
{
  // types:
  typedef array __self;
  typedef _Tp value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _CUDA_VSTD::reverse_iterator<iterator> reverse_iterator;
  typedef _CUDA_VSTD::reverse_iterator<const_iterator> const_reverse_iterator;

  typedef __conditional_t<is_const<_Tp>::value, const char, char> _CharType;

  struct _ArrayInStructT
  {
    _Tp __data_[1];
  };
  _ALIGNAS_TYPE(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)];

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 value_type* data() noexcept
  {
    return nullptr;
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const value_type*
  data() const noexcept
  {
    return nullptr;
  }

  // No explicit construct/copy/destroy for aggregate type
  _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void fill(const value_type&)
  {
    static_assert(!is_const<_Tp>::value, "cannot fill zero-sized array of type 'const T'");
  }

  _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 void swap(array&) noexcept
  {
    static_assert(!is_const<_Tp>::value, "cannot swap zero-sized array of type 'const T'");
  }

  // iterators:
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 iterator begin() noexcept
  {
    return iterator(nullptr);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  begin() const noexcept
  {
    return const_iterator(nullptr);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 iterator end() noexcept
  {
    return iterator(nullptr);
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  end() const noexcept
  {
    return const_iterator(nullptr);
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 reverse_iterator
  rbegin() noexcept
  {
    return reverse_iterator(end());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  rbegin() const noexcept
  {
    return const_reverse_iterator(end());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 reverse_iterator
  rend() noexcept
  {
    return reverse_iterator(begin());
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  rend() const noexcept
  {
    return const_reverse_iterator(begin());
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  cbegin() const noexcept
  {
    return begin();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_iterator
  cend() const noexcept
  {
    return end();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  crbegin() const noexcept
  {
    return rbegin();
  }
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX14 const_reverse_iterator
  crend() const noexcept
  {
    return rend();
  }

  // capacity:
  _LIBCUDACXX_INLINE_VISIBILITY constexpr size_type size() const noexcept
  {
    return 0;
  }
  _LIBCUDACXX_INLINE_VISIBILITY constexpr size_type max_size() const noexcept
  {
    return 0;
  }
  _LIBCUDACXX_NODISCARD_AFTER_CXX17 _LIBCUDACXX_INLINE_VISIBILITY constexpr bool empty() const noexcept
  {
    return true;
  }

  // element access:
  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference
  operator[](size_type) noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::operator[] on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  operator[](size_type) const noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::operator[] on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference at(size_type)
  {
    __throw_out_of_range("array<T, 0>::at");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  at(size_type) const
  {
    __throw_out_of_range("array<T, 0>::at");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference front() noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::front() on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  front() const noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::front() on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 reference back() noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::back() on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }

  _LIBCUDACXX_HIDE_FROM_ABI _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const_reference
  back() const noexcept
  {
    _LIBCUDACXX_ASSERT(false, "cannot call array<T, 0>::back() on a zero-sized array");
    _LIBCUDACXX_UNREACHABLE();
  }
};

#if _CCCL_STD_VER >= 2017
template <class _Tp, class... _Args, class = __enable_if_t<(is_same_v<_Tp, _Args> && ...)> >
_LIBCUDACXX_HOST_DEVICE array(_Tp, _Args...) -> array<_Tp, 1 + sizeof...(_Args)>;
#endif // _CCCL_STD_VER >= 2017

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return _CUDA_VSTD::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return !(__x == __y);
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return _CUDA_VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return __y < __x;
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return !(__y < __x);
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 bool
operator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
  return !(__x < __y);
}

template <class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11
  __enable_if_t<_Size == 0 || __is_swappable<_Tp>::value, void>
  swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y) noexcept(noexcept(__x.swap(__y)))
{
  __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct _LIBCUDACXX_TEMPLATE_VIS tuple_size<array<_Tp, _Size> > : public integral_constant<size_t, _Size>
{};

template <size_t _Ip, class _Tp, size_t _Size>
struct _LIBCUDACXX_TEMPLATE_VIS tuple_element<_Ip, array<_Tp, _Size> >
{
  static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
  typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 _Tp& get(array<_Tp, _Size>& __a) noexcept
{
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const _Tp&
get(const array<_Tp, _Size>& __a) noexcept
{
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 _Tp&& get(array<_Tp, _Size>&& __a) noexcept
{
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
  return _CUDA_VSTD::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline _LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 const _Tp&&
get(const array<_Tp, _Size>&& __a) noexcept
{
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
  return _CUDA_VSTD::move(__a.__elems_[_Ip]);
}

#if _CCCL_STD_VER >= 2014

template <typename _Tp, size_t _Size, size_t... _Index>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 array<remove_cv_t<_Tp>, _Size>
__to_array_lvalue_impl(_Tp (&__arr)[_Size], index_sequence<_Index...>)
{
  return {{__arr[_Index]...}};
}

template <typename _Tp, size_t _Size, size_t... _Index>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 array<remove_cv_t<_Tp>, _Size>
__to_array_rvalue_impl(_Tp (&&__arr)[_Size], index_sequence<_Index...>)
{
  return {{_CUDA_VSTD::move(__arr[_Index])...}};
}

template <typename _Tp, size_t _Size>
_LIBCUDACXX_INLINE_VISIBILITY _LIBCUDACXX_CONSTEXPR_AFTER_CXX11 array<remove_cv_t<_Tp>, _Size>
to_array(_Tp (&__arr)[_Size]) noexcept(_LIBCUDACXX_TRAIT(is_nothrow_constructible, _Tp, _Tp&))
{
  static_assert(!_LIBCUDACXX_TRAIT(is_array, _Tp),
                "[array.creation]/1: to_array does not accept multidimensional arrays.");
  static_assert(_LIBCUDACXX_TRAIT(is_constructible, _Tp, _Tp&),
                "[array.creation]/1: to_array requires copy constructible elements.");
  return _CUDA_VSTD::__to_array_lvalue_impl(__arr, _CUDA_VSTD::make_index_sequence<_Size>());
}

template <typename _Tp, size_t _Size>
_LIBCUDACXX_INLINE_VISIBILITY constexpr array<remove_cv_t<_Tp>, _Size>
to_array(_Tp (&&__arr)[_Size]) noexcept(_LIBCUDACXX_TRAIT(is_nothrow_move_constructible, _Tp))
{
  static_assert(!_LIBCUDACXX_TRAIT(is_array, _Tp),
                "[array.creation]/4: to_array does not accept multidimensional arrays.");
  static_assert(_LIBCUDACXX_TRAIT(is_move_constructible, _Tp),
                "[array.creation]/4: to_array requires move constructible elements.");
  return _CUDA_VSTD::__to_array_rvalue_impl(_CUDA_VSTD::move(__arr), make_index_sequence<_Size>());
}

#endif // _CCCL_STD_VER >= 2014

_LIBCUDACXX_END_NAMESPACE_STD

#endif // _LIBCUDACXX_ARRAY
