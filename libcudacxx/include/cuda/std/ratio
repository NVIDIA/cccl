//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _CUDA_STD_RATIO
#define _CUDA_STD_RATIO

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/__cstdlib/abs.h>
#include <cuda/std/__limits/numeric_limits.h>
#include <cuda/std/__type_traits/integral_constant.h>
#include <cuda/std/__utility/swap.h>
#include <cuda/std/climits>
#include <cuda/std/cstdint>

#include <cuda/std/__cccl/prologue.h>

_CCCL_BEGIN_NAMESPACE_CUDA_STD

inline constexpr intmax_t __cccl_ratio_nan = numeric_limits<intmax_t>::min();
inline constexpr intmax_t __cccl_ratio_max = numeric_limits<intmax_t>::max();
inline constexpr intmax_t __cccl_ratio_min = -__cccl_ratio_max;

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr intmax_t __cccl_ratio_gcd(intmax_t __x, intmax_t __y) noexcept
{
  return (__y == 0) ? ((__x == 0) ? 1 : __x) : _CUDA_VSTD::__cccl_ratio_gcd(__y, __x % __y);
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr intmax_t __cccl_ratio_lcm(intmax_t __x, intmax_t __y) noexcept
{
  return __x / _CUDA_VSTD::__cccl_ratio_gcd(__x, __y) * __y;
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr int __cccl_ratio_sign(intmax_t __x) noexcept
{
  return (__x == 0) ? 0 : ((__x < 0) ? -1 : 1);
}

struct __ratio_values
{
  intmax_t __num;
  intmax_t __den;
};

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr __ratio_values __cccl_ratio_reduce(__ratio_values __v) noexcept
{
  const auto __na  = _CUDA_VSTD::abs(__v.__num);
  const auto __da  = _CUDA_VSTD::abs(__v.__den);
  const auto __s   = _CUDA_VSTD::__cccl_ratio_sign(__v.__num) * _CUDA_VSTD::__cccl_ratio_sign(__v.__den);
  const auto __gcd = _CUDA_VSTD::__cccl_ratio_gcd(__na, __da);

  return {__s * __na / __gcd, __da / __gcd};
}

template <intmax_t _Num, intmax_t _Den = 1>
class _CCCL_TYPE_VISIBILITY_DEFAULT ratio
{
  static_assert(_Num != __cccl_ratio_nan, "invalid ratio numerator value");
  static_assert(_Den != __cccl_ratio_nan && _Den != 0, "invalid ratio denominator value");

public:
  static constexpr intmax_t num = _CUDA_VSTD::__cccl_ratio_reduce({_Num, _Den}).__num;
  static constexpr intmax_t den = _CUDA_VSTD::__cccl_ratio_reduce({_Num, _Den}).__den;

  using type = ratio<num, den>;
};

template <class _Tp>
inline constexpr bool __is_ratio_v = false;

template <intmax_t _Num, intmax_t _Den>
inline constexpr bool __is_ratio_v<ratio<_Num, _Den>> = true;

using atto  = ratio<1LL, 1000000000000000000LL>;
using femto = ratio<1LL, 1000000000000000LL>;
using pico  = ratio<1LL, 1000000000000LL>;
using nano  = ratio<1LL, 1000000000LL>;
using micro = ratio<1LL, 1000000LL>;
using milli = ratio<1LL, 1000LL>;
using centi = ratio<1LL, 100LL>;
using deci  = ratio<1LL, 10LL>;
using deca  = ratio<10LL, 1LL>;
using hecto = ratio<100LL, 1LL>;
using kilo  = ratio<1000LL, 1LL>;
using mega  = ratio<1000000LL, 1LL>;
using giga  = ratio<1000000000LL, 1LL>;
using tera  = ratio<1000000000000LL, 1LL>;
using peta  = ratio<1000000000000000LL, 1LL>;
using exa   = ratio<1000000000000000000LL, 1LL>;

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr intmax_t __cccl_ratio_mul_ll(intmax_t __lhs, intmax_t __rhs) noexcept
{
  _CCCL_VERIFY(__lhs != __cccl_ratio_nan, "invalid multiplication numerator value");
  _CCCL_VERIFY(__rhs != __cccl_ratio_nan, "invalid multiplication denominator value");
  if (__lhs == 0 || __rhs == 0)
  {
    return 0;
  }
  const auto __lhs_abs = _CUDA_VSTD::abs(__lhs);
  const auto __rhs_abs = _CUDA_VSTD::abs(__rhs);
  _CCCL_VERIFY(__lhs_abs <= __cccl_ratio_max / __rhs_abs, "ratio multiplication overflow");
  return __lhs * __rhs;
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr __ratio_values
__cccl_ratio_mul(__ratio_values __lhs, __ratio_values __rhs) noexcept
{
  const auto __gcd_n1_d2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__num, __lhs.__den);
  const auto __gcd_d1_n2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__den, __rhs.__num);

  __lhs.__num /= __gcd_n1_d2;
  __rhs.__num /= __gcd_d1_n2;
  __lhs.__den /= __gcd_n1_d2;
  __rhs.__den /= __gcd_d1_n2;

  const auto __num = _CUDA_VSTD::__cccl_ratio_mul_ll(__lhs.__num, __rhs.__num);
  const auto __den = _CUDA_VSTD::__cccl_ratio_mul_ll(__lhs.__den, __rhs.__den);

  return _CUDA_VSTD::__cccl_ratio_reduce({__num, __den});
}

template <class _R1, class _R2>
using ratio_multiply = ratio<_CUDA_VSTD::__cccl_ratio_mul({_R1::num, _R1::den}, {_R2::num, _R2::den}).__num,
                             _CUDA_VSTD::__cccl_ratio_mul({_R1::num, _R1::den}, {_R2::num, _R2::den}).__den>;

template <class _R1, class _R2>
using ratio_divide = ratio<_CUDA_VSTD::__cccl_ratio_mul({_R1::num, _R1::den}, {_R2::den, _R2::num}).__num,
                           _CUDA_VSTD::__cccl_ratio_mul({_R1::num, _R1::den}, {_R2::den, _R2::num}).__den>;

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr intmax_t __cccl_ratio_add_ll(intmax_t __lhs, intmax_t __rhs) noexcept
{
  if (__rhs > 0)
  {
    _CCCL_VERIFY(__lhs <= __cccl_ratio_max - __rhs, "ratio addition overflow");
    return __lhs + __rhs;
  }
  else if (__rhs < 0)
  {
    _CCCL_VERIFY(__lhs >= __cccl_ratio_min - __rhs, "ratio addition overflow");
    return __lhs + __rhs;
  }
  else
  {
    return __lhs;
  }
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr __ratio_values
__cccl_ratio_add(__ratio_values __lhs, __ratio_values __rhs) noexcept
{
  const auto __gcd_n1_n2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__num, __rhs.__num);
  const auto __gcd_d1_d2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__den, __rhs.__den);

  const auto __tmp1 = _CUDA_VSTD::__cccl_ratio_mul_ll(__lhs.__num / __gcd_n1_n2, __rhs.__den / __gcd_d1_d2);
  const auto __tmp2 = _CUDA_VSTD::__cccl_ratio_mul_ll(__rhs.__num / __gcd_n1_n2, __lhs.__den / __gcd_d1_d2);

  const __ratio_values __a{__gcd_n1_n2, __lhs.__den / __gcd_d1_d2};
  const __ratio_values __b{_CUDA_VSTD::__cccl_ratio_add_ll(__tmp1, __tmp2), __rhs.__den};

  return _CUDA_VSTD::__cccl_ratio_mul(__a, {__b});
}

template <class _R1, class _R2>
using ratio_add = ratio<_CUDA_VSTD::__cccl_ratio_add({_R1::num, _R1::den}, {_R2::num, _R2::den}).__num,
                        _CUDA_VSTD::__cccl_ratio_add({_R1::num, _R1::den}, {_R2::num, _R2::den}).__den>;

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr intmax_t __cccl_ratio_sub_ll(intmax_t __lhs, intmax_t __rhs) noexcept
{
  if (__rhs > 0)
  {
    _CCCL_VERIFY(__lhs >= __cccl_ratio_min + __rhs, "ratio subtraction overflow");
    return __lhs - __rhs;
  }
  else if (__rhs < 0)
  {
    _CCCL_VERIFY(__lhs <= __cccl_ratio_max + __rhs, "ratio subtraction overflow");
    return __lhs - __rhs;
  }
  else
  {
    return __lhs;
  }
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr __ratio_values
__cccl_ratio_sub(__ratio_values __lhs, __ratio_values __rhs) noexcept
{
  const auto __gcd_n1_n2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__num, __rhs.__num);
  const auto __gcd_d1_d2 = _CUDA_VSTD::__cccl_ratio_gcd(__lhs.__den, __rhs.__den);

  const auto __tmp1 = _CUDA_VSTD::__cccl_ratio_mul_ll(__lhs.__num / __gcd_n1_n2, __rhs.__den / __gcd_d1_d2);
  const auto __tmp2 = _CUDA_VSTD::__cccl_ratio_mul_ll(__rhs.__num / __gcd_n1_n2, __lhs.__den / __gcd_d1_d2);

  const __ratio_values __a{__gcd_n1_n2, __lhs.__den / __gcd_d1_d2};
  const __ratio_values __b{_CUDA_VSTD::__cccl_ratio_sub_ll(__tmp1, __tmp2), __rhs.__den};

  return _CUDA_VSTD::__cccl_ratio_mul(__a, {__b});
}

template <class _R1, class _R2>
using ratio_subtract = ratio<_CUDA_VSTD::__cccl_ratio_sub({_R1::num, _R1::den}, {_R2::num, _R2::den}).__num,
                             _CUDA_VSTD::__cccl_ratio_sub({_R1::num, _R1::den}, {_R2::num, _R2::den}).__den>;

// ratio_less

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr bool
__cccl_ratio_less_helper(__ratio_values __lhs, __ratio_values __rhs) noexcept
{
  while (true)
  {
    const auto __lhs_div_res = __lhs.__num / __lhs.__den;
    const auto __rhs_div_res = __rhs.__num / __rhs.__den;
    if (__lhs_div_res != __rhs_div_res)
    {
      return __lhs_div_res < __rhs_div_res;
    }
    __lhs = {__lhs.__den, __lhs.__num % __lhs.__den};
    __rhs = {__rhs.__den, __rhs.__num % __rhs.__den};
    if (__lhs.__den == 0 || __rhs.__den == 0)
    {
      return __lhs.__den == 0 && __rhs.__den != 0;
    }
    _CUDA_VSTD::swap(__lhs, __rhs);
  }
  _CCCL_UNREACHABLE();
}

[[nodiscard]] _LIBCUDACXX_HIDE_FROM_ABI constexpr bool
__cccl_ratio_less(__ratio_values __lhs, __ratio_values __rhs) noexcept
{
  const auto __lhs_sign = _CUDA_VSTD::__cccl_ratio_sign(__lhs.__num);
  const auto __rhs_sign = _CUDA_VSTD::__cccl_ratio_sign(__rhs.__num);

  if (__lhs_sign == 1 && __rhs_sign == 1)
  {
    return _CUDA_VSTD::__cccl_ratio_less_helper(__lhs, __rhs);
  }
  if (__lhs_sign == -1 && __rhs_sign == -1)
  {
    return _CUDA_VSTD::__cccl_ratio_less_helper({-__rhs.__num, __rhs.__den}, {-__lhs.__num, __lhs.__den});
  }
  return __lhs_sign < __rhs_sign;
}

template <class _R1, class _R2>
struct __ratio_gcd
{
  using type =
    ratio<_CUDA_VSTD::__cccl_ratio_gcd(_R1::num, _R2::num), _CUDA_VSTD::__cccl_ratio_lcm(_R1::den, _R2::den)>;
};

template <class _R1, class _R2>
inline constexpr bool ratio_equal_v = _R1::num == _R2::num && _R1::den == _R2::den;

template <class _R1, class _R2>
inline constexpr bool ratio_not_equal_v = !ratio_equal_v<_R1, _R2>;

template <class _R1, class _R2>
inline constexpr bool ratio_less_v = _CUDA_VSTD::__cccl_ratio_less({_R1::num, _R1::den}, {_R2::num, _R2::den});

template <class _R1, class _R2>
inline constexpr bool ratio_less_equal_v = !ratio_less_v<_R2, _R1>;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_v = ratio_less_v<_R2, _R1>;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_equal_v = !ratio_less_v<_R1, _R2>;

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_equal : bool_constant<ratio_equal_v<_R1, _R2>>
{};

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_not_equal : bool_constant<ratio_not_equal_v<_R1, _R2>>
{};

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_less : bool_constant<ratio_less_v<_R1, _R2>>
{};

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_less_equal : bool_constant<ratio_less_equal_v<_R1, _R2>>
{};

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_greater : bool_constant<ratio_greater_v<_R1, _R2>>
{};

template <class _R1, class _R2>
struct _CCCL_TYPE_VISIBILITY_DEFAULT ratio_greater_equal : bool_constant<ratio_greater_equal_v<_R1, _R2>>
{};

_CCCL_END_NAMESPACE_CUDA_STD

#include <cuda/std/__cccl/epilogue.h>

#endif // _CUDA_STD_RATIO
