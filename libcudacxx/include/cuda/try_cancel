/*
 * SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *
 * NVIDIA SOFTWARE LICENSE
 *
 * This license is a legal agreement between you and NVIDIA Corporation ("NVIDIA") and governs your use of the
 * NVIDIA/CUDA C++ Library software and materials provided hereunder (“SOFTWARE”).
 *
 * This license can be accepted only by an adult of legal age of majority in the country in which the SOFTWARE is used.
 * If you are under the legal age of majority, you must ask your parent or legal guardian to consent to this license. By
 * taking delivery of the SOFTWARE, you affirm that you have reached the legal age of majority, you accept the terms of
 * this license, and you take legal and financial responsibility for the actions of your permitted users.
 *
 * You agree to use the SOFTWARE only for purposes that are permitted by (a) this license, and (b) any applicable law,
 * regulation or generally accepted practices or guidelines in the relevant jurisdictions.
 *
 * 1. LICENSE. Subject to the terms of this license, NVIDIA grants you a non-exclusive limited license to: (a) install
 * and use the SOFTWARE, and (b) distribute the SOFTWARE subject to the distribution requirements described in this
 * license. NVIDIA reserves all rights, title and interest in and to the SOFTWARE not expressly granted to you under
 * this license.
 *
 * 2. DISTRIBUTION REQUIREMENTS. These are the distribution requirements for you to exercise the distribution grant:
 * a.      The terms under which you distribute the SOFTWARE must be consistent with the terms of this license,
 * including (without limitation) terms relating to the license grant and license restrictions and protection of
 * NVIDIA’s intellectual property rights. b.      You agree to notify NVIDIA in writing of any known or suspected
 * distribution or use of the SOFTWARE not in compliance with the requirements of this license, and to enforce the terms
 * of your agreements with respect to distributed SOFTWARE.
 *
 * 3. LIMITATIONS. Your license to use the SOFTWARE is restricted as follows:
 * a.      The SOFTWARE is licensed for you to develop applications only for use in systems with NVIDIA GPUs.
 * b.      You may not reverse engineer, decompile or disassemble, or remove copyright or other proprietary notices from
 * any portion of the SOFTWARE or copies of the SOFTWARE. c.      You may not modify or create derivative works of any
 * portion of the SOFTWARE. d.      You may not bypass, disable, or circumvent any technical measure, encryption,
 * security, digital rights management or authentication mechanism in the SOFTWARE. e.      You may not use the SOFTWARE
 * in any manner that would cause it to become subject to an open source software license. As examples, licenses that
 * require as a condition of use, modification, and/or distribution that the SOFTWARE be (i) disclosed or distributed in
 * source code form; (ii) licensed for the purpose of making derivative works; or (iii) redistributable at no charge. f.
 * Unless you have an agreement with NVIDIA for this purpose, you may not use the SOFTWARE with any system or
 * application where the use or failure of the system or application can reasonably be expected to threaten or result in
 * personal injury, death, or catastrophic loss. Examples include use in avionics, navigation, military, medical, life
 * support or other life critical applications. NVIDIA does not design, test or manufacture the SOFTWARE for these
 * critical uses and NVIDIA shall not be liable to you or any third party, in whole or in part, for any claims or
 * damages arising from such uses. g.      You agree to defend, indemnify and hold harmless NVIDIA and its affiliates,
 * and their respective employees, contractors, agents, officers and directors, from and against any and all claims,
 * damages, obligations, losses, liabilities, costs or debt, fines, restitutions and expenses (including but not limited
 * to attorney’s fees and costs incident to establishing the right of indemnification) arising out of or related to use
 * of the SOFTWARE outside of the scope of this Agreement, or not in compliance with its terms.
 *
 * 4. PRE-RELEASE. SOFTWARE versions identified as alpha, beta, preview, early access or otherwise as pre-release may
 * not be fully functional, may contain errors or design flaws, and may have reduced or different security, privacy,
 * availability, and reliability standards relative to commercial versions of NVIDIA software and materials. You may use
 * a pre-release SOFTWARE version at your own risk, understanding that these versions are not intended for use in
 * production or business-critical systems.
 *
 * 5. OWNERSHIP. The SOFTWARE and the related intellectual property rights therein are and will remain the sole and
 * exclusive property of NVIDIA or its licensors. The SOFTWARE is copyrighted and protected by the laws of the United
 * States and other countries, and international treaty provisions. NVIDIA may make changes to the SOFTWARE, at any time
 * without notice, but is not obligated to support or update the SOFTWARE.
 *
 * 6. COMPONENTS UNDER OTHER LICENSES. The SOFTWARE may include NVIDIA or third-party components with separate legal
 * notices or terms as may be described in proprietary notices accompanying the SOFTWARE. If and to the extent there is
 * a conflict between the terms in this license and the license terms associated with a component, the license terms
 * associated with the components control only to the extent necessary to resolve the conflict.
 *
 * 7. FEEDBACK. You may, but don’t have to, provide to NVIDIA any Feedback. “Feedback” means any suggestions, bug fixes,
 * enhancements, modifications, feature requests or other feedback regarding the SOFTWARE. For any Feedback that you
 * voluntarily provide, you hereby grant NVIDIA and its affiliates a perpetual, non-exclusive, worldwide, irrevocable
 * license to use, reproduce, modify, license, sublicense (through multiple tiers of sublicensees), and distribute
 * (through multiple tiers of distributors) the Feedback without the payment of any royalties or fees to you. NVIDIA
 * will use Feedback at its choice.
 *
 * 8. NO WARRANTIES. THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY OF ANY KIND INCLUDING, BUT
 * NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA DOES NOT
 * WARRANT THAT THE SOFTWARE WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION THEREOF WILL BE UNINTERRUPTED OR
 * ERROR-FREE, OR THAT ALL ERRORS WILL BE CORRECTED.
 *
 * 9. LIMITATIONS OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY LAW, NVIDIA AND ITS AFFILIATES SHALL NOT BE LIABLE
 * FOR ANY SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, OR ANY LOST PROFITS, PROJECT DELAYS, LOSS OF USE,
 * LOSS OF DATA OR LOSS OF GOODWILL, OR THE COSTS OF PROCURING SUBSTITUTE PRODUCTS, ARISING OUT OF OR IN CONNECTION WITH
 * THIS LICENSE OR THE USE OR PERFORMANCE OF THE SOFTWARE, WHETHER SUCH LIABILITY ARISES FROM ANY CLAIM BASED UPON
 * BREACH OF CONTRACT, BREACH OF WARRANTY, TORT (INCLUDING NEGLIGENCE), PRODUCT LIABILITY OR ANY OTHER CAUSE OF ACTION
 * OR THEORY OF LIABILITY, EVEN IF NVIDIA HAS PREVIOUSLY BEEN ADVISED OF, OR COULD REASONABLY HAVE FORESEEN, THE
 * POSSIBILITY OF SUCH DAMAGES. IN NO EVENT WILL NVIDIA’S AND ITS AFFILIATES TOTAL CUMULATIVE LIABILITY UNDER OR ARISING
 * OUT OF THIS LICENSE EXCEED US$10.00. THE NATURE OF THE LIABILITY OR THE NUMBER OF CLAIMS OR SUITS SHALL NOT ENLARGE
 * OR EXTEND THIS LIMIT.
 *
 * 10. TERMINATION. Your rights under this license will terminate automatically without notice from NVIDIA if you fail
 * to comply with any term and condition of this license or if you commence or participate in any legal proceeding
 * against NVIDIA with respect to the SOFTWARE. NVIDIA may terminate this license with advance written notice to you if
 * NVIDIA decides to no longer provide the SOFTWARE in a country or, in NVIDIA’s sole discretion, the continued use of
 * it is no longer commercially viable. Upon any termination of this license, you agree to promptly discontinue use of
 * the SOFTWARE and destroy all copies in your possession or control. Your prior distributions in accordance with this
 * license are not affected by the termination of this license. All provisions of this license will survive termination,
 * except for the license granted to you.
 *
 * 11. APPLICABLE LAW. This license will be governed in all respects by the laws of the United States and of the State
 * of Delaware as those laws are applied to contracts entered into and performed entirely within Delaware by Delaware
 * residents, without regard to the conflicts of laws principles. The United Nations Convention on Contracts for the
 * International Sale of Goods is specifically disclaimed. You agree to all terms of this Agreement in the English
 * language. The state or federal courts residing in Santa Clara County, California shall have exclusive jurisdiction
 * over any dispute or claim arising out of this license. Notwithstanding this, you agree that NVIDIA shall still be
 * allowed to apply for injunctive remedies or an equivalent type of urgent legal relief in any jurisdiction.
 *
 * 12. NO ASSIGNMENT. This license and your rights and obligations thereunder may not be assigned by you by any means or
 * operation of law without NVIDIA’s permission. Any attempted assignment not approved by NVIDIA in writing shall be
 * void and of no effect.
 *
 * 13. EXPORT. The SOFTWARE is subject to United States export laws and regulations. You agree that you will not ship,
 * transfer or export the SOFTWARE into any country, or use the SOFTWARE in any manner, prohibited by the United States
 * Bureau of Industry and Security or economic sanctions regulations administered by the U.S. Department of Treasury’s
 * Office of Foreign Assets Control (OFAC), or any applicable export laws, restrictions or regulations. These laws
 * include restrictions on destinations, end users and end use. By accepting this license, you confirm that you are not
 * a resident or citizen of any country currently embargoed by the U.S. and that you are not otherwise prohibited from
 * receiving the SOFTWARE.
 *
 * 14. GOVERNMENT USE. The SOFTWARE has been developed entirely at private expense and is “commercial items” consisting
 * of “commercial computer software” and “commercial computer software documentation” provided with RESTRICTED RIGHTS.
 * Use, duplication or disclosure by the U.S. Government or a U.S. Government subcontractor is subject to the
 * restrictions in this license pursuant to DFARS 227.7202-3(a) or as set forth in subparagraphs (b)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR 52.227-19, as applicable. Contractor/manufacturer is
 * NVIDIA, 2788 San Tomas Expressway, Santa Clara, CA 95051.
 *
 * 15. ENTIRE AGREEMENT. This license is the final, complete and exclusive agreement between the parties relating to the
 * subject matter of this license and supersedes all prior or contemporaneous understandings and agreements relating to
 * this subject matter, whether oral or written. If any court of competent jurisdiction determines that any provision of
 * this license is illegal, invalid or unenforceable, the remaining provisions will remain in full force and effect.
 * This license may only be modified in a writing signed by an authorized representative of each party.
 *
 * (v. August 20, 2021)
 */

#ifndef _CUDA_TRY_CANCEL
#define _CUDA_TRY_CANCEL

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

_LIBCUDACXX_BEGIN_NAMESPACE_CUDA

namespace experimental {

namespace __detail {

struct __empty_t {
  __device__ void operator()(dim3);
};

template <int __I>
_CCCL_NODISCARD _CCCL_DEVICE _CCCL_HIDE_FROM_ABI int __cluster_get_dim(__int128 __result) noexcept {
    int __r;
    if constexpr(__I == 0) {
        asm volatile("clusterlaunchcontrol.query_cancel.get_first_ctaid::x.b32.b128 %0, %1;" : "=r"(__r) : "q"(__result) : "memory");
    } else if constexpr(__I == 1) {
        asm volatile("clusterlaunchcontrol.query_cancel.get_first_ctaid::y.b32.b128 %0, %1;" : "=r"(__r) : "q"(__result) : "memory");
    } else if constexpr(__I == 2) {
        asm volatile("clusterlaunchcontrol.query_cancel.get_first_ctaid::z.b32.b128 %0, %1;" : "=r"(__r) : "q"(__result) : "memory");
    } else {
      __r = -1;
      #ifndef NDEBUG
      __trap();
      #endif
    }
    return __r;
}

} // namespace __detail

/// This API for implementing work-stealing, repeatedly attempts to cancel the launch of a thread block
/// from the current grid. On success, it invokes the unary function `__uf` before trying again.
/// On failure, it returns.
///
/// This API does not provide any memory synchronization.
/// This API does not guarantee that any thread will invoke `__uf` with the next block index until all
/// invocatons of `__uf` for the prior block index have returned.
///
/// Preconditions:
/// - All thread block threads shall call this API exactly once.
/// - Exactly one thread block thread shall call this API with `__is_leader` equals `true`.  
template <int __ThreadBlockDim = 3, typename __UnaryFunction = __detail::__empty_t>
    requires std::is_invocable_r_v<void, __UnaryFunction, dim3>
_CCCL_DEVICE _CCCL_HIDE_FROM_ABI void try_cancel_blocks(bool __is_leader, __UnaryFunction __uf) {
  NV_IF_ELSE_TARGET(NV_PROVIDES_SM_100,
    (
    __shared__ uint64_t __barrier; // TODO: use 2 barriers and 2 results avoid last sync threads
    __shared__ __int128 __result;
    bool __phase = false;
    dim3 __block_idx;

    if constexpr (__ThreadBlockDim == 3) {
      __block_idx = dim3(blockIdx.x, blockIdx.y, blockIdx.z);
    } else if constexpr (__ThreadBlockDim == 2) {
      __block_idx = dim3(blockIdx.x, blockIdx.y, 1);
    } else if constexpr (__ThreadBlockDim == 1) {
      __block_idx = dim3(blockIdx.x, 1, 1);      
    } else {
      #ifndef NDEBUG
        __trap();
      #endif
    }

    // Initialize barrier and kick-start try_cancel pipeline:
    if (__is_leader) {
        auto __leader_mask = __activemask();
        asm volatile(
            "{\n\t"
                ".reg .pred p;\n\t"	       
                // elect.sync is a workaround for peeling loop (#nvbug-id)
                "elect.sync _|p, %2;\n\t"
                "@p mbarrier.init.shared::cta.b64 [%1], 1;\n\t"
                "@p clusterlaunchcontrol.try_cancel.async.shared::cta.mbarrier::complete_tx::bytes.b128 [%0], [%1];\n\t"
                "@p mbarrier.arrive.expect_tx.release.cta.shared::cta.b64 _, [%1], 16;\n\t"
            "}"
            :
            : "r"((int)__cvta_generic_to_shared(&__result)), "r"((int)__cvta_generic_to_shared(&__barrier)), "r"(__leader_mask)
            : "memory"
        );
    }
    // Note: mbarrier only accessed by control thread; no inter-thread synchronization required.

    do {
        __uf(__block_idx); // Invoke unary function.

        if (__is_leader) {
	  asm volatile(
                "{\n\t"
                    ".reg .pred p;\n\t"
		    "waitLoop:\n\t\t"
     		        "mbarrier.try_wait.parity.relaxed.cta.shared.b64 p, [%0], %1;\n\t\t"
                        "@!p bra waitLoop;\n\t"
                "}"
                :
		: "r"((int)__cvta_generic_to_shared(&__barrier)), "r"((unsigned)__phase)
		: "memory"
            );
	  __phase = !__phase;
        }
        __syncthreads(); // All threads of prior thread block have "exited".

	// Note: clusterlaunchcontrol.try_cancel arrives at barrier using generic-proxy,
	// and performs cross-proxy fencing required to allows reading '__result' using generic-proxy.
	// Therefore no intra-thread cross-proxy synchronization required to wait on
	// mbarrier or read the result.
        {
            int __success = 0;
            asm volatile(
	        "{\n\t"
                    ".reg .pred p;\n\t"
                    "clusterlaunchcontrol.query_cancel.is_canceled.pred.b128 p, %1;\n\t"
                    "selp.b32 %0, 1, 0, p;\n\t"
                "}\n\t"
                : "=r"(__success)
                : "q"(__result)
            );
            if (__success != 1) {
                // Invalidating mbarrier and synchronizing before exiting not
                // required since each thread block calls this API at most once.
                break;
            }
        }

        // Read new thread block dimensions
        if constexpr (__ThreadBlockDim == 3) {
            int __bx = __detail::__cluster_get_dim<0>(__result);
            int __by = __detail::__cluster_get_dim<1>(__result);
            int __bz = __detail::__cluster_get_dim<2>(__result);
            __block_idx = dim3(__bx, __by, __bz);
        } else if constexpr (__ThreadBlockDim == 2) {
            int __bx = __detail::__cluster_get_dim<0>(__result);
            int __by = __detail::__cluster_get_dim<1>(__result);
            __block_idx = dim3(__bx, __by, 1);
        } else if constexpr (__ThreadBlockDim == 1) {
            int __bx = __detail::__cluster_get_dim<0>(__result);
            __block_idx = dim3(__bx, 1, 1);
        } else {
	  __trap();
	}

        // Wait for all threads to read __result before issuing next async op.
        // generic->generic synchronization
        __syncthreads();
	// TODO: only control-warp requires sync, other warps can arrive
	// TODO: double-buffering results+barrier pairs using phase avoids this sync

        if (__is_leader) {
  	    auto __leader_mask = __activemask();
            asm volatile(
                "{\n\t"
                    ".reg .pred p;\n\t"		
                    // elect.sync is a workaround for peeling loop (#nvbug-id)
                    "elect.sync _|p, %2;\n\t"
                    // Note: the clusterlaunchcontrol.try_cancel operation generic->async writes to 'result' using
		    // async-proxy. Therefore, uni-directional release + acquire generic->async intra-thread synchronization
		    // is required to order the prior loads of the result on the current loop iteration, before the
		    // async-proxy writes of clusterlaunchcontrol.try_cancel of the next iteration.
		    // All cross-proxy fencing is performed in the control-thread only since all threads issuing reads of
		    // result are in the same thread block as the control thread.
                    "@p fence.proxy.async::generic.release.sync_restrict::shared::cta.cluster;\n\t"
                    "@p fence.proxy.async::generic.acquire.sync_restrict::shared::cluster.cluster;"
                    // try to cancel another thread block
                    "@p clusterlaunchcontrol.try_cancel.async.shared::cta.mbarrier::complete_tx::bytes.b128 [%0], [%1];\n\t"
                    "@p mbarrier.arrive.expect_tx.relaxed.cta.shared::cta.b64 _, [%1], 16;\n\t"
                "}"
                :
                : "r"((int)__cvta_generic_to_shared(&__result)), "r"((int)__cvta_generic_to_shared(&__barrier)), "r"(__leader_mask)
                : "memory"
            );
        }
      } while (true);
    ), ( // NV_IF_ELSE_TARGET(NV_PROVIDES_SM_100,
      // SW fall-back for lower compute capabilities.
      // TODO: it may make sense to __trap here instead since lower compute capabilities may want
      // to do something else (grid-stride, atomics, etc.).
      // A higher-level abstraction like for_each should handle that.

      __uf(blockId);
    )
  )  // NV_IF_ELSE_TARGET(NV_PROVIDES_SM_100,
}

} // namespace experimental

_LIBCUDACXX_END_NAMESPACE_CUDA

#endif // _CUDA_ANNOTATED_PTR
