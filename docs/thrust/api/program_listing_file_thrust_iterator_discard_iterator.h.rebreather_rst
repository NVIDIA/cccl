thrust\/iterator\/discard\_iterator.h
=====================================

File members: :ref:`thrust\/iterator\/discard\_iterator.h <discard__iterator_8h>`

.. code-block:: c++

   /*
    *  Copyright 2008-2013 NVIDIA Corporation
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    */

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <thrust/iterator/counting_iterator.h>
   #include <thrust/iterator/detail/any_assign.h>
   #include <thrust/iterator/iterator_adaptor.h>

   #include <cuda/std/cstddef>

   THRUST_NAMESPACE_BEGIN

   template <typename>
   class discard_iterator;

   namespace detail
   {
   template <typename System>
   struct make_discard_iterator_base
   {
     // XXX value_type should actually be void but this interferes with zip_iterator<discard_iterator>
     using value_type    = any_assign;
     using reference     = any_assign&;
     using incrementable = ::cuda::std::ptrdiff_t;

     using base_iterator = counting_iterator<incrementable, System, random_access_traversal_tag>;

     using type =
       iterator_adaptor<discard_iterator<System>,
                        base_iterator,
                        value_type,
                        iterator_system_t<base_iterator>,
                        iterator_traversal_t<base_iterator>,
                        reference>;
   };
   } // namespace detail

   _CCCL_DIAG_PUSH
   _CCCL_DIAG_SUPPRESS_MSVC(4244 4267) // possible loss of data

   template <typename System = use_default>
   class discard_iterator : public detail::make_discard_iterator_base<System>::type
   {
     friend class iterator_core_access;
     using super_t       = typename detail::make_discard_iterator_base<System>::type;
     using incrementable = typename detail::make_discard_iterator_base<System>::incrementable;
     using base_iterator = typename detail::make_discard_iterator_base<System>::base_iterator;

   public:
     using reference  = typename super_t::reference;
     using value_type = typename super_t::value_type;

     _CCCL_HOST_DEVICE discard_iterator(incrementable const& i = incrementable())
         : super_t(base_iterator(i))
     {}

   private: // Core iterator interface
     _CCCL_HOST_DEVICE reference dereference() const
     {
       return m_element;
     }

     mutable value_type m_element;

   };

   template <typename System = use_default>
   inline _CCCL_HOST_DEVICE discard_iterator<System> make_discard_iterator(::cuda::std::ptrdiff_t i = 0)
   {
     return discard_iterator<System>{i};
   }

   _CCCL_DIAG_POP

   THRUST_NAMESPACE_END

