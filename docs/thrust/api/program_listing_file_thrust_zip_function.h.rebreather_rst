thrust\/zip\_function.h
=======================

File members: :ref:`thrust\/zip\_function.h <zip__function_8h>`

.. code-block:: c++

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <thrust/detail/type_deduction.h>
   #include <thrust/tuple.h>
   #include <thrust/type_traits/integer_sequence.h>

   #include <cuda/functional>

   THRUST_NAMESPACE_BEGIN

   namespace detail
   {
   namespace zip_detail
   {

   // Add workaround for decltype(auto) on C++11-only compilers:
   _CCCL_EXEC_CHECK_DISABLE
   template <typename Function, typename Tuple, std::size_t... Is>
   _CCCL_HOST_DEVICE decltype(auto) apply_impl(Function&& func, Tuple&& args, index_sequence<Is...>)
   {
     return func(thrust::get<Is>(THRUST_FWD(args))...);
   }

   template <typename Function, typename Tuple>
   _CCCL_HOST_DEVICE decltype(auto) apply(Function&& func, Tuple&& args)
   {
     constexpr auto tuple_size = thrust::tuple_size<::cuda::std::decay_t<Tuple>>::value;
     return apply_impl(THRUST_FWD(func), THRUST_FWD(args), make_index_sequence<tuple_size>{});
   }

   } // namespace zip_detail
   } // namespace detail

   template <typename Function>
   class zip_function
   {
   public:
     zip_function() = default;

     _CCCL_HOST_DEVICE zip_function(Function func)
         : func(::cuda::std::move(func))
     {}

     // Add workaround for decltype(auto) on C++11-only compilers:

     template <typename Tuple>
     _CCCL_HOST_DEVICE decltype(auto) operator()(Tuple&& args) const
     {
       return detail::zip_detail::apply(func, THRUST_FWD(args));
     }

     _CCCL_HOST_DEVICE Function& underlying_function() const
     {
       return func;
     }

   private:
     mutable Function func;
   };

   template <typename Function>
   _CCCL_HOST_DEVICE zip_function<::cuda::std::decay_t<Function>> make_zip_function(Function&& fun)
   {
     using func_t = ::cuda::std::decay_t<Function>;
     return zip_function<func_t>(THRUST_FWD(fun));
   }

   THRUST_NAMESPACE_END

   _CCCL_BEGIN_NAMESPACE_CUDA
   template <typename F>
   struct proclaims_copyable_arguments<THRUST_NS_QUALIFIER::zip_function<F>> : proclaims_copyable_arguments<F>
   {};
   _CCCL_END_NAMESPACE_CUDA

