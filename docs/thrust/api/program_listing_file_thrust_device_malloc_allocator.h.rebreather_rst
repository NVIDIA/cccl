thrust\/device\_malloc\_allocator.h
===================================

File members: :ref:`thrust\/device\_malloc\_allocator.h <device__malloc__allocator_8h>`

.. code-block:: c++

   /*
    *  Copyright 2008-2018 NVIDIA Corporation
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    */

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header
   #include <thrust/device_free.h>
   #include <thrust/device_malloc.h>
   #include <thrust/device_ptr.h>
   #include <thrust/device_reference.h>

   #include <cuda/std/__new/bad_alloc.h>
   #include <cuda/std/limits>

   THRUST_NAMESPACE_BEGIN

   // forward declarations to WAR circular #includes
   #ifndef _CCCL_DOXYGEN_INVOKED // Do not document
   template <typename>
   class device_ptr;
   template <typename T>
   device_ptr<T> device_malloc(const std::size_t n);
   #endif // _CCCL_DOXYGEN_INVOKED

   template <typename T>
   class device_malloc_allocator
   {
   public:
     using value_type = T;

     using pointer = device_ptr<T>;

     using const_pointer = device_ptr<const T>;

     using reference = device_reference<T>;

     using const_reference = device_reference<const T>;

     using size_type = std::size_t;

     using difference_type = typename pointer::difference_type;

     template <typename U>
     struct rebind
     {
       using other = device_malloc_allocator<U>;
     }; // end rebind

     _CCCL_HOST_DEVICE inline device_malloc_allocator() {}

     _CCCL_HOST_DEVICE inline ~device_malloc_allocator() {}

     _CCCL_HOST_DEVICE inline device_malloc_allocator(device_malloc_allocator const&) {}

     template <typename U>
     _CCCL_HOST_DEVICE inline device_malloc_allocator(device_malloc_allocator<U> const&)
     {}

     device_malloc_allocator& operator=(const device_malloc_allocator&) = default;

     _CCCL_HOST_DEVICE inline pointer address(reference r)
     {
       return &r;
     }

     _CCCL_HOST_DEVICE inline const_pointer address(const_reference r)
     {
       return &r;
     }

     _CCCL_HOST inline pointer allocate(size_type cnt, const_pointer = const_pointer(static_cast<T*>(0)))
     {
       if (cnt > this->max_size())
       {
         ::cuda::std::__throw_bad_alloc();
       } // end if

       return pointer(device_malloc<T>(cnt));
     } // end allocate()

     _CCCL_HOST inline void deallocate(pointer p, [[maybe_unused]] size_type cnt) noexcept
     {
       device_free(p);
     } // end deallocate()

     inline size_type max_size() const
     {
       return (::cuda::std::numeric_limits<size_type>::max)() / sizeof(T);
     } // end max_size()

     _CCCL_HOST_DEVICE inline bool operator==(device_malloc_allocator const&) const
     {
       return true;
     }

     _CCCL_HOST_DEVICE inline bool operator!=(device_malloc_allocator const& a) const
     {
       return !operator==(a);
     }
   }; // end device_malloc_allocator

   THRUST_NAMESPACE_END

