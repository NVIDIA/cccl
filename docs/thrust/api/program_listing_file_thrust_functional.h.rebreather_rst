thrust\/functional.h
====================

File members: :ref:`thrust\/functional.h <functional_8h>`

.. code-block:: c++

   /*
    *  Copyright 2008-2018 NVIDIA Corporation
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    */

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <thrust/detail/functional/actor.h>

   #include <cuda/functional>
   #include <cuda/std/functional>

   THRUST_NAMESPACE_BEGIN

   template <class T = void>
   using divides CCCL_DEPRECATED_BECAUSE("Use cuda::std::divides instead") = ::cuda::std::divides<T>;
   template <class T = void>
   using minus CCCL_DEPRECATED_BECAUSE("Use cuda::std::minus instead") = ::cuda::std::minus<T>;
   template <class T = void>
   using modulus CCCL_DEPRECATED_BECAUSE("Use cuda::std::modulus instead") = ::cuda::std::modulus<T>;
   template <class T = void>
   using multiplies CCCL_DEPRECATED_BECAUSE("Use cuda::std::multiplies instead") = ::cuda::std::multiplies<T>;
   template <class T = void>
   using negate CCCL_DEPRECATED_BECAUSE("Use cuda::std::negate instead") = ::cuda::std::negate<T>;
   template <class T = void>
   using plus CCCL_DEPRECATED_BECAUSE("Use cuda::std::plus instead") = ::cuda::std::plus<T>;

   template <typename T = void>
   struct square
   {
     _CCCL_EXEC_CHECK_DISABLE
     _CCCL_HOST_DEVICE constexpr T operator()(const T& x) const
     {
       return x * x;
     }
   };

   template <>
   struct square<void>
   {
     using is_transparent = void;

     _CCCL_EXEC_CHECK_DISABLE
     template <typename T>
     _CCCL_HOST_DEVICE constexpr T operator()(const T& x) const noexcept(noexcept(x * x))
     {
       return x * x;
     }
   };

   template <class T = void>
   using equal_to CCCL_DEPRECATED_BECAUSE("Use cuda::std::equal_to instead") = ::cuda::std::equal_to<T>;
   template <class T = void>
   using greater CCCL_DEPRECATED_BECAUSE("Use cuda::std::greater instead") = ::cuda::std::greater<T>;
   template <class T = void>
   using greater_equal CCCL_DEPRECATED_BECAUSE("Use cuda::std::greater_equal instead") = ::cuda::std::greater_equal<T>;
   template <class T = void>
   using less CCCL_DEPRECATED_BECAUSE("Use cuda::std::less instead") = ::cuda::std::less<T>;
   template <class T = void>
   using less_equal CCCL_DEPRECATED_BECAUSE("Use cuda::std::less_equal instead") = ::cuda::std::less_equal<T>;
   template <class T = void>
   using not_equal_to CCCL_DEPRECATED_BECAUSE("Use cuda::std::not_equal_to instead") = ::cuda::std::not_equal_to<T>;

   template <class T = void>
   using logical_and CCCL_DEPRECATED_BECAUSE("Use cuda::std::logical_and instead") = ::cuda::std::logical_and<T>;
   template <class T = void>
   using logical_not CCCL_DEPRECATED_BECAUSE("Use cuda::std::logical_not instead") = ::cuda::std::logical_not<T>;
   template <class T = void>
   using logical_or CCCL_DEPRECATED_BECAUSE("Use cuda::std::logical_or instead") = ::cuda::std::logical_or<T>;

   template <class T = void>
   using bit_and CCCL_DEPRECATED_BECAUSE("Use cuda::std::bit_and instead") = ::cuda::std::bit_and<T>;
   template <class T = void>
   using bit_or CCCL_DEPRECATED_BECAUSE("Use cuda::std::bit_or instead") = ::cuda::std::bit_or<T>;
   template <class T = void>
   using bit_xor CCCL_DEPRECATED_BECAUSE("Use cuda::std::bit_xor instead") = ::cuda::std::bit_xor<T>;

   template <class T = void>
   using maximum CCCL_DEPRECATED_BECAUSE("Use cuda::maximum instead") = ::cuda::maximum<T>;
   template <class T = void>
   using minimum CCCL_DEPRECATED_BECAUSE("Use cuda::minimum instead") = ::cuda::minimum<T>;

   template <typename T1 = void, typename T2 = void>
   struct project1st
   {
     _CCCL_HOST_DEVICE constexpr const T1& operator()(const T1& lhs, const T2& /*rhs*/) const
     {
       return lhs;
     }
   };

   template <>
   struct project1st<void, void>
   {
     using is_transparent = void;
     _CCCL_EXEC_CHECK_DISABLE
     template <typename T1, typename T2>
     _CCCL_HOST_DEVICE constexpr auto operator()(T1&& t1, T2&&) const noexcept(noexcept(THRUST_FWD(t1)))
       -> decltype(THRUST_FWD(t1))
     {
       return THRUST_FWD(t1);
     }
   };

   template <typename T1 = void, typename T2 = void>
   struct project2nd
   {
     _CCCL_HOST_DEVICE constexpr const T2& operator()(const T1& /*lhs*/, const T2& rhs) const
     {
       return rhs;
     }
   }; // end project2nd

   template <>
   struct project2nd<void, void>
   {
     using is_transparent = void;
     _CCCL_EXEC_CHECK_DISABLE
     template <typename T1, typename T2>
     _CCCL_HOST_DEVICE constexpr auto operator()(T1&&, T2&& t2) const noexcept(noexcept(THRUST_FWD(t2)))
       -> decltype(THRUST_FWD(t2))
     {
       return THRUST_FWD(t2);
     }
   };

   // odds and ends

   #ifdef _CCCL_DOXYGEN_INVOKED
   using ::cuda::std::not_fn;
   #else // ^^^ _CCCL_DOXYGEN_INVOKED ^^^ / vvv !_CCCL_DOXYGEN_INVOKED vvv
   _CCCL_TEMPLATE(class _Fn)
   _CCCL_REQUIRES(::cuda::std::is_constructible_v<::cuda::std::decay_t<_Fn>, _Fn>
                    _CCCL_AND ::cuda::std::is_move_constructible_v<::cuda::std::decay_t<_Fn>>)
   CCCL_DEPRECATED_BECAUSE("Use cuda::std::not_fn instead")
   [[nodiscard]] _CCCL_API constexpr auto not_fn(_Fn&& __f)
   {
     return ::cuda::std::not_fn(::cuda::std::forward<_Fn>(__f));
   }
   #endif // !_CCCL_DOXYGEN_INVOKED

   namespace placeholders
   {

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<0>::type _1;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<1>::type _2;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<2>::type _3;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<3>::type _4;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<4>::type _5;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<5>::type _6;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<6>::type _7;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<7>::type _8;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<8>::type _9;

   _CCCL_GLOBAL_CONSTANT thrust::detail::functional::placeholder<9>::type _10;

   } // namespace placeholders

   THRUST_NAMESPACE_END

   #include <thrust/detail/functional/operators.h>
   #include <thrust/detail/type_traits/is_commutative.h>

