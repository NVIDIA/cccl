thrust\/device\_new\_allocator.h
================================

File members: :ref:`thrust\/device\_new\_allocator.h <device__new__allocator_8h>`

.. code-block:: c++

   /*
    *  Copyright 2008-2013 NVIDIA Corporation
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    */

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header
   #include <thrust/device_delete.h>
   #include <thrust/device_new.h>
   #include <thrust/device_ptr.h>
   #include <thrust/device_reference.h>

   #include <cuda/std/__new/bad_alloc.h>
   #include <cuda/std/cstdint>
   #include <cuda/std/limits>

   THRUST_NAMESPACE_BEGIN

   template <typename T>
   class device_new_allocator
   {
   public:
     using value_type = T;

     using pointer = device_ptr<T>;

     using const_pointer = device_ptr<const T>;

     using reference = device_reference<T>;

     using const_reference = device_reference<const T>;

     using size_type = ::cuda::std::size_t;

     using difference_type = typename pointer::difference_type;

     template <typename U>
     struct rebind
     {
       using other = device_new_allocator<U>;
     }; // end rebind

     _CCCL_HOST_DEVICE inline device_new_allocator() {}

     _CCCL_HOST_DEVICE inline ~device_new_allocator() {}

     _CCCL_HOST_DEVICE inline device_new_allocator(device_new_allocator const&) {}

     template <typename U>
     _CCCL_HOST_DEVICE inline device_new_allocator(device_new_allocator<U> const&)
     {}

     _CCCL_HOST_DEVICE inline pointer address(reference r)
     {
       return &r;
     }

     _CCCL_HOST_DEVICE inline const_pointer address(const_reference r)
     {
       return &r;
     }

     _CCCL_HOST inline pointer allocate(size_type cnt, const_pointer = const_pointer(static_cast<T*>(0)))
     {
       if (cnt > this->max_size())
       {
         ::cuda::std::__throw_bad_alloc();
       } // end if

       // use "::operator new" rather than keyword new
       return pointer(device_new<T>(cnt));
     } // end allocate()

     _CCCL_HOST inline void deallocate(pointer p, [[maybe_unused]] size_type cnt) noexcept
     {
       // use "::operator delete" rather than keyword delete
       device_delete(p);
     } // end deallocate()

     _CCCL_HOST_DEVICE inline size_type max_size() const
     {
       return ::cuda::std::numeric_limits<size_type>::max THRUST_PREVENT_MACRO_SUBSTITUTION() / sizeof(T);
     } // end max_size()

     _CCCL_HOST_DEVICE inline bool operator==(device_new_allocator const&)
     {
       return true;
     }

     _CCCL_HOST_DEVICE inline bool operator!=(device_new_allocator const& a)
     {
       return !operator==(a);
     }
   }; // end device_new_allocator

   THRUST_NAMESPACE_END

