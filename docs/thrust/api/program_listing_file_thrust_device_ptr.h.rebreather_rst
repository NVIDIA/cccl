thrust\/device\_ptr.h
=====================

File members: :ref:`thrust\/device\_ptr.h <device__ptr_8h>`

.. code-block:: c++

   /*
    *  Copyright 2008-2021 NVIDIA Corporation
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    */

   #pragma once

   #include <thrust/detail/config.h>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header
   #include <thrust/memory.h>

   THRUST_NAMESPACE_BEGIN

   template <typename T>
   class device_reference;

   template <typename T>
   class device_ptr
       : public thrust::pointer<T, thrust::device_system_tag, thrust::device_reference<T>, thrust::device_ptr<T>>
   {
   private:
     using super_t = thrust::pointer<T, thrust::device_system_tag, thrust::device_reference<T>, thrust::device_ptr<T>>;

   public:
     _CCCL_HIDE_FROM_ABI device_ptr() = default;

     _CCCL_HOST_DEVICE device_ptr(std::nullptr_t)
         : super_t(nullptr)
     {}

     template <typename U>
     _CCCL_HOST_DEVICE explicit device_ptr(U* ptr)
         : super_t(ptr)
     {}

     template <typename U>
     _CCCL_HOST_DEVICE device_ptr(device_ptr<U> const& other)
         : super_t(other)
     {}

     template <typename U>
     _CCCL_HOST_DEVICE device_ptr& operator=(device_ptr<U> const& other)
     {
       super_t::operator=(other);
       return *this;
     }

     _CCCL_HOST_DEVICE device_ptr& operator=(std::nullptr_t)
     {
       super_t::operator=(nullptr);
       return *this;
     }
   };

   #ifdef _CCCL_DOXYGEN_INVOKED

   template <typename T, typename CharT, typename Traits>
   _CCCL_HOST std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& os, device_ptr<T> const& dp);
   #endif

   template <typename T>
   _CCCL_HOST_DEVICE device_ptr<T> device_pointer_cast(T* ptr);

   template <typename T>
   _CCCL_HOST_DEVICE device_ptr<T> device_pointer_cast(device_ptr<T> const& dptr);

   THRUST_NAMESPACE_END

   #include <thrust/detail/device_ptr.inl>
   #include <thrust/detail/raw_pointer_cast.h>

