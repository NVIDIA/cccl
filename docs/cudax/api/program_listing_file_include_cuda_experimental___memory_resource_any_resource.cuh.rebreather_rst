include\/cuda\/experimental\/\_\_memory\_resource\/any\_resource.cuh
====================================================================

File members: :ref:`include\/cuda\/experimental\/\_\_memory\_resource\/any\_resource.cuh <any__resource_8cuh>`

.. code-block:: c++

   //===----------------------------------------------------------------------===//
   //
   // Part of CUDA Experimental in CUDA C++ Core Libraries,
   // under the Apache License v2.0 with LLVM Exceptions.
   // See https://llvm.org/LICENSE.txt for license information.
   // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
   // SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES.
   //
   //===----------------------------------------------------------------------===//

   #ifndef _CUDAX__MEMORY_RESOURCE_ANY_RESOURCE_H
   #define _CUDAX__MEMORY_RESOURCE_ANY_RESOURCE_H

   #include <cuda/std/detail/__config>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cuda/__memory_resource/get_property.h>
   #include <cuda/__memory_resource/resource.h>
   #include <cuda/__memory_resource/resource_ref.h>
   #include <cuda/__utility/basic_any.h>
   #include <cuda/std/__concepts/concept_macros.h>
   #include <cuda/std/__utility/forward.h>
   #include <cuda/std/optional>

   #include <cuda/experimental/__memory_resource/properties.cuh>

   #include <cuda/std/__cccl/prologue.h>

   namespace cuda::experimental
   {
   #ifndef _CCCL_DOXYGEN_INVOKED // Do not document this

   template <class _Property>
   using __property_result_t _CCCL_NODEBUG_ALIAS = _CUDA_VSTD::__type_call1< //
     _CUDA_VSTD::conditional_t<cuda::property_with_value<_Property>,
                               _CUDA_VSTD::__type_quote1<__property_value_t>,
                               _CUDA_VSTD::__type_always<void>>,
     _Property>;

   template <class _Property>
   struct __with_property
   {
     template <class _Ty>
     _CCCL_PUBLIC_HOST_API static auto __get_property(const _Ty& __obj) //
       -> __property_result_t<_Property>
     {
       if constexpr (!_CUDA_VSTD::is_same_v<__property_result_t<_Property>, void>)
       {
         return get_property(__obj, _Property());
       }
       else
       {
         return void();
       }
     }

     template <class...>
     struct __iproperty : __basic_interface<__iproperty>
     {
       _CCCL_HOST_API friend auto get_property([[maybe_unused]] const __iproperty& __obj, _Property)
         -> __property_result_t<_Property>
       {
         if constexpr (!_CUDA_VSTD::is_same_v<__property_result_t<_Property>, void>)
         {
           return ::cuda::__virtcall<&__get_property<__iproperty>>(&__obj);
         }
         else
         {
           return void();
         }
       }

       template <class _Ty>
       using overrides _CCCL_NODEBUG_ALIAS = __overrides_for<_Ty, &__get_property<_Ty>>;
     };
   };

   template <class _Property>
   using __iproperty = typename __with_property<_Property>::template __iproperty<>;

   template <class... _Properties>
   using __iproperty_set = ::cuda::__iset<__iproperty<_Properties>...>;

   // Wrap the calls of the allocate and deallocate member functions
   // because of NVBUG#4967486
   // Needs to keep the _async because of fun windows macros
   template <class _Resource>
   _CCCL_PUBLIC_HOST_API auto
   __allocate_async(_Resource& __mr, ::cuda::stream_ref __stream, size_t __bytes, size_t __alignment)
     -> decltype(__mr.allocate(__stream, __bytes, __alignment))
   {
     return __mr.allocate(__stream, __bytes, __alignment);
   }

   template <class _Resource>
   _CCCL_PUBLIC_HOST_API auto
   __deallocate_async(_Resource& __mr, ::cuda::stream_ref __stream, void* __pv, size_t __bytes, size_t __alignment)
     -> decltype(__mr.deallocate(__stream, __pv, __bytes, __alignment))
   {
     __mr.deallocate(__stream, __pv, __bytes, __alignment);
   }

   template <class...>
   struct __ibasic_resource : __basic_interface<__ibasic_resource>
   {
     _CCCL_PUBLIC_HOST_API void* allocate_sync(size_t __bytes, size_t __alignment = alignof(_CUDA_VSTD::max_align_t))
     {
       return ::cuda::__virtcall<&__ibasic_resource::allocate_sync>(this, __bytes, __alignment);
     }

     _CCCL_PUBLIC_HOST_API void

     deallocate_sync(void* __pv, size_t __bytes, size_t __alignment = alignof(_CUDA_VSTD::max_align_t))
     {
       return ::cuda::__virtcall<&__ibasic_resource::deallocate_sync>(this, __pv, __bytes, __alignment);
     }

     template <class _Ty>
     using overrides _CCCL_NODEBUG_ALIAS = __overrides_for<_Ty, &_Ty::allocate_sync, &_Ty::deallocate_sync>;
   };

   template <class...>
   struct __ibasic_async_resource : __basic_interface<__ibasic_async_resource>
   {
     _CCCL_PUBLIC_HOST_API void* allocate(::cuda::stream_ref __stream, size_t __bytes, size_t __alignment)
     {
       return ::cuda::__virtcall<&__allocate_async<__ibasic_async_resource>>(this, __stream, __bytes, __alignment);
     }

     _CCCL_PUBLIC_HOST_API void* allocate(::cuda::stream_ref __stream, size_t __bytes)
     {
       return ::cuda::__virtcall<&__allocate_async<__ibasic_async_resource>>(
         this, __stream, __bytes, alignof(_CUDA_VSTD::max_align_t));
     }

     _CCCL_PUBLIC_HOST_API void deallocate(::cuda::stream_ref __stream, void* __pv, size_t __bytes, size_t __alignment)
     {
       return ::cuda::__virtcall<&__deallocate_async<__ibasic_async_resource>>(this, __stream, __pv, __bytes, __alignment);
     }

     _CCCL_PUBLIC_HOST_API void deallocate(::cuda::stream_ref __stream, void* __pv, size_t __bytes)
     {
       return ::cuda::__virtcall<&__deallocate_async<__ibasic_async_resource>>(
         this, __stream, __pv, __bytes, alignof(_CUDA_VSTD::max_align_t));
     }

     template <class _Ty>
     using overrides _CCCL_NODEBUG_ALIAS = __overrides_for<_Ty, &__allocate_async<_Ty>, &__deallocate_async<_Ty>>;
   };

   // This is the pseudo-virtual override for getting an old-style vtable pointer
   // from a new-style __basic_any resource type. It is used below by
   // __iresource_ref_conversions.
   template <class _Resource>
   _CCCL_PUBLIC_HOST_API const _CUDA_VMR::_Alloc_vtable* __get_resource_vptr(_Resource&) noexcept
   {
     if constexpr (_CUDA_VMR::resource<_Resource>)
     {
       return &_CUDA_VMR::__alloc_vtable<_CUDA_VMR::_AllocType::_Default, _CUDA_VMR::_WrapperType::_Reference, _Resource>;
     }
     else if constexpr (_CUDA_VMR::synchronous_resource<_Resource>)
     {
       return &_CUDA_VMR::
         __alloc_vtable<_CUDA_VMR::_AllocType::_Synchronous, _CUDA_VMR::_WrapperType::_Reference, _Resource>;
     }
     else
     {
       // This branch is taken when called from the thunk of an unspecialized
       // interface; e.g., `icat<>` rather than `icat<ialley_cat<>>`. The thunks of
       // unspecialized interfaces are never called, they just need to exist. The
       // function pointer will be used as a key to look up the proper override.
       _CCCL_UNREACHABLE();
     }
   }

   _CCCL_DIAG_PUSH
   _CCCL_DIAG_SUPPRESS_GCC("-Wunused-but-set-parameter")

   // Given a list of properties and a __basic_any vptr, build a _Resource_vtable
   // for the properties as cuda::mr::basic_resource_ref expects.
   template <class _VPtr, class... _Properties>
   _CCCL_HOST_API auto __make_resource_vtable(_VPtr __vptr, _CUDA_VMR::_Resource_vtable<_Properties...>*) noexcept
     -> _CUDA_VMR::_Resource_vtable<_Properties...>
   {
     return {__vptr->__query_interface(__iproperty<_Properties>())->__fn_...};
   }

   _CCCL_DIAG_POP

   // This interface provides the any_[async_]resource types with a conversion
   // to the old cuda::mr::basic_resource_ref types.
   template <class... _Super>
   struct _CCCL_DECLSPEC_EMPTY_BASES __iresource_ref_conversions
       : __basic_interface<__iresource_ref_conversions>
       , _CUDA_VMR::_Resource_ref_base
   {
     using __self_t = __basic_any_from_t<__iresource_ref_conversions&>;

     template <class _Property>
     using __iprop = __rebind_interface<__iproperty<_Property>, _Super...>;

     template <_CUDA_VMR::_AllocType _Alloc_type>
     using __iresource = __rebind_interface<
       _CUDA_VSTD::
         conditional_t<_Alloc_type == _CUDA_VMR::_AllocType::_Synchronous, __ibasic_resource<>, __ibasic_async_resource<>>,
       _Super...>;

     _CCCL_TEMPLATE(_CUDA_VMR::_AllocType _Alloc_type, class... _Properties)
     _CCCL_REQUIRES(_CUDA_VSTD::derived_from<__self_t, __iresource<_Alloc_type>>
                    && (_CUDA_VSTD::derived_from<__self_t, __iprop<_Properties>> && ...))
     operator _CUDA_VMR::basic_resource_ref<_Alloc_type, _Properties...>()
     {
       auto& __self = ::cuda::__basic_any_from(*this);
       auto* __vptr = ::cuda::__virtcall<&__get_resource_vptr<__iresource_ref_conversions>>(this);
       auto* __vtag = static_cast<_CUDA_VMR::_Filtered_vtable<_Properties...>*>(nullptr);
       auto __props = ::cuda::experimental::__make_resource_vtable(__basic_any_access::__get_vptr(__self), __vtag);

       return _CUDA_VMR::_Resource_ref_helper::_Construct<_Alloc_type, _Properties...>(
         __basic_any_access::__get_optr(__self),
         static_cast<const _CUDA_VMR::_Vtable_store<_Alloc_type>*>(__vptr),
         __props);
     }

     template <class _Resource>
     using overrides = __overrides_for<_Resource, &__get_resource_vptr<_Resource>>;
   };

   template <class... _Properties>
   using __iresource _CCCL_NODEBUG_ALIAS =
     ::cuda::__iset<__ibasic_resource<>,
                    __iproperty_set<_Properties...>,
                    __iresource_ref_conversions<>,
                    ::cuda::__icopyable<>,
                    ::cuda::__iequality_comparable<>>;

   template <class... _Properties>
   using __iasync_resource _CCCL_NODEBUG_ALIAS = __iset<__iresource<_Properties...>, __ibasic_async_resource<>>;

   template <class _Property>
   using __try_property_result_t =
     _CUDA_VSTD::conditional_t<!_CUDA_VSTD::is_same_v<__property_result_t<_Property>, void>, //
                               _CUDA_VSTD::optional<__property_result_t<_Property>>, //
                               bool>;

   template <class _Derived>
   struct __with_try_get_property
   {
     template <class _Property>
     [[nodiscard]] _CCCL_HOST_API friend auto try_get_property(const _Derived& __self, _Property) noexcept
       -> __try_property_result_t<_Property>
     {
       auto __prop = ::cuda::__dynamic_any_cast<const __iproperty<_Property>*>(&__self);
       if constexpr (_CUDA_VSTD::is_same_v<__property_result_t<_Property>, void>)
       {
         return __prop != nullptr;
       }
       else if (__prop)
       {
         return get_property(*__prop, _Property{});
       }
       else
       {
         return _CUDA_VSTD::nullopt;
       }
     }
   };

   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES any_resource;

   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES resource_ref;

   // `any_synchronous_resource` wraps any given resource that satisfies the required
   // properties. It owns the contained resource, taking care of construction /
   // destruction. This makes it especially suited for use in e.g. container types
   // that need to ensure that the lifetime of the container exceeds the lifetime
   // of the memory resource used to allocate the storage
   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES any_synchronous_resource
       : __basic_any<__iresource<_Properties...>>
       , __with_try_get_property<any_synchronous_resource<_Properties...>>
   {
     // Inherit constructors from __basic_any
     _LIBCUDACXX_DELEGATE_CONSTRUCTORS(
       any_synchronous_resource, ::cuda::__basic_any, experimental::__iresource<_Properties...>);

     // any_resource is convertible to any_synchronous_resource
     _CCCL_TEMPLATE(class... _OtherProperties)
     _CCCL_REQUIRES((_CUDA_VSTD::__type_set_contains_v<_CUDA_VSTD::__type_set<_OtherProperties...>, _Properties...>) )
     any_synchronous_resource(experimental::any_resource<_OtherProperties...> __other) noexcept
         : __base(_CUDA_VSTD::move(__other.__get_base()))
     {}

     using default_queries = properties_list<_Properties...>;

   private:
     static_assert(_CUDA_VMR::__contains_execution_space_property<_Properties...>,
                   "The properties of cuda::experimental::any_synchronous_resource must contain at least one execution "
                   "space "
                   "property!");
     using __base::interface;
   };

   // ``any_resource`` wraps any given resource that satisfies the
   // required properties. It owns the contained resource, taking care of
   // construction / destruction. This makes it especially suited for use in e.g.
   // container types that need to ensure that the lifetime of the container
   // exceeds the lifetime of the memory resource used to allocate the storage
   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES any_resource
       : __basic_any<__iasync_resource<_Properties...>>
       , __with_try_get_property<any_resource<_Properties...>>
   {
     // Inherit constructors from __basic_any
     _LIBCUDACXX_DELEGATE_CONSTRUCTORS(any_resource, ::cuda::__basic_any, experimental::__iasync_resource<_Properties...>);

     using default_queries = properties_list<_Properties...>;

   private:
     static_assert(_CUDA_VMR::__contains_execution_space_property<_Properties...>,
                   "The properties of cuda::experimental::any_resource must contain at least one execution space "
                   "property!");

     template <class...>
     friend struct any_synchronous_resource;

     using __base::interface;

     __base& __get_base() noexcept
     {
       return *this;
     }
   };

   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES synchronous_resource_ref
       : __basic_any<__iresource<_Properties...>&>
       , __with_try_get_property<synchronous_resource_ref<_Properties...>>
   {
     // Inherit constructors from __basic_any
     _LIBCUDACXX_DELEGATE_CONSTRUCTORS(
       synchronous_resource_ref, ::cuda::__basic_any, experimental::__iresource<_Properties...>&);

     // resource_ref is convertible to synchronous_resource_ref
     _CCCL_TEMPLATE(class... _OtherProperties)
     _CCCL_REQUIRES((_CUDA_VSTD::__type_set_contains_v<_CUDA_VSTD::__type_set<_OtherProperties...>, _Properties...>) )
     synchronous_resource_ref(experimental::resource_ref<_OtherProperties...> __other) noexcept
         : __base(__other.__get_base())
     {}

     // Conversions from the synchronous_resource_ref types in cuda::mr is not supported.
     template <class... _OtherProperties>
     synchronous_resource_ref(_CUDA_VMR::synchronous_resource_ref<_OtherProperties...>) = delete;

     template <class... _OtherProperties>
     synchronous_resource_ref(_CUDA_VMR::resource_ref<_OtherProperties...>) = delete;

     using default_queries = properties_list<_Properties...>;

   private:
     static_assert(_CUDA_VMR::__contains_execution_space_property<_Properties...>,
                   "The properties of cuda::experimental::synchronous_resource_ref must contain at least one execution "
                   "space "
                   "property!");
     using __base::interface;
   };

   template <class... _Properties>
   struct _CCCL_DECLSPEC_EMPTY_BASES resource_ref
       : __basic_any<__iasync_resource<_Properties...>&>
       , __with_try_get_property<resource_ref<_Properties...>>
   {
     // Conversions from the synchronous_resource_ref types in cuda::mr is not supported.
     template <class... _OtherProperties>
     resource_ref(_CUDA_VMR::resource_ref<_OtherProperties...>) = delete;

     // Inherit other constructors from __basic_any
     _LIBCUDACXX_DELEGATE_CONSTRUCTORS(resource_ref, ::cuda::__basic_any, experimental::__iasync_resource<_Properties...>&);

     using default_queries = properties_list<_Properties...>;

   private:
     static_assert(_CUDA_VMR::__contains_execution_space_property<_Properties...>,
                   "The properties of cuda::experimental::resource_ref must contain at least one execution space "
                   "property!");

     template <class...>
     friend struct synchronous_resource_ref;

     using __base::interface;

     __base& __get_base() noexcept
     {
       return *this;
     }
   };

   _CCCL_TEMPLATE(class... _Properties, class _Resource)
   _CCCL_REQUIRES(mr::synchronous_resource_with<_Resource, _Properties...>)
   synchronous_resource_ref<_Properties...> __as_resource_ref(_Resource& __mr) noexcept
   {
     return synchronous_resource_ref<_Properties...>(__mr);
   }

   template <class... _Properties>
   synchronous_resource_ref<_Properties...> __as_resource_ref(synchronous_resource_ref<_Properties...> const __mr) noexcept
   {
     return __mr;
   }

   template <class... _Properties>
   synchronous_resource_ref<_Properties...> __as_resource_ref(resource_ref<_Properties...> const __mr) noexcept
   {
     return __mr;
   }

   template <class... _Properties, mr::_AllocType _Alloc_type>
   mr::synchronous_resource_ref<_Properties...>
   __as_resource_ref(mr::basic_resource_ref<_Alloc_type, _Properties...> const __mr) noexcept
   {
     return __mr;
   }

   #else // ^^^ !_CCCL_DOXYGEN_INVOKED ^^^ / vvv _CCCL_DOXYGEN_INVOKED vvv

   enum class _ResourceKind
   {
     _Synchronous,
     _Asynchronous
   };

   template <_ResourceKind _Kind, class... _Properties>
   class basic_any_resource
   {
   public:
     basic_any_resource() noexcept;

     basic_any_resource(basic_any_resource&& __other) noexcept;

     basic_any_resource(const basic_any_resource& __other);

     template <class _Resource>
     basic_any_resource(_Resource __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_any_resource(basic_any_resource<_OtherKind, _OtherProperties...> __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_any_resource(basic_resource_ref<_OtherKind, _OtherProperties...> __res);

     basic_any_resource& operator=(basic_any_resource&& __other) noexcept;

     basic_any_resource& operator=(const basic_any_resource& __other);

     template <class _Resource>
     basic_any_resource& operator=(_Resource __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_any_resource& operator=(basic_any_resource<_OtherKind, _OtherProperties...> __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_any_resource& operator=(basic_resource_ref<_OtherKind, _OtherProperties...> __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     [[nodiscard]] bool operator==(const basic_any_resource<_OtherKind, _OtherProperties...>& __rhs) const;

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     [[nodiscard]] bool operator==(const basic_resource_ref<_OtherKind, _OtherProperties...>& __rhs) const;

     [[nodiscard]] void* allocate_sync(size_t __size, size_t __align = alignof(cuda::std::max_align_t));

     void deallocate_sync(void* __pv, size_t __size, size_t __align = alignof(cuda::std::max_align_t));

     [[nodiscard]] void* allocate(cuda::stream_ref __stream, size_t __size, size_t __align);

     [[nodiscard]] void* allocate(cuda::stream_ref __stream, size_t __size);

     void deallocate(cuda::stream_ref __stream, void* __pv, size_t __size, size_t __align);

     void deallocate(cuda::stream_ref __stream, void* __pv, size_t __size);

     [[nodiscard]] bool has_value() const noexcept;

     void reset() noexcept;

     [[nodiscard]] const cuda::std::type_info& type() const noexcept;

     template <class _Property>
     friend decltype(auto) get_property(const basic_any_resource& __res, _Property __prop) noexcept;

     template <class _Property>
     friend auto try_get_property(const basic_any_resource& __res, _Property __prop) noexcept;
   };

   template <_ResourceKind _Kind, class... _Properties>
   class basic_resource_ref
   {
   public:
     basic_resource_ref(const basic_resource_ref& __other);

     template <class _Resource>
     basic_resource_ref(_Resource& __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_resource_ref(basic_resource_ref<_OtherKind, _OtherProperties...> __res);

     basic_resource_ref& operator=(const basic_resource_ref& __other);

     template <class _Resource>
     basic_resource_ref& operator=(_Resource& __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     basic_resource_ref& operator=(basic_resource_ref<_OtherKind, _OtherProperties...> __res);

     template <_ResourceKind _OtherKind, class... _OtherProperties>
     [[nodiscard]] bool operator==(const basic_resource_ref<_OtherKind, _OtherProperties...>& __rhs) const;

     [[nodiscard]] void* allocate_sync(size_t __size, size_t __align = alignof(cuda::std::max_align_t));

     void deallocate_sync(void* __pv, size_t __size, size_t __align = alignof(cuda::std::max_align_t));

     [[nodiscard]] void* allocate(cuda::stream_ref __stream, size_t __size, size_t __align);

     [[nodiscard]] void* allocate(cuda::stream_ref __stream, size_t __size);

     void deallocate(cuda::stream_ref __stream, void* __pv, size_t __size, size_t __align);

     void deallocate(cuda::stream_ref __stream, void* __pv, size_t __size);

     [[nodiscard]] const cuda::std::type_info& type() const noexcept;

     template <class _Property>
     friend decltype(auto) get_property(const basic_resource_ref& __res, _Property __prop) noexcept;

     template <class _Property>
     friend auto try_get_property(const basic_resource_ref& __res, _Property __prop) noexcept;
   };

   template <class... _Properties>
   using any_synchronous_resource = basic_any_resource<_ResourceKind::_Synchronous, _Properties...>;

   template <class... _Properties>
   using any_resource = basic_any_resource<_ResourceKind::_Asynchronous, _Properties...>;

   template <class... _Properties>
   using synchronous_resource_ref = basic_resource_ref<_ResourceKind::_Synchronous, _Properties...>;

   template <class... _Properties>
   using resource_ref = basic_resource_ref<_ResourceKind::_Asynchronous, _Properties...>;

   #endif // _CCCL_DOXYGEN_INVOKED

   template <class _Resource, class... _Properties, class... _Args>
   auto make_any_synchronous_resource(_Args&&... __args) -> any_synchronous_resource<_Properties...>
   {
     static_assert(_CUDA_VMR::synchronous_resource<_Resource>,
                   "_Resource does not satisfy the cuda::mr::synchronous_resource concept");
     static_assert(_CUDA_VMR::synchronous_resource_with<_Resource, _Properties...>,
                   "The provided _Resource type does not support the requested properties");
     return any_synchronous_resource<_Properties...>{
       _CUDA_VSTD::in_place_type<_Resource>, _CUDA_VSTD::forward<_Args>(__args)...};
   }

   template <class _Resource, class... _Properties, class... _Args>
   auto make_any_resource(_Args&&... __args) -> any_resource<_Properties...>
   {
     static_assert(_CUDA_VMR::resource<_Resource>, "_Resource does not satisfy the cuda::mr::resource concept");
     static_assert(_CUDA_VMR::resource_with<_Resource, _Properties...>,
                   "The provided _Resource type does not support the requested properties");
     return any_resource<_Properties...>{_CUDA_VSTD::in_place_type<_Resource>, _CUDA_VSTD::forward<_Args>(__args)...};
   }

   } // namespace cuda::experimental

   #include <cuda/std/__cccl/epilogue.h>

   #endif // _CUDAX__MEMORY_RESOURCE_ANY_RESOURCE_H

