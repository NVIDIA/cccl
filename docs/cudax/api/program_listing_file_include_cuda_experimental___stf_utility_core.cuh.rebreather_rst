include\/cuda\/experimental\/\_\_stf\/utility\/core.cuh
=======================================================

File members: :ref:`include\/cuda\/experimental\/\_\_stf\/utility\/core.cuh <core_8cuh>`

.. code-block:: c++

   //===----------------------------------------------------------------------===//
   //
   // Part of CUDASTF in CUDA C++ Core Libraries,
   // under the Apache License v2.0 with LLVM Exceptions.
   // See https://llvm.org/LICENSE.txt for license information.
   // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
   // SPDX-FileCopyrightText: Copyright (c) 2022-2024 NVIDIA CORPORATION & AFFILIATES.
   //
   //===----------------------------------------------------------------------===//

   #pragma once

   #include <cuda/__cccl_config>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cuda/experimental/__stf/utility/cuda_attributes.cuh>

   #include <cstddef>
   #include <functional>
   #include <limits>
   #include <memory>
   #include <string>
   #include <tuple>
   #include <type_traits>
   #include <utility>

   namespace cuda::experimental::stf
   {

   // Hack setenv on Windows
   #if _CCCL_COMPILER(MSVC)

   inline int setenv(const char* name, const char* value, int overwrite)
   {
     if (!name || !value || !name[0])
     {
       // Invalid input: name or value is null, or name is an empty string
       return -1;
     }

     // Check if the variable already exists and if overwrite is allowed
     if (!overwrite && ::std::getenv(name) != nullptr)
     {
       return 0; // Variable exists, and we're not allowed to overwrite it
     }

     // Construct the string in the form "NAME=VALUE"
     auto env_var = ::std::string(name) + "=" + value;

     // Use _putenv to set the environment variable in MSVC
     if (_putenv(env_var.c_str()) != 0)
     {
       return -1; // _putenv failed
     }

     return 0; // Success
   }
   #endif

   #ifndef _CCCL_DOXYGEN_INVOKED // FIXME Doxygen is lost with decltype(auto)

   template <typename T>
   _CCCL_HOST_DEVICE constexpr decltype(auto) mv(T&& obj)
   {
     static_assert(::std::is_lvalue_reference_v<T>, "Useless move from rvalue.");
     static_assert(!::std::is_const_v<::std::remove_reference_t<T>>, "Misleading move from const lvalue.");
     return ::std::move(obj);
   }
   #endif // _CCCL_DOXYGEN_INVOKED

   template <typename T>
   auto to_shared(T&& obj)
   {
     return ::std::make_shared<::std::remove_cv_t<::std::remove_reference_t<T>>>(::std::forward<T>(obj));
   }

   template <typename T, typename U>
   _CCCL_HOST_DEVICE auto each(T from, U to)
   {
     using common = ::std::remove_reference_t<decltype(true ? from : to)>;

     class iterator
     {
       common value;

     public:
       _CCCL_HOST_DEVICE iterator(common value)
           : value(mv(value))
       {}

       _CCCL_HOST_DEVICE common operator*() const
       {
         return value;
       }

       _CCCL_HOST_DEVICE iterator& operator++()
       {
         if constexpr (::std::is_enum_v<common>)
         {
           value = static_cast<T>(static_cast<::std::underlying_type_t<T>>(value) + 1);
         }
         else
         {
           ++value;
         }
         return *this;
       }

       _CCCL_HOST_DEVICE bool operator!=(const iterator& other) const
       {
         return value != other.value;
       }
     };

     class each_t
     {
       common begin_, end_;

     public:
       _CCCL_HOST_DEVICE each_t(T begin, U end)
           : begin_(mv(begin))
           , end_(mv(end))
       {}
       _CCCL_HOST_DEVICE iterator begin() const
       {
         return iterator(begin_);
       }
       _CCCL_HOST_DEVICE iterator end() const
       {
         return iterator(end_);
       }
     };

     return each_t{mv(from), mv(to)};
   }

   template <typename T>
   auto each(T to)
   {
     static_assert(!::std::is_pointer_v<T>, "Use the two arguments version of each() with pointers.");
     if constexpr (::std::is_signed_v<T>)
     {
       _CCCL_ASSERT(to >= 0, "Attempt to iterate from 0 to a negative value.");
     }
     return each(T(0), mv(to));
   }

   template <size_t n, typename F, size_t... i>
   constexpr void unroll(F&& f, ::std::index_sequence<i...> = {})
   {
     if constexpr (sizeof...(i) != n)
     {
       return unroll<n>(::std::forward<F>(f), ::std::make_index_sequence<n>());
     }
     else
     {
       using result_t = decltype(f(::std::integral_constant<size_t, 0>()));
       if constexpr (::std::is_same_v<result_t, void>)
       {
         (f(::std::integral_constant<size_t, i>()), ...);
       }
       else
       {
         (f(::std::integral_constant<size_t, i>()) && ...);
       }
     }
   }

   template <typename T, typename... P>
   constexpr auto tuple_prepend(T&& prefix, ::std::tuple<P...> tuple)
   {
     return ::std::apply(
       [&](auto&&... p) {
         return ::std::tuple(::std::forward<T>(prefix), ::std::forward<decltype(p)>(p)...);
       },
       mv(tuple));
   }

   namespace reserved
   {

   // Like ::std::make_tuple, but skips all values of the same type as `::std::ignore`.
   inline constexpr auto make_tuple()
   {
     return ::std::tuple<>();
   }

   template <typename T, typename... P>
   constexpr auto make_tuple([[maybe_unused]] T t, P... p)
   {
     if constexpr (::std::is_same_v<const T, const decltype(::std::ignore)>)
     {
       // Recurse skipping the first parameter
       return make_tuple(mv(p)...);
     }
     else
     {
       // Keep first parameter, concatenate with recursive call
       return tuple_prepend(mv(t), make_tuple(mv(p)...));
     }
   }

   } // namespace reserved

   template <size_t n, typename F, size_t... i>
   constexpr auto make_tuple_indexwise(F&& f, ::std::index_sequence<i...> = {})
   {
     if constexpr (sizeof...(i) != n)
     {
       return make_tuple_indexwise<n>(::std::forward<F>(f), ::std::make_index_sequence<n>());
     }
     else
     {
       return reserved::make_tuple(f(::std::integral_constant<size_t, i>())...);
     }
   }

   template <typename Tuple, typename F>
   constexpr auto tuple_transform(Tuple&& t, F&& f)
   {
     constexpr size_t n = ::std::tuple_size_v<::std::remove_reference_t<Tuple>>;
     return make_tuple_indexwise<n>([&](auto j) {
       if constexpr (::std::is_invocable_v<F, decltype(j), decltype(::std::get<j>(::std::forward<Tuple>(t)))>)
       {
         return f(j, ::std::get<j>(::std::forward<Tuple>(t)));
       }
       else
       {
         return f(::std::get<j>(::std::forward<Tuple>(t)));
       }
     });
   }

   template <typename Tuple, typename F>
   constexpr void each_in_tuple(Tuple&& t, F&& f)
   {
     constexpr size_t n = ::std::tuple_size_v<::std::remove_reference_t<Tuple>>;
     unroll<n>([&](auto j) {
       if constexpr (::std::is_invocable_v<F, decltype(j), decltype(::std::get<j>(::std::forward<Tuple>(t)))>)
       {
         f(j, ::std::get<j>(::std::forward<Tuple>(t)));
       }
       else
       {
         f(::std::get<j>(::std::forward<Tuple>(t)));
       }
     });
   }

   namespace reserved
   {
   // Implementation of each_in_pack below
   template <typename F, size_t... i, typename... P>
   constexpr void each_in_pack(F&& f, ::std::index_sequence<i...>, P&&... p)
   {
     if constexpr (::std::is_invocable_v<F,
                                         ::std::integral_constant<size_t, 0>,
                                         ::std::tuple_element_t<0, ::std::tuple<P&&...>>>)
     {
       (f(::std::integral_constant<size_t, i>(), ::std::forward<P>(p)), ...);
     }
     else
     {
       (f(::std::forward<P>(p)), ...);
     }
   }
   } // namespace reserved

   template <typename F, typename... P>
   constexpr void each_in_pack(F&& f, P&&... p)
   {
     if constexpr (sizeof...(P) > 0)
     {
       reserved::each_in_pack(::std::forward<F>(f), ::std::make_index_sequence<sizeof...(P)>(), ::std::forward<P>(p)...);
     }
   }

   template <typename E>
   auto as_underlying(E value)
   {
     return static_cast<::std::underlying_type_t<E>>(value);
   }

   template <typename V>
   constexpr V get_reserved_default()
   {
     return ::std::is_floating_point_v<V> ? -::std::numeric_limits<V>::max()
          : ::std::is_unsigned_v<V>
            ? ::std::numeric_limits<V>::max()
            : ::std::numeric_limits<V>::min();
   }

   template <auto V>
   using __copy_type_t = decltype(V);

   template <auto static_v, __copy_type_t<static_v> reserved = get_reserved_default<__copy_type_t<static_v>>()>
   class optionally_static
   {
   public:
     using type = decltype(static_v);

     static constexpr bool is_static = static_v != reserved;

     static constexpr auto reserved_v = reserved;

     constexpr optionally_static() = default;
     constexpr optionally_static(const optionally_static&) = default;
     constexpr optionally_static& operator=(const optionally_static&) = default;

     constexpr optionally_static(type dynamic_value)
         : payload(dynamic_value)
     {}

     constexpr type get() const
     {
       if constexpr (is_static)
       {
         return static_v;
       }
       else
       {
         return payload;
       }
     }

     constexpr operator type() const
     {
       return get();
     }

     constexpr type& get_ref()
     {
       return payload;
     }

     optionally_static& operator++()
     {
       ++get_ref();
       return *this;
     }

     optionally_static operator++(int)
     {
       auto copy = *this;
       ++*this;
       return copy;
     }

     optionally_static& operator--()
     {
       --get_ref();
       return *this;
     }

     optionally_static operator--(int)
     {
       auto copy = *this;
       --*this;
       return copy;
     }

     optionally_static operator+() const
     {
       return *this;
     }

     auto operator-() const
     {
       if constexpr (!is_static)
       {
         return -get();
       }
       else if constexpr (-static_v == reserved)
       {
         /* rare case where we convert a static value into a dynamic one */
         return reserved;
       }
       else
       {
         return optionally_static<-static_v, reserved>();
       }
     }

   private:
     struct nonesuch
     {};
     using state_t                         = ::std::conditional_t<is_static, nonesuch, type>;
     [[no_unique_address]] state_t payload = state_t();
   };

   #ifndef _CCCL_DOXYGEN_INVOKED // Do not document
   // Operator implementations
   #  define _3197bc91feaf98030b2cc0b441d7b0ea(op)                                                          \
       template <auto v1, auto v2, auto r>                                                                  \
       constexpr auto operator op(const optionally_static<v1, r>& lhs, const optionally_static<v2, r>& rhs) \
       {                                                                                                    \
         if constexpr (!std::remove_reference_t<decltype(lhs)>::is_static                                   \
                       || !std::remove_reference_t<decltype(rhs)>::is_static)                               \
         {                                                                                                  \
           return lhs.get() op rhs.get();                                                                   \
         }                                                                                                  \
         else if constexpr ((v1 op v2) == r)                                                                \
         {                                                                                                  \
           /* rare case where we convert two static values into a dynamic one */                            \
           return r;                                                                                        \
         }                                                                                                  \
         else                                                                                               \
         {                                                                                                  \
           return optionally_static<(v1 op v2), r>();                                                       \
         }                                                                                                  \
       }                                                                                                    \
       template <auto v, auto r, typename T>                                                                \
       constexpr auto operator op(const optionally_static<v, r>& lhs, const T& rhs)                         \
       {                                                                                                    \
         return lhs.get() op rhs;                                                                           \
       }                                                                                                    \
       template <auto v, auto r, typename T>                                                                \
       constexpr auto operator op(const T& lhs, const optionally_static<v, r>& rhs)                         \
       {                                                                                                    \
         return lhs op rhs.get();                                                                           \
       }                                                                                                    \
       template <auto v2, auto r>                                                                           \
       constexpr auto& operator op##=(optionally_static<r, r>& lhs, const optionally_static<v2, r>& rhs)    \
       {                                                                                                    \
         return lhs.get_ref() op## = rhs.get();                                                             \
       }                                                                                                    \
       template <auto r, typename T>                                                                        \
       constexpr auto& operator op##=(optionally_static<r, r>& lhs, const T & rhs)                          \
       {                                                                                                    \
         return lhs.get_ref() op## = rhs;                                                                   \
       }

   // Implement for the usual operators
   _3197bc91feaf98030b2cc0b441d7b0ea(+);
   _3197bc91feaf98030b2cc0b441d7b0ea(-);
   _3197bc91feaf98030b2cc0b441d7b0ea(*);
   _3197bc91feaf98030b2cc0b441d7b0ea(/);
   _3197bc91feaf98030b2cc0b441d7b0ea(%);
   _3197bc91feaf98030b2cc0b441d7b0ea(&);
   _3197bc91feaf98030b2cc0b441d7b0ea(|);
   _3197bc91feaf98030b2cc0b441d7b0ea(^);
   //_3197bc91feaf98030b2cc0b441d7b0ea(<<);
   //_3197bc91feaf98030b2cc0b441d7b0ea(>>);

   #  undef _3197bc91feaf98030b2cc0b441d7b0ea

   #  define _3197bc91feaf98030b2cc0b441d7b0ea(op)                                                                     \
       template <auto v1, auto v2, auto r>                                                                             \
       constexpr bool operator op(const optionally_static<v1, r>& lhs, const optionally_static<v2, r>& rhs)            \
       {                                                                                                               \
         return lhs.get() op rhs.get();                                                                                \
       }                                                                                                               \
       template <auto v, auto r, typename T, typename = std::enable_if_t<!std::is_same_v<T, optionally_static<v, r>>>> \
       constexpr bool operator op(const optionally_static<v, r>& lhs, const T& rhs)                                    \
       {                                                                                                               \
         return lhs.get() op rhs;                                                                                      \
       }                                                                                                               \
       template <auto v, auto r, typename T, typename = std::enable_if_t<!std::is_same_v<T, optionally_static<v, r>>>> \
       constexpr bool operator op(const T& lhs, const optionally_static<v, r>& rhs)                                    \
       {                                                                                                               \
         return lhs op rhs.get();                                                                                      \
       }

   _3197bc91feaf98030b2cc0b441d7b0ea(==);
   _3197bc91feaf98030b2cc0b441d7b0ea(!=);
   _3197bc91feaf98030b2cc0b441d7b0ea(<);
   _3197bc91feaf98030b2cc0b441d7b0ea(>);
   _3197bc91feaf98030b2cc0b441d7b0ea(<=);
   _3197bc91feaf98030b2cc0b441d7b0ea(>=);

   #  undef _3197bc91feaf98030b2cc0b441d7b0ea

   #endif // _CCCL_DOXYGEN_INVOKED

   } // namespace cuda::experimental::stf

