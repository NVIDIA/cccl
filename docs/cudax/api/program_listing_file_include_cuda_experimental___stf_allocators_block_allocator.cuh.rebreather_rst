include\/cuda\/experimental\/\_\_stf\/allocators\/block\_allocator.cuh
======================================================================

File members: :ref:`include\/cuda\/experimental\/\_\_stf\/allocators\/block\_allocator.cuh <block__allocator_8cuh>`

.. code-block:: c++

   //===----------------------------------------------------------------------===//
   //
   // Part of CUDASTF in CUDA C++ Core Libraries,
   // under the Apache License v2.0 with LLVM Exceptions.
   // See https://llvm.org/LICENSE.txt for license information.
   // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
   // SPDX-FileCopyrightText: Copyright (c) 2022-2024 NVIDIA CORPORATION & AFFILIATES.
   //
   //===----------------------------------------------------------------------===//

   #pragma once

   #include <cuda/__cccl_config>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cuda/experimental/__stf/internal/async_prereq.cuh>
   #include <cuda/experimental/__stf/places/places.cuh>

   #include <mutex>

   namespace cuda::experimental::stf
   {

   class backend_ctx_untyped;

   class block_allocator_interface
   {
   public:
     block_allocator_interface() = default;

     virtual ~block_allocator_interface() = default;

     virtual void*
     allocate(backend_ctx_untyped&, const data_place& memory_node, ::std::ptrdiff_t& s, event_list& prereqs) = 0;

     virtual void
     deallocate(backend_ctx_untyped&, const data_place& memory_node, event_list& prereqs, void* ptr, size_t sz) = 0;

     virtual event_list deinit(backend_ctx_untyped&) = 0;

     virtual ::std::string to_string() const = 0;

     virtual void print_info() const
     {
       const auto s = to_string();
       fprintf(stderr, "No additional info for allocator of kind \"%.*s\".\n", static_cast<int>(s.size()), s.data());
     }
   };

   class block_allocator_untyped
   {
   public:
     template <typename T>
     friend class block_allocator;

     block_allocator_untyped() = default;

     block_allocator_untyped(::std::shared_ptr<block_allocator_interface> ptr)
         : pimpl(mv(ptr))
     {}

     template <typename ctx_t>
     block_allocator_untyped(ctx_t& ctx, ::std::shared_ptr<block_allocator_interface> ptr)
         : pimpl(mv(ptr))
     {
       ctx.attach_allocator(pimpl);
     }

     void* allocate(backend_ctx_untyped& bctx, const data_place& memory_node, ::std::ptrdiff_t& s, event_list& prereqs)
     {
       return pimpl->allocate(bctx, memory_node, s, prereqs);
     }

     void deallocate(backend_ctx_untyped& bctx, const data_place& memory_node, event_list& prereqs, void* ptr, size_t sz)
     {
       return pimpl->deallocate(bctx, memory_node, prereqs, ptr, sz);
     }

     event_list deinit(backend_ctx_untyped& bctx)
     {
       return pimpl->deinit(bctx);
     }

     ::std::string to_string() const
     {
       return pimpl->to_string();
     }

     explicit operator bool() const
     {
       return pimpl != nullptr;
     }

   private:
     ::std::shared_ptr<block_allocator_interface> pimpl;
   };

   template <typename T>
   class block_allocator : public block_allocator_untyped
   {
   public:
     template <typename ctx_t, typename... Args>
     block_allocator(ctx_t& ctx, Args&&... args)
         : block_allocator_untyped(ctx, ::std::make_shared<T>(::std::forward<Args>(args)...))
     {}

     block_allocator(::std::shared_ptr<block_allocator_interface> ptr)
         : block_allocator_untyped(mv(ptr))
     {}
   };

   } // end namespace cuda::experimental::stf

