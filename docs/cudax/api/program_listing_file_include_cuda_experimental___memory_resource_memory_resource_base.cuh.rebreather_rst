include\/cuda\/experimental\/\_\_memory\_resource\/memory\_resource\_base.cuh
=============================================================================

File members: :ref:`include\/cuda\/experimental\/\_\_memory\_resource\/memory\_resource\_base.cuh <memory__resource__base_8cuh>`

.. code-block:: c++

   //===----------------------------------------------------------------------===//
   //
   // Part of CUDA Experimental in CUDA C++ Core Libraries,
   // under the Apache License v2.0 with LLVM Exceptions.
   // See https://llvm.org/LICENSE.txt for license information.
   // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
   // SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES.
   //
   //===----------------------------------------------------------------------===//

   #ifndef _CUDAX__MEMORY_RESOURCE_MEMORY_RESOURCE_BASE
   #define _CUDAX__MEMORY_RESOURCE_MEMORY_RESOURCE_BASE

   #include <cuda/std/detail/__config>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #if _CCCL_CUDA_COMPILER(CLANG)
   #  include <cuda_runtime.h>
   #  include <cuda_runtime_api.h>
   #endif // _CCCL_CUDA_COMPILER(CLANG)

   #include <cuda/__device/device_ref.h>
   #include <cuda/std/__concepts/concept_macros.h>
   #include <cuda/std/__cuda/api_wrapper.h>
   #include <cuda/std/cstddef>
   #include <cuda/stream_ref>

   #include <cuda/experimental/__memory_resource/any_resource.cuh>
   #include <cuda/experimental/__memory_resource/memory_pool_base.cuh>
   #include <cuda/experimental/__memory_resource/properties.cuh>
   #include <cuda/experimental/__stream/internal_streams.cuh>
   #include <cuda/experimental/__stream/stream.cuh>

   #include <cuda/std/__cccl/prologue.h>

   namespace cuda::experimental
   {

   class __memory_resource_base
   {
   protected:
     ::cudaMemPool_t __pool_;

     [[nodiscard]] static constexpr bool __is_valid_alignment(const size_t __alignment) noexcept
     {
       return __alignment <= _CUDA_VMR::default_cuda_malloc_alignment
           && (_CUDA_VMR::default_cuda_malloc_alignment % __alignment == 0);
     }

   public:
     __memory_resource_base(_CUDA_VSTD::nullptr_t) = delete;

     explicit __memory_resource_base(::cudaMemPool_t __pool) noexcept
         : __pool_(__pool)
     {}

     [[nodiscard]] void* allocate_sync(const size_t __bytes,
                                       const size_t __alignment = _CUDA_VMR::default_cuda_malloc_alignment)
     {
       if (!__is_valid_alignment(__alignment))
       {
         _CUDA_VSTD_NOVERSION::__throw_invalid_argument(
           "Invalid alignment passed to "
           "__memory_resource_base::allocate_sync.");
       }

       void* __ptr{nullptr};
       _CCCL_TRY_CUDA_API(
         ::cudaMallocFromPoolAsync,
         "__memory_resource_base::allocate_sync failed to allocate with cudaMallocFromPoolAsync",
         &__ptr,
         __bytes,
         __pool_,
         __cccl_allocation_stream().get());
       __cccl_allocation_stream().sync();
       return __ptr;
     }

     void deallocate_sync(
       void* __ptr, const size_t, [[maybe_unused]] const size_t __alignment = _CUDA_VMR::default_cuda_malloc_alignment)
     {
       _CCCL_ASSERT(__is_valid_alignment(__alignment),
                    "Invalid alignment passed to __memory_resource_base::deallocate_sync.");
       _CCCL_ASSERT_CUDA_API(
         ::cudaFreeAsync, "__memory_resource_base::deallocate_sync failed", __ptr, __cccl_allocation_stream().get());
       __cccl_allocation_stream().sync();
     }

     [[nodiscard]] void* allocate(const ::cuda::stream_ref __stream, const size_t __bytes, const size_t __alignment)
     {
       if (!__is_valid_alignment(__alignment))
       {
         _CUDA_VSTD_NOVERSION::__throw_invalid_argument(
           "Invalid alignment passed to "
           "__memory_resource_base::allocate.");
       }

       return allocate(__stream, __bytes);
     }

     [[nodiscard]] void* allocate(const ::cuda::stream_ref __stream, const size_t __bytes)
     {
       void* __ptr{nullptr};
       _CCCL_TRY_CUDA_API(
         ::cudaMallocFromPoolAsync,
         "__memory_resource_base::allocate failed to allocate with cudaMallocFromPoolAsync",
         &__ptr,
         __bytes,
         __pool_,
         __stream.get());
       return __ptr;
     }

     void deallocate(
       [[maybe_unused]] const ::cuda::stream_ref __stream, void* __ptr, const size_t __bytes, const size_t __alignment)
     {
       // We need to ensure that the provided alignment matches the minimal provided alignment
       _CCCL_ASSERT(__is_valid_alignment(__alignment), "Invalid alignment passed to __memory_resource_base::deallocate.");
       deallocate(__stream, __ptr, __bytes);
     }

     void deallocate(const ::cuda::stream_ref __stream, void* __ptr, size_t)
     {
       _CCCL_ASSERT_CUDA_API(::cudaFreeAsync, "__memory_resource_base::deallocate failed", __ptr, __stream.get());
     }

     void enable_access_from(::cuda::std::span<const device_ref> __devices)
     {
       ::cuda::experimental::__mempool_set_access(
         __pool_, {__devices.data(), __devices.size()}, cudaMemAccessFlagsProtReadWrite);
     }

     void enable_access_from(device_ref __device)
     {
       ::cuda::experimental::__mempool_set_access(__pool_, {&__device, 1}, cudaMemAccessFlagsProtReadWrite);
     }

     void disable_access_from(::cuda::std::span<const device_ref> __devices)
     {
       ::cuda::experimental::__mempool_set_access(
         __pool_, {__devices.data(), __devices.size()}, cudaMemAccessFlagsProtNone);
     }

     void disable_access_from(device_ref __device)
     {
       ::cuda::experimental::__mempool_set_access(__pool_, {&__device, 1}, cudaMemAccessFlagsProtNone);
     }

     [[nodiscard]] bool is_accessible_from(device_ref __device)
     {
       return ::cuda::experimental::__mempool_get_access(__pool_, __device);
     }

     [[nodiscard]] bool operator==(__memory_resource_base const& __rhs) const noexcept
     {
       return __pool_ == __rhs.__pool_;
     }

   #if _CCCL_STD_VER <= 2017
     [[nodiscard]] bool operator!=(__memory_resource_base const& __rhs) const noexcept
     {
       return __pool_ != __rhs.__pool_;
     }
   #endif // _CCCL_STD_VER <= 2017

     [[nodiscard]] constexpr cudaMemPool_t get() const noexcept
     {
       return __pool_;
     }
   };

   } // namespace cuda::experimental

   #include <cuda/std/__cccl/epilogue.h>

   #endif // _CUDAX__MEMORY_RESOURCE_MEMORY_RESOURCE_BASE

