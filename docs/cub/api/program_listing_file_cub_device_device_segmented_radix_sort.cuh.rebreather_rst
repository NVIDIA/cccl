cub\/device\/device\_segmented\_radix\_sort.cuh
===============================================

File members: :ref:`cub\/device\/device\_segmented\_radix\_sort.cuh <device__segmented__radix__sort_8cuh>`

.. code-block:: c++

   /******************************************************************************
    * Copyright (c) 2011, Duane Merrill.  All rights reserved.
    * Copyright (c) 2011-2022, NVIDIA CORPORATION.  All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the NVIDIA CORPORATION nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    * ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    ******************************************************************************/

   #pragma once

   #include <cub/config.cuh>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cub/detail/choose_offset.cuh>
   #include <cub/device/dispatch/dispatch_radix_sort.cuh>

   CUB_NAMESPACE_BEGIN

   struct DeviceSegmentedRadixSort
   {
   private:
     // Name reported for NVTX ranges
     _CCCL_HOST_DEVICE static constexpr auto GetName() -> const char*
     {
       return "cub::DeviceSegmentedRadixSort";
     }

   public:

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchSegmentedRadixSort<
         SortOrder::Ascending,
         KeyT,
         ValueT,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 false,
                                 stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       return DispatchSegmentedRadixSort<
         SortOrder::Ascending,
         KeyT,
         ValueT,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 true,
                                 stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchSegmentedRadixSort<
         SortOrder::Descending,
         KeyT,
         ValueT,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 false,
                                 stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       return DispatchSegmentedRadixSort<
         SortOrder::Descending,
         KeyT,
         ValueT,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 true,
                                 stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       // Null value type
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DispatchSegmentedRadixSort<
         SortOrder::Ascending,
         KeyT,
         NullType,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 false,
                                 stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       // Null value type
       DoubleBuffer<NullType> d_values;

       return DispatchSegmentedRadixSort<
         SortOrder::Ascending,
         KeyT,
         NullType,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 true,
                                 stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DispatchSegmentedRadixSort<
         SortOrder::Descending,
         KeyT,
         NullType,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 false,
                                 stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Signed integer type for global offsets
       using SegmentSizeT = ::cuda::std::int32_t;

       // Null value type
       DoubleBuffer<NullType> d_values;

       return DispatchSegmentedRadixSort<
         SortOrder::Descending,
         KeyT,
         NullType,
         BeginOffsetIteratorT,
         EndOffsetIteratorT,
         SegmentSizeT>::Dispatch(d_temp_storage,
                                 temp_storage_bytes,
                                 d_keys,
                                 d_values,
                                 num_items,
                                 num_segments,
                                 d_begin_offsets,
                                 d_end_offsets,
                                 begin_bit,
                                 end_bit,
                                 true,
                                 stream);
     }

   };

   CUB_NAMESPACE_END

