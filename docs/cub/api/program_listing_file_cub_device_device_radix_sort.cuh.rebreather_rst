cub\/device\/device\_radix\_sort.cuh
====================================

File members: :ref:`cub\/device\/device\_radix\_sort.cuh <device__radix__sort_8cuh>`

.. code-block:: c++

   /******************************************************************************
    * Copyright (c) 2011, Duane Merrill.  All rights reserved.
    * Copyright (c) 2011-2025, NVIDIA CORPORATION.  All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the NVIDIA CORPORATION nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    * ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    ******************************************************************************/

   #pragma once

   #include <cub/config.cuh>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cub/detail/choose_offset.cuh>
   #include <cub/device/dispatch/dispatch_radix_sort.cuh>

   #include <cuda/std/type_traits>

   CUB_NAMESPACE_BEGIN

   struct DeviceRadixSort
   {
   private:
     template <SortOrder Order, typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
       ::cuda::std::false_type,
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       bool is_overwrite_okay,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       NumItemsT num_items,
       DecomposerT decomposer,
       int begin_bit,
       int end_bit,
       cudaStream_t stream);

     template <SortOrder Order, typename KeyT, typename ValueT, typename OffsetT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
       ::cuda::std::true_type,
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       bool is_overwrite_okay,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       OffsetT num_items,
       DecomposerT decomposer,
       int begin_bit,
       int end_bit,
       cudaStream_t stream)
     {
       return DispatchRadixSort<Order, KeyT, ValueT, OffsetT, DecomposerT>::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         static_cast<OffsetT>(num_items),
         begin_bit,
         end_bit,
         is_overwrite_okay,
         stream,
         decomposer);
     }

     template <SortOrder Order, typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
       ::cuda::std::false_type,
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       bool is_overwrite_okay,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       NumItemsT num_items,
       DecomposerT decomposer,
       cudaStream_t stream);

     template <SortOrder Order, typename KeyT, typename ValueT, typename OffsetT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
       ::cuda::std::true_type,
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       bool is_overwrite_okay,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       OffsetT num_items,
       DecomposerT decomposer,
       cudaStream_t stream)
     {
       constexpr int begin_bit = 0;
       const int end_bit       = detail::radix::traits_t<KeyT>::default_end_bit(decomposer);

       return DeviceRadixSort::custom_radix_sort<Order>(
         ::cuda::std::true_type{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         num_items,
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     // Name reported for NVTX ranges
     _CCCL_HOST_DEVICE static constexpr auto GetName() -> const char*
     {
       return "cub::DeviceRadixSort";
     }

   public:

     template <typename KeyT, typename ValueT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       // TODO API that doesn't accept decomposer should also contain a static
       //      assert that the key type is fundamental.

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchRadixSort<SortOrder::Ascending, KeyT, ValueT, OffsetT>::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         static_cast<OffsetT>(num_items),
         begin_bit,
         end_bit,
         is_overwrite_okay,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairs(void* d_temp_storage,
                 size_t& temp_storage_bytes,
                 const KeyT* d_keys_in,
                 KeyT* d_keys_out,
                 const ValueT* d_values_in,
                 ValueT* d_values_out,
                 NumItemsT num_items,
                 DecomposerT decomposer,
                 int begin_bit,
                 int end_bit,
                 cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairs(void* d_temp_storage,
                 size_t& temp_storage_bytes,
                 const KeyT* d_keys_in,
                 KeyT* d_keys_out,
                 const ValueT* d_values_in,
                 ValueT* d_values_out,
                 NumItemsT num_items,
                 DecomposerT decomposer,
                 cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       constexpr bool is_overwrite_okay = true;

       return DispatchRadixSort<SortOrder::Ascending, KeyT, ValueT, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairs(void* d_temp_storage,
                 size_t& temp_storage_bytes,
                 DoubleBuffer<KeyT>& d_keys,
                 DoubleBuffer<ValueT>& d_values,
                 NumItemsT num_items,
                 DecomposerT decomposer,
                 cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairs(void* d_temp_storage,
                 size_t& temp_storage_bytes,
                 DoubleBuffer<KeyT>& d_keys,
                 DoubleBuffer<ValueT>& d_values,
                 NumItemsT num_items,
                 DecomposerT decomposer,
                 int begin_bit,
                 int end_bit,
                 cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchRadixSort<SortOrder::Descending, KeyT, ValueT, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairsDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         const KeyT* d_keys_in,
         KeyT* d_keys_out,
         const ValueT* d_values_in,
         ValueT* d_values_out,
         NumItemsT num_items,
         DecomposerT decomposer,
         int begin_bit,
         int end_bit,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairsDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         const KeyT* d_keys_in,
         KeyT* d_keys_out,
         const ValueT* d_values_in,
         ValueT* d_values_out,
         NumItemsT num_items,
         DecomposerT decomposer,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       constexpr bool is_overwrite_okay = true;

       return DispatchRadixSort<SortOrder::Descending, KeyT, ValueT, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairsDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         DoubleBuffer<KeyT>& d_keys,
         DoubleBuffer<ValueT>& d_values,
         NumItemsT num_items,
         DecomposerT decomposer,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortPairsDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         DoubleBuffer<KeyT>& d_keys,
         DoubleBuffer<ValueT>& d_values,
         NumItemsT num_items,
         DecomposerT decomposer,
         int begin_bit,
         int end_bit,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       // Null value type
       DoubleBuffer<NullType> d_values;

       return DispatchRadixSort<SortOrder::Ascending, KeyT, NullType, OffsetT>::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         static_cast<OffsetT>(num_items),
         begin_bit,
         end_bit,
         is_overwrite_okay,
         stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeys(void* d_temp_storage,
                size_t& temp_storage_bytes,
                const KeyT* d_keys_in,
                KeyT* d_keys_out,
                NumItemsT num_items,
                DecomposerT decomposer,
                int begin_bit,
                int end_bit,
                cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeys(void* d_temp_storage,
                size_t& temp_storage_bytes,
                const KeyT* d_keys_in,
                KeyT* d_keys_out,
                NumItemsT num_items,
                DecomposerT decomposer,
                cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       constexpr bool is_overwrite_okay = true;

       // Null value type
       DoubleBuffer<NullType> d_values;

       return DispatchRadixSort<SortOrder::Ascending, KeyT, NullType, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeys(void* d_temp_storage,
                size_t& temp_storage_bytes,
                DoubleBuffer<KeyT>& d_keys,
                NumItemsT num_items,
                DecomposerT decomposer,
                cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeys(void* d_temp_storage,
                size_t& temp_storage_bytes,
                DoubleBuffer<KeyT>& d_keys,
                NumItemsT num_items,
                DecomposerT decomposer,
                int begin_bit,
                int end_bit,
                cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DispatchRadixSort<SortOrder::Descending, KeyT, NullType, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeysDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         const KeyT* d_keys_in,
         KeyT* d_keys_out,
         NumItemsT num_items,
         DecomposerT decomposer,
         int begin_bit,
         int end_bit,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeysDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         const KeyT* d_keys_in,
         KeyT* d_keys_out,
         NumItemsT num_items,
         DecomposerT decomposer,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       // We cast away const-ness, but will *not* write to these arrays.
       // ``DispatchRadixSort::Dispatch`` will allocate temporary storage and
       // create a new double-buffer internally when the ``is_overwrite_ok`` flag
       // is not set.
       constexpr bool is_overwrite_okay = false;
       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename NumItemsT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       NumItemsT num_items,
       int begin_bit       = 0,
       int end_bit         = sizeof(KeyT) * 8,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // Unsigned integer type for global offsets.
       using OffsetT = detail::choose_offset_t<NumItemsT>;

       constexpr bool is_overwrite_okay = true;

       // Null value type
       DoubleBuffer<NullType> d_values;

       return DispatchRadixSort<SortOrder::Descending, KeyT, NullType, OffsetT>::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeysDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         DoubleBuffer<KeyT>& d_keys,
         NumItemsT num_items,
         DecomposerT decomposer,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         stream);
     }

     template <typename KeyT, typename NumItemsT, typename DecomposerT>
     CUB_RUNTIME_FUNCTION static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<DecomposerT, int>, //
         cudaError_t>
       SortKeysDescending(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         DoubleBuffer<KeyT>& d_keys,
         NumItemsT num_items,
         DecomposerT decomposer,
         int begin_bit,
         int end_bit,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       // unsigned integer type for global offsets
       using offset_t           = detail::choose_offset_t<NumItemsT>;
       using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

       static_assert(decomposer_check_t::value,
                     "DecomposerT must be a callable object returning a tuple of references to "
                     "arithmetic types");

       constexpr bool is_overwrite_okay = true;
       DoubleBuffer<NullType> d_values;

       return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
         decomposer_check_t{},
         d_temp_storage,
         temp_storage_bytes,
         is_overwrite_okay,
         d_keys,
         d_values,
         static_cast<offset_t>(num_items),
         decomposer,
         begin_bit,
         end_bit,
         stream);
     }

   };

   CUB_NAMESPACE_END

