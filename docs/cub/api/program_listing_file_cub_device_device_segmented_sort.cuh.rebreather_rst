cub\/device\/device\_segmented\_sort.cuh
========================================

File members: :ref:`cub\/device\/device\_segmented\_sort.cuh <device__segmented__sort_8cuh>`

.. code-block:: c++

   /******************************************************************************
    * Copyright (c) 2011-2022, NVIDIA CORPORATION.  All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the NVIDIA CORPORATION nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    ******************************************************************************/

   #pragma once

   #include <cub/config.cuh>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cub/detail/choose_offset.cuh>
   #include <cub/device/dispatch/dispatch_segmented_sort.cuh>
   #include <cub/util_namespace.cuh>

   #include <cuda/std/cstdint>

   CUB_NAMESPACE_BEGIN

   struct DeviceSegmentedSort
   {
   private:
     // Name reported for NVTX ranges
     _CCCL_HOST_DEVICE static constexpr auto GetName() -> const char*
     {
       return "cub::DeviceSegmentedSort";
     }

     // Internal version without NVTX range
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = false;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Ascending, KeyT, cub::NullType, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescendingNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = false;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Descending, KeyT, cub::NullType, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<NullType> d_values;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysDescendingNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = true;
       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Ascending, KeyT, cub::NullType, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<NullType> d_values;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysNoNVTX(
         d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescendingNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = true;
       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Descending, KeyT, cub::NullType, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<NullType> d_values;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysDescendingNoNVTX(
         d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysNoNVTX<KeyT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysDescendingNoNVTX<KeyT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysNoNVTX<KeyT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, stream);
     }

     template <typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeysDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysDescendingNoNVTX<KeyT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = false;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Ascending, KeyT, ValueT, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         d_values_in,
         d_values_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescendingNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = false;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Descending, KeyT, ValueT, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
       DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsDescendingNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         d_values_in,
         d_values_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = true;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Ascending, KeyT, ValueT, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescendingNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       constexpr bool is_overwrite_okay = true;

       using OffsetT =
         detail::choose_signed_offset_t<detail::common_iterator_value_t<BeginOffsetIteratorT, EndOffsetIteratorT>>;
       using DispatchT =
         DispatchSegmentedSort<SortOrder::Descending, KeyT, ValueT, OffsetT, BeginOffsetIteratorT, EndOffsetIteratorT>;

       return DispatchT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         is_overwrite_okay,
         stream);
     }

   public:
     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsDescendingNoNVTX(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsNoNVTX<KeyT, ValueT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         d_values_in,
         d_values_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       const KeyT* d_keys_in,
       KeyT* d_keys_out,
       const ValueT* d_values_in,
       ValueT* d_values_out,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsDescendingNoNVTX<KeyT, ValueT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_keys_out,
         d_values_in,
         d_values_out,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsNoNVTX<KeyT, ValueT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

     template <typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortPairsDescending(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       DoubleBuffer<KeyT>& d_keys,
       DoubleBuffer<ValueT>& d_values,
       ::cuda::std::int64_t num_items,
       ::cuda::std::int64_t num_segments,
       BeginOffsetIteratorT d_begin_offsets,
       EndOffsetIteratorT d_end_offsets,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsDescendingNoNVTX<KeyT, ValueT, BeginOffsetIteratorT, EndOffsetIteratorT>(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         d_values,
         num_items,
         num_segments,
         d_begin_offsets,
         d_end_offsets,
         stream);
     }

   };

   CUB_NAMESPACE_END

