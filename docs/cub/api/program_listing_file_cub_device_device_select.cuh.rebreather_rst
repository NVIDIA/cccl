cub\/device\/device\_select.cuh
===============================

File members: :ref:`cub\/device\/device\_select.cuh <device__select_8cuh>`

.. code-block:: c++

   /******************************************************************************
    * Copyright (c) 2011, Duane Merrill.  All rights reserved.
    * Copyright (c) 2011-2022, NVIDIA CORPORATION.  All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the NVIDIA CORPORATION nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    * ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    ******************************************************************************/

   #pragma once

   #include <cub/config.cuh>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cub/detail/choose_offset.cuh>
   #include <cub/device/dispatch/dispatch_select_if.cuh>
   #include <cub/device/dispatch/dispatch_unique_by_key.cuh>

   #include <cuda/std/type_traits>
   CUB_NAMESPACE_BEGIN

   struct DeviceSelect
   {
     template <typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t Flagged(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       InputIteratorT d_in,
       FlagIterator d_flags,
       OutputIteratorT d_out,
       NumSelectedIteratorT d_num_selected_out,
       ::cuda::std::int64_t num_items,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::Flagged");

       using OffsetT    = ::cuda::std::int64_t; // Signed integer type for global offsets
       using SelectOp   = NullType; // Selection op (not used)
       using EqualityOp = NullType; // Equality operator (not used)

       return DispatchSelectIf<
         InputIteratorT,
         FlagIterator,
         OutputIteratorT,
         NumSelectedIteratorT,
         SelectOp,
         EqualityOp,
         OffsetT,
         SelectImpl::Select>::Dispatch(d_temp_storage,
                                       temp_storage_bytes,
                                       d_in,
                                       d_flags,
                                       d_out,
                                       d_num_selected_out,
                                       SelectOp(),
                                       EqualityOp(),
                                       num_items,
                                       stream);
     }

     template <typename IteratorT, typename FlagIterator, typename NumSelectedIteratorT>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t Flagged(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       IteratorT d_data,
       FlagIterator d_flags,
       NumSelectedIteratorT d_num_selected_out,
       ::cuda::std::int64_t num_items,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::Flagged");

       using OffsetT    = ::cuda::std::int64_t; // Signed integer type for global offsets
       using SelectOp   = NullType; // Selection op (not used)
       using EqualityOp = NullType; // Equality operator (not used)

       return DispatchSelectIf<IteratorT,
                               FlagIterator,
                               IteratorT,
                               NumSelectedIteratorT,
                               SelectOp,
                               EqualityOp,
                               OffsetT,
                               SelectImpl::SelectPotentiallyInPlace>::
         Dispatch(
           d_temp_storage,
           temp_storage_bytes,
           d_data, // in
           d_flags,
           d_data, // out
           d_num_selected_out,
           SelectOp(),
           EqualityOp(),
           num_items,
           stream);
     }

     template <typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t
     If(void* d_temp_storage,
        size_t& temp_storage_bytes,
        InputIteratorT d_in,
        OutputIteratorT d_out,
        NumSelectedIteratorT d_num_selected_out,
        ::cuda::std::int64_t num_items,
        SelectOp select_op,
        cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::If");

       using OffsetT      = ::cuda::std::int64_t; // Signed integer type for global offsets
       using FlagIterator = NullType*; // FlagT iterator type (not used)
       using EqualityOp   = NullType; // Equality operator (not used)

       return DispatchSelectIf<
         InputIteratorT,
         FlagIterator,
         OutputIteratorT,
         NumSelectedIteratorT,
         SelectOp,
         EqualityOp,
         OffsetT,
         SelectImpl::Select>::Dispatch(d_temp_storage,
                                       temp_storage_bytes,
                                       d_in,
                                       nullptr,
                                       d_out,
                                       d_num_selected_out,
                                       select_op,
                                       EqualityOp(),
                                       num_items,
                                       stream);
     }

     template <typename IteratorT, typename NumSelectedIteratorT, typename SelectOp>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t
     If(void* d_temp_storage,
        size_t& temp_storage_bytes,
        IteratorT d_data,
        NumSelectedIteratorT d_num_selected_out,
        ::cuda::std::int64_t num_items,
        SelectOp select_op,
        cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::If");

       using OffsetT      = ::cuda::std::int64_t; // Signed integer type for global offsets
       using FlagIterator = NullType*; // FlagT iterator type (not used)
       using EqualityOp   = NullType; // Equality operator (not used)

       return DispatchSelectIf<IteratorT,
                               FlagIterator,
                               IteratorT,
                               NumSelectedIteratorT,
                               SelectOp,
                               EqualityOp,
                               OffsetT,
                               SelectImpl::SelectPotentiallyInPlace>::
         Dispatch(
           d_temp_storage,
           temp_storage_bytes,
           d_data, // in
           nullptr,
           d_data, // out
           d_num_selected_out,
           select_op,
           EqualityOp(),
           num_items,
           stream);
     }

     template <typename InputIteratorT,
               typename FlagIterator,
               typename OutputIteratorT,
               typename NumSelectedIteratorT,
               typename SelectOp>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t FlaggedIf(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       InputIteratorT d_in,
       FlagIterator d_flags,
       OutputIteratorT d_out,
       NumSelectedIteratorT d_num_selected_out,
       ::cuda::std::int64_t num_items,
       SelectOp select_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::FlaggedIf");

       using OffsetT    = ::cuda::std::int64_t; // Signed integer type for global offsets
       using EqualityOp = NullType; // Equality operator (not used)

       return DispatchSelectIf<
         InputIteratorT,
         FlagIterator,
         OutputIteratorT,
         NumSelectedIteratorT,
         SelectOp,
         EqualityOp,
         OffsetT,
         SelectImpl::Select>::Dispatch(d_temp_storage,
                                       temp_storage_bytes,
                                       d_in,
                                       d_flags,
                                       d_out,
                                       d_num_selected_out,
                                       select_op,
                                       EqualityOp(),
                                       num_items,
                                       stream);
     }

     template <typename IteratorT, typename FlagIterator, typename NumSelectedIteratorT, typename SelectOp>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t FlaggedIf(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       IteratorT d_data,
       FlagIterator d_flags,
       NumSelectedIteratorT d_num_selected_out,
       ::cuda::std::int64_t num_items,
       SelectOp select_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::FlaggedIf");

       using OffsetT    = ::cuda::std::int64_t; // Signed integer type for global offsets
       using EqualityOp = NullType; // Equality operator (not used)

       return DispatchSelectIf<IteratorT,
                               FlagIterator,
                               IteratorT,
                               NumSelectedIteratorT,
                               SelectOp,
                               EqualityOp,
                               OffsetT,
                               SelectImpl::SelectPotentiallyInPlace>::
         Dispatch(
           d_temp_storage,
           temp_storage_bytes,
           d_data, // in
           d_flags,
           d_data, // out
           d_num_selected_out,
           select_op,
           EqualityOp(),
           num_items,
           stream);
     }

     template <typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT>
     CUB_RUNTIME_FUNCTION _CCCL_FORCEINLINE static cudaError_t Unique(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       InputIteratorT d_in,
       OutputIteratorT d_out,
       NumSelectedIteratorT d_num_selected_out,
       ::cuda::std::int64_t num_items,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::Unique");

       using OffsetT      = ::cuda::std::int64_t;
       using FlagIterator = NullType*; // FlagT iterator type (not used)
       using SelectOp     = NullType; // Selection op (not used)
       using EqualityOp   = ::cuda::std::equal_to<>; // Default == operator

       return DispatchSelectIf<
         InputIteratorT,
         FlagIterator,
         OutputIteratorT,
         NumSelectedIteratorT,
         SelectOp,
         EqualityOp,
         OffsetT,
         SelectImpl::Select>::Dispatch(d_temp_storage,
                                       temp_storage_bytes,
                                       d_in,
                                       nullptr,
                                       d_out,
                                       d_num_selected_out,
                                       SelectOp(),
                                       EqualityOp(),
                                       num_items,
                                       stream);
     }

     template <typename KeyInputIteratorT,
               typename ValueInputIteratorT,
               typename KeyOutputIteratorT,
               typename ValueOutputIteratorT,
               typename NumSelectedIteratorT,
               typename NumItemsT,
               typename EqualityOpT>
     CUB_RUNTIME_FUNCTION __forceinline__ static //
       ::cuda::std::enable_if_t< //
         !::cuda::std::is_convertible_v<EqualityOpT, cudaStream_t>, //
         cudaError_t>
       UniqueByKey(
         void* d_temp_storage,
         size_t& temp_storage_bytes,
         KeyInputIteratorT d_keys_in,
         ValueInputIteratorT d_values_in,
         KeyOutputIteratorT d_keys_out,
         ValueOutputIteratorT d_values_out,
         NumSelectedIteratorT d_num_selected_out,
         NumItemsT num_items,
         EqualityOpT equality_op,
         cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, "cub::DeviceSelect::UniqueByKey");

       using OffsetT = detail::choose_offset_t<NumItemsT>;

       return DispatchUniqueByKey<
         KeyInputIteratorT,
         ValueInputIteratorT,
         KeyOutputIteratorT,
         ValueOutputIteratorT,
         NumSelectedIteratorT,
         EqualityOpT,
         OffsetT>::Dispatch(d_temp_storage,
                            temp_storage_bytes,
                            d_keys_in,
                            d_values_in,
                            d_keys_out,
                            d_values_out,
                            d_num_selected_out,
                            equality_op,
                            static_cast<OffsetT>(num_items),
                            stream);
     }

     template <typename KeyInputIteratorT,
               typename ValueInputIteratorT,
               typename KeyOutputIteratorT,
               typename ValueOutputIteratorT,
               typename NumSelectedIteratorT,
               typename NumItemsT>
     CUB_RUNTIME_FUNCTION __forceinline__ static cudaError_t UniqueByKey(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyInputIteratorT d_keys_in,
       ValueInputIteratorT d_values_in,
       KeyOutputIteratorT d_keys_out,
       ValueOutputIteratorT d_values_out,
       NumSelectedIteratorT d_num_selected_out,
       NumItemsT num_items,
       cudaStream_t stream = 0)
     {
       return UniqueByKey(
         d_temp_storage,
         temp_storage_bytes,
         d_keys_in,
         d_values_in,
         d_keys_out,
         d_values_out,
         d_num_selected_out,
         num_items,
         ::cuda::std::equal_to<>{},
         stream);
     }
   };

   CUB_NAMESPACE_END

