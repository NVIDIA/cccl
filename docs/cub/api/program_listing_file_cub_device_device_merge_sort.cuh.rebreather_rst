cub\/device\/device\_merge\_sort.cuh
====================================

File members: :ref:`cub\/device\/device\_merge\_sort.cuh <device__merge__sort_8cuh>`

.. code-block:: c++

   /******************************************************************************
    * Copyright (c) 2011-2022, NVIDIA CORPORATION.  All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the NVIDIA CORPORATION nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    ******************************************************************************/

   #pragma once

   #include <cub/config.cuh>

   #if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
   #  pragma GCC system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
   #  pragma clang system_header
   #elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
   #  pragma system_header
   #endif // no system header

   #include <cub/detail/choose_offset.cuh>
   #include <cub/device/dispatch/dispatch_merge_sort.cuh>
   #include <cub/util_namespace.cuh>

   CUB_NAMESPACE_BEGIN

   struct DeviceMergeSort
   {
   private:
     // Name reported for NVTX ranges
     _CCCL_HOST_DEVICE static constexpr auto GetName() -> const char*
     {
       return "cub::DeviceMergeSort";
     }

     // Internal version without NVTX range
     template <typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       ValueIteratorT d_items,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       using ChooseOffsetT = detail::choose_offset_t<OffsetT>;

       using DispatchMergeSortT =
         DispatchMergeSort<KeyIteratorT, ValueIteratorT, KeyIteratorT, ValueIteratorT, ChooseOffsetT, CompareOpT>;

       return DispatchMergeSortT::Dispatch(
         d_temp_storage, temp_storage_bytes, d_keys, d_items, d_keys, d_items, num_items, compare_op, stream);
     }

   public:
     template <typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       ValueIteratorT d_items,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortPairsNoNVTX(d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, stream);
     }

     template <typename KeyInputIteratorT,
               typename ValueInputIteratorT,
               typename KeyIteratorT,
               typename ValueIteratorT,
               typename OffsetT,
               typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortPairsCopy(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyInputIteratorT d_input_keys,
       ValueInputIteratorT d_input_items,
       KeyIteratorT d_output_keys,
       ValueIteratorT d_output_items,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       using ChooseOffsetT = detail::choose_offset_t<OffsetT>;

       using DispatchMergeSortT =
         DispatchMergeSort<KeyInputIteratorT, ValueInputIteratorT, KeyIteratorT, ValueIteratorT, ChooseOffsetT, CompareOpT>;

       return DispatchMergeSortT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_input_keys,
         d_input_items,
         d_output_keys,
         d_output_items,
         num_items,
         compare_op,
         stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       using ChooseOffsetT = detail::choose_offset_t<OffsetT>;

       using DispatchMergeSortT =
         DispatchMergeSort<KeyIteratorT, NullType*, KeyIteratorT, NullType*, ChooseOffsetT, CompareOpT>;

       return DispatchMergeSortT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_keys,
         static_cast<NullType*>(nullptr),
         d_keys,
         static_cast<NullType*>(nullptr),
         num_items,
         compare_op,
         stream);
     }

   public:
     template <typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysNoNVTX(d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, stream);
     }

   private:
     // Internal version without NVTX range
     template <typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysCopyNoNVTX(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyInputIteratorT d_input_keys,
       KeyIteratorT d_output_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       using ChooseOffsetT = detail::choose_offset_t<OffsetT>;

       using DispatchMergeSortT =
         DispatchMergeSort<KeyInputIteratorT, NullType*, KeyIteratorT, NullType*, ChooseOffsetT, CompareOpT>;

       return DispatchMergeSortT::Dispatch(
         d_temp_storage,
         temp_storage_bytes,
         d_input_keys,
         static_cast<NullType*>(nullptr),
         d_output_keys,
         static_cast<NullType*>(nullptr),
         num_items,
         compare_op,
         stream);
     }

   public:
     template <typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t SortKeysCopy(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyInputIteratorT d_input_keys,
       KeyIteratorT d_output_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysCopyNoNVTX(
         d_temp_storage, temp_storage_bytes, d_input_keys, d_output_keys, num_items, compare_op, stream);
     }

     template <typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortPairs(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       ValueIteratorT d_items,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       return SortPairsNoNVTX<KeyIteratorT, ValueIteratorT, OffsetT, CompareOpT>(
         d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, stream);
     }

     template <typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeys(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyIteratorT d_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

       return SortKeysNoNVTX<KeyIteratorT, OffsetT, CompareOpT>(
         d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, stream);
     }

     template <typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT>
     CUB_RUNTIME_FUNCTION static cudaError_t StableSortKeysCopy(
       void* d_temp_storage,
       size_t& temp_storage_bytes,
       KeyInputIteratorT d_input_keys,
       KeyIteratorT d_output_keys,
       OffsetT num_items,
       CompareOpT compare_op,
       cudaStream_t stream = 0)
     {
       _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
       return SortKeysCopyNoNVTX<KeyInputIteratorT, KeyIteratorT, OffsetT, CompareOpT>(
         d_temp_storage, temp_storage_bytes, d_input_keys, d_output_keys, num_items, compare_op, stream);
     }
   };

   CUB_NAMESPACE_END

