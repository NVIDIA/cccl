

<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>cub::BlockScan &#8212; CUDA Core Compute Libraries</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/nvidia-sphinx-theme.css?v=933278ad" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />



    <script src="../../_static/documentation_options.js?v=bbe6ed3a"></script>
    <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=5ceeb459"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'cub/api/classcub_1_1BlockScan';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://NVIDIA.github.io/cccl/nv-versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'unstable';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>

    <link rel="canonical" href="https://NVIDIA.github.io/cccl/cub/api/classcub_1_1BlockScan.html" />
    <link rel="icon" href="../../_static/favicon.png"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="cub::BlockScanRunningPrefixOp" href="structcub_1_1BlockScanRunningPrefixOp.html" />
    <link rel="prev" title="cub::BlockRunLengthDecode" href="classcub_1_1BlockRunLengthDecode.html" />


  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="unstable" />


  </head>

  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>


  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="CUDA Core Compute Libraries - Home"/>
    <img src="../../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark pst-js-only" alt="CUDA Core Compute Libraries - Home"/>
  
  
    <p class="title logo__title">CUDA Core Compute Libraries</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">


<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA/cccl" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="CUDA Core Compute Libraries - Home"/>
    <img src="../../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark pst-js-only" alt="CUDA Core Compute Libraries - Home"/>
  
  
    <p class="title logo__title">CUDA Core Compute Libraries</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">


<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA/cccl" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">



<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../../cpp.html">CUDA C++ Core Libraries</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../../libcudacxx/index.html">libcu++</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../libcudacxx/index.html">Overview</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/setup.html">Setup</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/setup/requirements.html">Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/setup/getting.html">Getting libcu++</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/setup/building_and_testing.html">Building &amp; Testing libcu++</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/releases.html">Releases</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/releases/changelog.html">Changelog</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/releases/versioning.html">Versioning</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/standard_api.html">Standard API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/algorithms_library.html">Algorithms Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/c_library.html">C Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/concepts_library.html">Concepts Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/container_library.html">Container Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/execution_library.html">Execution Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/numerics_library.html">Numerics Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/ranges_library.html">Ranges Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/synchronization_library.html">Synchronization Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/time_library.html">Time Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/type_support.html">Type Support Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/standard_api/utility_library.html">Utility Library</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/extended_api.html">Extended API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/bit.html">Bit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/execution_model.html">Execution model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/exceptions.html">Exception Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/memory_model.html">Memory model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/thread_groups.html">Thread Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/synchronization_primitives.html">Synchronization Primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/asynchronous_operations.html">Asynchronous Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/memory_access_properties.html">Memory access properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/functional.html">Functional</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/iterators.html">Fancy Iterators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/type_traits.html">Type traits</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/vector_tuple_protocol.html">Vector Tuple Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/numeric.html">Numeric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/random.html">Random</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/memory.html">Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/memory_resource.html">Memory Resources</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/math.html">Math</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/mdspan.html">Mdspan</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/tma.html">Tensor Memory Accelerator (TMA)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/warp.html">Warp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/utility.html">Utility</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/extended_api/work_stealing.html">Work stealing</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/runtime.html">Runtime</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/cudart_interactions.html">CUDA Runtime interactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/stream.html">Streams</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/event.html">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/algorithm.html">Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/device.html">Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/hierarchy.html">Hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/launch.html">Launch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/buffer.html">Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/memory_pools.html">Memory Pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/runtime/legacy_resources.html">Legacy resources</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../libcudacxx/ptx_api.html">PTX API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/ptx/examples.html">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/ptx/instructions.html">PTX Instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/ptx/pragmas.html">PTX Pragmas</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../libcudacxx/api/index.html">API reference</a></li>
</ul>
</details></li>
<li class="toctree-l2 current active has-children"><a class="reference internal" href="../index.html">CUB</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../test_overview.html">CUB Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="../benchmarking.html">CUB Benchmarks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tuning.html">CUB Tunings</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../developer_overview.html">CUB Developer Overview</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../developer/thread_level.html">Thread-level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../developer/warp_level.html">Warp-level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../developer/block_scope.html">Block-scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../developer/device_scope.html">Device-scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../developer/nvtx.html">NVTX</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../releases.html">CUB Releases</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../releases/changelog.html">CUB 2.1.0</a></li>


















































</ul>
</details></li>
<li class="toctree-l3 current active has-children"><a class="reference internal" href="../api.html">API documentation</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../api_docs/thread_level.html">Thread-level Primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_docs/warp_wide.html">Warp-Wide “Collective” Primitives</a></li>
<li class="toctree-l4 current active"><a class="reference internal" href="../api_docs/block_wide.html">Block-Wide “Collective” Primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_docs/device_wide.html">Device-Wide Primitives</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="index.html">API reference</a></li>
</ul>
</details></li>










<li class="toctree-l2 has-children"><a class="reference internal" href="../../thrust/index.html">Thrust</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../thrust/index.html">Overview</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../thrust/developer_overview.html">Thrust Developer Overview</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/developer/cmake_options.html">Developer CMake Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/developer/systems.html">Thrust systems</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../thrust/releases.html">Releases</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/releases/changelog.html">Changelog</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/releases/versioning.html">Versioning</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../thrust/release_process.html">Release Process</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../thrust/api.html">API documentation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/algorithms.html">Algorithms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/containers.html">Containers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/function_objects.html">Function Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/iterators.html">Iterators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/memory_management.html">Memory Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/numerics.html">Numerics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/parallel_execution_policies.html">Parallel Execution Policies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/random.html">Random Number Generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/system.html">System</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../thrust/api_docs/utility.html">Utility</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../thrust/api/index.html">API reference</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../cudax/index.html">CUDA Experimental</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cudax/index.html">Overview</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cudax/container.html">Containers library</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/classcuda_1_1experimental_1_1uninitialized__buffer.html">cuda::experimental::uninitialized_buffer</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cudax/memory_resource.html">Memory Resources</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/classcuda_1_1mr_1_1basic__any__resource.html">cuda::mr::basic_any_resource</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/structcuda_1_1memory__pool__properties.html">cuda::memory_pool_properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/structcuda_1_1device__memory__pool.html">cuda::device_memory_pool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/structcuda_1_1pinned__memory__pool.html">cuda::pinned_memory_pool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/structcuda_1_1managed__memory__pool.html">cuda::managed_memory_pool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/classcuda_1_1mr_1_1legacy__pinned__memory__resource.html">cuda::mr::legacy_pinned_memory_resource</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/classcuda_1_1mr_1_1legacy__managed__memory__resource.html">cuda::mr::legacy_managed_memory_resource</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../libcudacxx/api/structcuda_1_1mr_1_1shared__resource.html">cuda::mr::shared_resource</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cudax/graph.html">Graphs library</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1graph.html">cuda::experimental::graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1graph__builder.html">cuda::experimental::graph_builder</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1graph__builder__ref.html">cuda::experimental::graph_builder_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1graph__node__ref.html">cuda::experimental::graph_node_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1stf_1_1graphed__interface__of.html">cuda::experimental::stf::graphed_interface_of</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1stf_1_1graphed__interface__of_3_01mdspan_3_01T_00_01P_8_8_8_01_4_01_4.html">cuda::experimental::stf::graphed_interface_of&lt; mdspan&lt; T, P… &gt; &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1stf_1_1graphed__interface__of_3_01scalar__view_3_01T_01_4_01_4.html">cuda::experimental::stf::graphed_interface_of&lt; scalar_view&lt; T &gt; &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/api/structcuda_1_1experimental_1_1stf_1_1graphed__interface__of_3_01void__interface_01_4.html">cuda::experimental::stf::graphed_interface_of&lt; void_interface &gt;</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cudax/stf.html">CUDASTF</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cudax/stf/custom_data_interface.html">Implementation of the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> class</a></li>





<li class="toctree-l4"><a class="reference internal" href="../../cudax/stf/lower_level_api.html">Lower-level API</a></li>

</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../cudax/api/index.html">API reference</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../../cccl/tma.html">Tensor Memory Accelerator (TMA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cccl/3.0_migration_guide.html">CCCL 2.x ‐ CCCL 3.0 migration guide</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../cccl/development/index.html">CCCL Development Guide</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cccl/development/macro.html">CCCL Internal Macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cccl/development/testing.html">CCCL Testing Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cccl/development/build_and_bisect_tools.html">Build and Bisect Utilities</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cccl/development/visibility.html">Symbol Visibility</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cccl/development/visibility/host_stub_visibility.html">Host Stub Visibility Issue</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cccl/development/visibility/device_kernel_visibility.html">Device Kernel Visibility Issue</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cccl/development/visibility/different_architectures.html">Linking TUs compiled with different architectures</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../cccl/contributing.html">Contributing to the CUDA Core Compute Libraries</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cccl/contributing/code_of_conduct.html">Code of Conduct</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../../cccl/license.html">License</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../python/index.html">CCCL Python Libraries</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../python/setup.html">Setup and Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/compute.html"><code class="docutils literal notranslate"><span class="pre">cuda.compute</span></code>: Parallel Computing Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/coop.html"><code class="docutils literal notranslate"><span class="pre">cuda.coop</span></code>: Cooperative Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python/resources.html">Resources</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../python/api_reference.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../python/compute_api.html"><code class="docutils literal notranslate"><span class="pre">cuda.compute</span></code> API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../python/coop_api.html"><code class="docutils literal notranslate"><span class="pre">cuda.coop</span></code> API Reference</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../cpp.html" class="nav-link">CUDA C++ Core Libraries</a></li>
    
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">CUB</a></li>
    
    
    <li class="breadcrumb-item"><a href="../api.html" class="nav-link">CUB API documentation</a></li>
    
    
    <li class="breadcrumb-item"><a href="../api_docs/block_wide.html" class="nav-link">Block-Wide “Collective” Primitives</a></li>
    
    
    <li class="breadcrumb-item"><a href="block.html" class="nav-link">Block-wide Primitives</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">cub::BlockScan</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="cub-blockscan">
<h1>cub::BlockScan<a class="headerlink" href="#cub-blockscan" title="Link to this heading">#</a></h1>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockDimX</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#_CPPv4N3cub18BlockScanAlgorithmE" title="cub::BlockScanAlgorithm"><span class="n"><span class="pre">BlockScanAlgorithm</span></span></a><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">Algorithm</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#_CPPv4N3cub18BlockScanAlgorithm17BLOCK_SCAN_RAKINGE" title="cub::BLOCK_SCAN_RAKING"><span class="n"><span class="pre">BLOCK_SCAN_RAKING</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockDimY</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockDimZ</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">BlockScan</span></span></span><a class="headerlink" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="Link to this definition">#</a><br /></dt>
<dd><p><p>The BlockScan class provides <a class="reference internal" href="../index.html#collective-primitives"><span class="std std-ref">collective</span></a> methods for computing a parallel prefix
sum/scan of items partitioned across a CUDA thread block.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Given a list of input elements and a binary reduction operator, a
<a class="reference external" href="http://en.wikipedia.org/wiki/Prefix_sum">prefix scan</a> produces an output list where each element is computed
to be the reduction of the elements occurring earlier in the input list. <em>Prefix sum</em> connotes a prefix scan with
the addition operator. The term <em>inclusive indicates</em> that the <em>i</em><sup>th</sup> output reduction incorporates
the <em>i</em><sup>th</sup> input. The term <em>exclusive</em> indicates the <em>i</em><sup>th</sup> input is not incorporated into
the <em>i</em><sup>th</sup> output reduction.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>BlockScan can be optionally specialized by algorithm to accommodate different workload profiles:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#_CPPv4N3cub18BlockScanAlgorithm17BLOCK_SCAN_RAKINGE" title="cub::BLOCK_SCAN_RAKING"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">cub::BLOCK_SCAN_RAKING</span></code></a>:
An efficient (high throughput) “raking reduce-then-scan” prefix scan algorithm.</p></li>
<li><p><a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#_CPPv4N3cub18BlockScanAlgorithm25BLOCK_SCAN_RAKING_MEMOIZEE" title="cub::BLOCK_SCAN_RAKING_MEMOIZE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">cub::BLOCK_SCAN_RAKING_MEMOIZE</span></code></a>:
Similar to cub::BLOCK_SCAN_RAKING, but having higher throughput at the expense of additional
register pressure for intermediate storage.</p></li>
<li><p><a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#_CPPv4N3cub18BlockScanAlgorithm21BLOCK_SCAN_WARP_SCANSE" title="cub::BLOCK_SCAN_WARP_SCANS"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">cub::BLOCK_SCAN_WARP_SCANS</span></code></a>:
A quick (low latency) “tiled warpscans” prefix scan algorithm.</p></li>
</ol>
</li>
</ul>
</section>
<section id="performance-considerations">
<h2>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>Uses special instructions when applicable (e.g., warp <code class="docutils literal notranslate"><span class="pre">SHFL</span></code>)</p></li>
<li><p>Uses synchronization-free communication between warp lanes when applicable</p></li>
<li><p>Invokes a minimal number of minimal block-wide synchronization barriers (only
one or two depending on algorithm selection)</p></li>
<li><p>Incurs zero bank conflicts for most types</p></li>
<li><p>Computation is slightly more efficient (i.e., having lower instruction overhead) for:</p>
<ul>
<li><p>Prefix sum variants (vs. generic scan)</p></li>
<li><p>The number of threads in the block is a multiple of the architecture’s warp size</p></li>
</ul>
</li>
<li><p>See cub::BlockScanAlgorithm for performance details regarding algorithmic alternatives</p></li>
</ul>
</section>
<section id="a-simple-example">
<h2>A Simple Example<a class="headerlink" href="#a-simple-example" title="Link to this heading">#</a></h2>
<p>Every thread in the block uses the BlockScan class by first specializing the BlockScan type, then instantiating an instance with parameters for communication, and finally invoking one or more collective member functions.</p>
<p>The code snippet below illustrates an exclusive prefix sum of 512 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumArrayKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{[1,1,1,1],</span> <span class="pre">[1,1,1,1],</span> <span class="pre">...,</span> <span class="pre">[1,1,1,1]}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{[0,1,2,3],</span> <span class="pre">[4,5,6,7],</span> <span class="pre">...,</span> <span class="pre">[508,509,510,511]}</span></code>.</p>
</section>
<section id="re-using-dynamically-allocating-shared-memory">
<h2>Re-using dynamically allocating shared memory<a class="headerlink" href="#re-using-dynamically-allocating-shared-memory" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">block/example_block_reduce_dyn_smem.cu</span></code> example illustrates usage of dynamically shared memory with
BlockReduce and how to re-purpose the same memory region.
This example can be easily adapted to the storage required by BlockScan.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> – Data type being scanned</p></li>
<li><p><strong>BlockDimX</strong> – The thread block length in threads along the X dimension</p></li>
<li><p><strong>Algorithm</strong> – <strong>[optional]</strong> <a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#namespacecub_1abec44bba36037c547e7e84906d0d23ab"><span class="std std-ref">cub::BlockScanAlgorithm</span></a> enumerator specifying the underlying algorithm to use (default: <a class="reference internal" href="namespacecub_1abec44bba36037c547e7e84906d0d23ab.html#namespacecub_1abec44bba36037c547e7e84906d0d23aba0fa6cac57b7df2f475a67af053b9371c"><span class="std std-ref">cub::BLOCK_SCAN_RAKING</span></a>)</p></li>
<li><p><strong>BlockDimY</strong> – <strong>[optional]</strong> The thread block length in threads along the Y dimension (default: 1)</p></li>
<li><p><strong>BlockDimZ</strong> – <strong>[optional]</strong> The thread block length in threads along the Z dimension (default: 1) </p></li>
</ul>
</dd>
</dl>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-collective-constructors">Collective constructors</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan9BlockScanEv">
<span class="target" id="classcub_1_1BlockScan_1ac743e2d00dbc5e8e30d58435072579f4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">BlockScan</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan9BlockScanEv" title="Link to this definition">#</a><br /></dt>
<dd><p>Collective constructor using a private static allocation of shared memory as temporary storage. </p>
<p><div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan9BlockScanER11TempStorage">
<span class="target" id="classcub_1_1BlockScan_1a3b2afa31709bf024fb9723f7aca3739d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">BlockScan</span></span></span><span class="sig-paren">(</span><em class="sig-param"><a class="reference internal" href="#_CPPv4N3cub9BlockScan11TempStorageE" title="cub::BlockScan::TempStorage"><span class="n"><span class="pre">TempStorage</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">temp_storage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan9BlockScanER11TempStorage" title="Link to this definition">#</a><br /></dt>
<dd><p>Collective constructor using the specified memory allocation as temporary storage. </p>
<p><div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>temp_storage</strong> – <strong>[in]</strong> Reference to memory allocation having layout type <a class="reference internal" href="#structcub_1_1BlockScan_1_1TempStorage"><span class="std std-ref">TempStorage</span></a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-exclusive-prefix-sum-operations">Exclusive prefix sum operations</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1T">
<span class="target" id="classcub_1_1BlockScan_1a01bf806fa935227e1657026b3a5fe7e6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes one input element. The value of 0 is applied as the initial value, and is assigned
to <code class="docutils literal notranslate"><span class="pre">output</span></code> in <em>thread</em><sub>0</sub>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="snippet">
<h2>Snippet<a class="headerlink" href="#snippet" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix sum of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumSingleKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">127</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1TR1T">
<span class="target" id="classcub_1_1BlockScan_1a15c69826f3be0e1177082178ac32c228"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes one input element.
The value of 0 is applied as the initial value, and is assigned to <code class="docutils literal notranslate"><span class="pre">output</span></code> in <em>thread</em><sub>0</sub>.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id1">
<h2>Snippet<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix sum of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumAggregateKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">127</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">128</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan12ExclusiveSumEv1TR1TR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a9dc1af50f40b5800d92fb63c3552fca6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan12ExclusiveSumEv1TR1TR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveSum::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan12ExclusiveSumEv1TR1TR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes one input element.  Instead of using 0 as the block-wide prefix, the call-back functor
<code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by the first warp in the block, and the value returned by
<em>lane</em><sub>0</sub> in that warp is used as the “seed” value that logically prefixes the thread block’s
scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>. The functor will be invoked by the first warp of threads in the block,
however only the return value from <em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id2">
<h2>Snippet<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an exclusive prefix sum over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.  Each tile consists
of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Running prefix</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span>
<span class="w">  </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">  </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">    </span><span class="n">running_total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumSinglePrefixCallbackKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize running total</span>
<span class="w">  </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">    </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">127</span></code>.
The output for the second segment will be <code class="docutils literal notranslate"><span class="pre">128,</span> <span class="pre">129,</span> <span class="pre">...,</span> <span class="pre">255</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-exclusive-prefix-sum-operations-(multiple-data-per-thread)">Exclusive prefix sum operations (multiple data per thread)</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a39825e0f45dd4e5dcdc19b3addd66fa6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.
The value of 0 is applied as the initial value, and is assigned to <code class="docutils literal notranslate"><span class="pre">output[0]</span></code> in <em>thread</em><sub>0</sub>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id3">
<h2>Snippet<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix sum of 512 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumArrayKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,1,1,1],</span> <span class="pre">[1,1,1,1],</span> <span class="pre">...,</span> <span class="pre">[1,1,1,1]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,1,2,3],</span> <span class="pre">[4,5,6,7],</span> <span class="pre">...,</span> <span class="pre">[508,509,510,511]</span> <span class="pre">}</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1ace3dd687667af03873acd10f6e3561e4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.
The value of 0 is applied as the initial value, and is assigned to <code class="docutils literal notranslate"><span class="pre">output[0]</span></code> in <em>thread</em><sub>0</sub>.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id4">
<h2>Snippet<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix sum of 512 integer items that are partitioned in
a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads where each thread owns
4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumArrayAggregateKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,1,1,1],</span> <span class="pre">[1,1,1,1],</span> <span class="pre">...,</span> <span class="pre">[1,1,1,1]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,1,2,3],</span> <span class="pre">[4,5,6,7],</span> <span class="pre">...,</span> <span class="pre">[508,509,510,511]</span> <span class="pre">}</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">512</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1aabb662bb840f7014dad2b143c8357968"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveSum::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.
Instead of using 0 as the block-wide prefix, the call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by
the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the “seed”
value that logically prefixes the thread block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>This operation assumes the value of obtained by the <code class="docutils literal notranslate"><span class="pre">T</span></code>’s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value “zero” for addition.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>.
The functor will be invoked by the first warp of threads in the block, however only the return value from
<em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id5">
<h2>Snippet<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an exclusive prefix sum over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.  Each tile consists
of 512 integer items that are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a>
across 128 threads where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Running prefix</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span>
<span class="w">  </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">  </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">    </span><span class="n">running_total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveSumPrefixCallbackKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockScan for a 1D block of 128 threads, 4 ints per thread</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoadT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStoreT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScanT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate aliased shared memory for BlockLoad, BlockStore, and BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoadT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">load</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScanT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">scan</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStoreT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">store</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize running total</span>
<span class="w">  </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="n">BlockLoadT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide exclusive prefix sum</span>
<span class="w">    </span><span class="n">BlockScanT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">scan</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">    </span><span class="n">BlockStoreT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">...,</span> <span class="pre">510,</span> <span class="pre">511</span></code>.
The output for the second segment will be <code class="docutils literal notranslate"><span class="pre">512,</span> <span class="pre">513,</span> <span class="pre">514,</span> <span class="pre">515,</span> <span class="pre">...,</span> <span class="pre">1022,</span> <span class="pre">1023</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-exclusive-prefix-scan-operations">Exclusive prefix scan operations</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a20806e3787568ebea79223b2c00b09d2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOp" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id6">
<h2>Snippet<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix max scan of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveScanSingleKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{});</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">-127</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">INT_MIN,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">124,</span> <span class="pre">126</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> <p><p>Initial value to seed the exclusive scan (and is assigned to <cite>output[0]</cite> in <em>thread</em><sub>0</sub>)</p>
</p>
</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOpR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1af9e0ca6b3f7760256b8e56bdedea244d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOpR1T" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOpR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id7">
<h2>Snippet<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix max scan of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveScanAggregateKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">-127</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">INT_MIN,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">124,</span> <span class="pre">126</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">126</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">initial_value</span></code> is not applied to the block-wide aggregate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> <p><p>Initial value to seed the exclusive scan (and is assigned to <code class="docutils literal notranslate"><span class="pre">output[0]</span></code> in <em>thread</em><sub>0</sub>). It is not
taken into account for <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code>.</p>
</p>
</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN3cub9BlockScan13ExclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a4a18d694b47535dbe70d7d7ca9425f0c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I00EN3cub9BlockScan13ExclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I00EN3cub9BlockScan13ExclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3cub9BlockScan13ExclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element. The call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by
the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as
the “seed” value that logically prefixes the thread block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>.
The functor will be invoked by the first warp of threads in the block, however only the return value from
<em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id8">
<h2>Snippet<a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an exclusive prefix max scan over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.
Each tile consists of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Running prefix</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Constructor</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">    </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">        </span><span class="n">running_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initialize running total</span>
<span class="w">    </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">        </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span>
<span class="w">            </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">        </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">4,</span> <span class="pre">-5,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be <code class="docutils literal notranslate"><span class="pre">INT_MIN,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">124,</span> <span class="pre">126</span></code>.
The output for the second segment will be <code class="docutils literal notranslate"><span class="pre">126,</span> <span class="pre">128,</span> <span class="pre">128,</span> <span class="pre">130,</span> <span class="pre">...,</span> <span class="pre">252,</span> <span class="pre">254</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-exclusive-prefix-scan-operations-(multiple-data-per-thread)">Exclusive prefix scan operations (multiple data per thread)</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1afbd1a4ba81a80dcd2216651f4f2c8ba8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id9">
<h2>Snippet<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix max scan of 512 integer
items that are partitioned in a [&lt;em&gt;blocked arrangement&lt;/em&gt;](../index.html#sec5sec3)
across 128 threads where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveScanArrayKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{});</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,-1,2,-3],</span> <span class="pre">[4,-5,6,-7],</span> <span class="pre">...,</span> <span class="pre">[508,-509,510,-511]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[INT_MIN,0,0,2],</span> <span class="pre">[2,4,4,6],</span> <span class="pre">...,</span> <span class="pre">[506,508,508,510]</span> <span class="pre">}</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> <p><p>Initial value to seed the exclusive scan (and is assigned to <cite>output[0]</cite> in <em>thread</em><sub>0</sub>)</p>
</p>
</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a617adefea9978ddd17b9d0b82a4c1e8b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id10">
<h2>Snippet<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an exclusive prefix max scan of 512 integer items that are partitioned in
a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads where each thread owns
4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span>
<span class="w">        </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,-1,2,-3],</span> <span class="pre">[4,-5,6,-7],</span> <span class="pre">...,</span> <span class="pre">[508,-509,510,-511]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[INT_MIN,0,0,2],</span> <span class="pre">[2,4,4,6],</span> <span class="pre">...,</span> <span class="pre">[506,508,508,510]</span> <span class="pre">}</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">510</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">initial_value</span></code> is not applied to the block-wide aggregate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> <p><p>Initial value to seed the exclusive scan (and is assigned to <cite>output[0]</cite> in <em>thread</em><sub>0</sub>). It is not taken
into account for <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code>.</p>
</p>
</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a0bfa48199edc35ed8125eaaf142b05b4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ExclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::ExclusiveScan::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an exclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.
The call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by the first warp in the block, and the value
returned by <em>lane</em><sub>0</sub> in that warp is used as the “seed” value that logically prefixes the thread
block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>. The functor will be invoked by the
first warp of threads in the block, however only the return value from
<em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id11">
<h2>Snippet<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an exclusive prefix max scan over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans. Each tile consists
of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackMaxOp</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Running prefix</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackMaxOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span>
<span class="w">  </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">  </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">    </span><span class="n">running_total</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExclusiveScanPrefixCallbackKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockScan for a 1D block of 128 threads, 4 ints per thread</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoadT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStoreT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScanT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate aliased shared memory for BlockLoad, BlockStore, and BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoadT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">load</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScanT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">scan</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStoreT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">store</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize running total</span>
<span class="w">  </span><span class="n">BlockPrefixCallbackMaxOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="n">BlockLoadT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide exclusive prefix max scan</span>
<span class="w">    </span><span class="n">BlockScanT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">scan</span><span class="p">).</span><span class="n">ExclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">    </span><span class="n">BlockStoreT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">4,</span> <span class="pre">-5,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be
<code class="docutils literal notranslate"><span class="pre">INT_MIN,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">...,</span> <span class="pre">508,</span> <span class="pre">510</span></code>.
The output for the second segment will be
<code class="docutils literal notranslate"><span class="pre">510,</span> <span class="pre">512,</span> <span class="pre">512,</span> <span class="pre">514,</span> <span class="pre">514,</span> <span class="pre">516,</span> <span class="pre">...,</span> <span class="pre">1020,</span> <span class="pre">1022</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-inclusive-prefix-sum-operations">Inclusive prefix sum operations</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan12InclusiveSumE1TR1T">
<span class="target" id="classcub_1_1BlockScan_1ac1186066f7b0d08015687ec5a7b18e3f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan12InclusiveSumE1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+)
as the scan operator. Each thread contributes one input element.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id12">
<h2>Snippet<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix sum of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveSumSingleKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">128</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan12InclusiveSumE1TR1TR1T">
<span class="target" id="classcub_1_1BlockScan_1a1fa90be68fdef67533556dbdbca0e591"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>, <em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3cub9BlockScan12InclusiveSumE1TR1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes one input element.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id13">
<h2>Snippet<a class="headerlink" href="#id13" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix sum of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveSumSingleAggregateKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">128</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">128</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan12InclusiveSumEv1TR1TR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a8c8e5a63a4bacb4eb1e7c54ac47cdb13"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan12InclusiveSumEv1TR1TR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveSum::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan12InclusiveSumEv1TR1TR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes one input element. Instead of using 0 as the block-wide prefix, the call-back functor
<code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by the first warp in the block, and the value returned by
<em>lane</em><sub>0</sub> in that warp is used as the “seed” value that logically prefixes the thread block’s
scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>. The functor will be invoked by the first warp of threads in the block,
however only the return value from <em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id14">
<h2>Snippet<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an inclusive prefix sum over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.
Each tile consists of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Running prefix</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Constructor</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">    </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">        </span><span class="n">running_total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initialize running total</span>
<span class="w">    </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">        </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span>
<span class="w">            </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">        </span><span class="n">d_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">128</span></code>.
The output for the second segment will be <code class="docutils literal notranslate"><span class="pre">129,</span> <span class="pre">130,</span> <span class="pre">...,</span> <span class="pre">256</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied
to the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-inclusive-prefix-sum-operations-(multiple-data-per-thread)">Inclusive prefix sum operations (multiple data per thread)</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a89696dceeb0608a6f7b7171e31dd3bcc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id15">
<h2>Snippet<a class="headerlink" href="#id15" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix sum of 512 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveSumArrayKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,1,1,1],</span> <span class="pre">[1,1,1,1],</span> <span class="pre">...,</span> <span class="pre">[1,1,1,1]</span> <span class="pre">}</span></code>. The corresponding output
<code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,2,3,4],</span> <span class="pre">[5,6,7,8],</span> <span class="pre">...,</span> <span class="pre">[509,510,511,512]</span> <span class="pre">}</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a5515799fd5881c5e860b96156af24a4e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.
Also provides every thread with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id16">
<h2>Snippet<a class="headerlink" href="#id16" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix sum of 512 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveSumArrayAggregateKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,1,1,1],</span> <span class="pre">[1,1,1,1],</span> <span class="pre">...,</span> <span class="pre">[1,1,1,1]</span> <span class="pre">}</span></code>. The
corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[1,2,3,4],</span> <span class="pre">[5,6,7,8],</span> <span class="pre">...,</span> <span class="pre">[509,510,511,512]</span> <span class="pre">}</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">512</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1aa7a159659c26b8bf79799f8d3aae8cfb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveSum</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveSum::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveSum::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using addition (+) as the scan operator.
Each thread contributes an array of consecutive input elements.
Instead of using 0 as the block-wide prefix, the call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by
the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the “seed”
value that logically prefixes the thread block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>. The functor will be invoked by the first warp of threads in the block,
however only the return value from <em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id17">
<h2>Snippet<a class="headerlink" href="#id17" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an inclusive prefix sum over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.  Each tile consists
of 512 integer items that are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a>
across 128 threads where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Running prefix</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span>
<span class="w">  </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">  </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">    </span><span class="n">running_total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveSumPrefixCallbackKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockScan for a 1D block of 128 threads, 4 ints per thread</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoadT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStoreT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScanT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate aliased shared memory for BlockLoad, BlockStore, and BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoadT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">load</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScanT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">scan</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStoreT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">store</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize running total</span>
<span class="w">  </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="n">BlockLoadT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide inclusive prefix sum</span>
<span class="w">    </span><span class="n">BlockScanT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">scan</span><span class="p">).</span><span class="n">InclusiveSum</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">    </span><span class="n">BlockStoreT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be
<code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">...,</span> <span class="pre">511,</span> <span class="pre">512</span></code>. The output for the second segment will be
<code class="docutils literal notranslate"><span class="pre">513,</span> <span class="pre">514,</span> <span class="pre">515,</span> <span class="pre">516,</span> <span class="pre">...,</span> <span class="pre">1023,</span> <span class="pre">1024</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to the
logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-inclusive-prefix-scan-operations">Inclusive prefix scan operations</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a21e49625847b3b52c59668bbf00cc913"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOp" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id18">
<h2>Snippet<a class="headerlink" href="#id18" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 128 integer items that
are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveScanSingleKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix max scan</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{});</span>

<span class="w">  </span><span class="c1">// Store result</span>
<span class="w">  </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">-127</span></code>. The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code>
in those threads will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">126</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a5fb943b8a3677c9df2ccf2dff2d2ccb3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element. Also provides every thread with the block-wide
<code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id19">
<h2>Snippet<a class="headerlink" href="#id19" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 128
integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Obtain input item for each thread</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide inclusive prefix max scan</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">-127</span></code>. The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code>
in those threads will be <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">126</span></code>. Furthermore the value
<code class="docutils literal notranslate"><span class="pre">126</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> Block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a60ad41fc53ed0d0187a8890a51149aeb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">input</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I00EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I00EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes one input element. The call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code>
is invoked by the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as
the “seed” value that logically prefixes the thread block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>. The functor’s input parameter
The functor will be invoked by the first warp of threads in the block,
however only the return value from <em>lane</em><sub>0</sub> is applied
as the block-wide prefix. Can be stateful.</p></li>
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>For multi-dimensional blocks, threads are linearly ranked in row-major order.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id20">
<h2>Snippet<a class="headerlink" href="#id20" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an inclusive prefix max scan over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.  Each tile consists
of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackMaxOp</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Running prefix</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackMaxOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span>
<span class="w">  </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">  </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">    </span><span class="n">running_total</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveScanPrefixCallbackKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockScan for a 1D block of 128 threads, 4 ints per thread</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoadT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStoreT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScanT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate aliased shared memory for BlockLoad, BlockStore, and BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoadT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">load</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScanT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">scan</span><span class="p">;</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStoreT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">store</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize running total</span>
<span class="w">  </span><span class="n">BlockPrefixCallbackMaxOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="n">BlockLoadT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide inclusive prefix max</span>
<span class="w">    </span><span class="n">BlockScanT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">scan</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">    </span><span class="n">BlockStoreT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">4,</span> <span class="pre">-5,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be
<code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">126,</span> <span class="pre">126</span></code>. The output for the second segment
will be <code class="docutils literal notranslate"><span class="pre">128,</span> <span class="pre">128,</span> <span class="pre">130,</span> <span class="pre">130,</span> <span class="pre">...,</span> <span class="pre">254,</span> <span class="pre">254</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input item</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output item (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-inclusive-prefix-scan-operations-(multiple-data-per-thread)">Inclusive prefix scan operations (multiple data per thread)</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1af8c67aacd4f0ac564a6bee10cbfd065a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id21">
<h2>Snippet<a class="headerlink" href="#id21" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 512 integer items that
are partitioned in a [&lt;em&gt;blocked arrangement&lt;/em&gt;](../index.html#sec5sec3) across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveScanArrayKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive prefix max scan</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{});</span>

<span class="w">  </span><span class="c1">// Store results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">d_data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,-1,2,-3],</span> <span class="pre">[4,-5,6,-7],</span> <span class="pre">...,</span> <span class="pre">[508,-509,510,-511]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,0,2,2],</span> <span class="pre">[4,4,6,6],</span> <span class="pre">...,</span> <span class="pre">[508,508,510,510]</span> <span class="pre">}</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1afebc426fa59173cb742459a26c4b8390"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id22">
<h2>Snippet<a class="headerlink" href="#id22" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 128 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 64 threads
where each thread owns 2 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveBlockScanKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 64 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">block_scan_t</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">temp_storage_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_scan_t</span><span class="o">::</span><span class="n">TempStorage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">temp_storage_t</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">initial_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_items_per_thread</span><span class="p">),</span><span class="w"> </span><span class="c1">// item 0</span>
<span class="w">    </span><span class="mi">-1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_items_per_thread</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// item 1</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">//  input: {[0, -1], [2, -3],[4, -5], ... [126, -127]}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive scan max</span>
<span class="w">  </span><span class="n">block_scan_t</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">initial_value</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{});</span>

<span class="w">  </span><span class="c1">// output: {[1, 1], [2, 2],[3, 3], ... [126, 126]}</span>
<span class="w">  </span><span class="c1">// ...</span>
</pre></div>
</div>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> Initial value to seed the inclusive scan (uniform across block)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a81861faf81586f45aaa17f3c4eeb9855"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements. Also provides every thread
with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id23">
<h2>Snippet<a class="headerlink" href="#id23" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 512 integer items that
are partitioned in a [&lt;em&gt;blocked arrangement&lt;/em&gt;](../index.html#sec5sec3) across 128 threads
where each thread owns 4 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for a 1D block of 128 threads of type int</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="c1">// Collectively compute the block-wide inclusive prefix max scan</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>
</pre></div>
</div>
<p>Suppose the set of input <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> across the block of threads is
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,-1,2,-3],</span> <span class="pre">[4,-5,6,-7],</span> <span class="pre">...,</span> <span class="pre">[508,-509,510,-511]</span> <span class="pre">}</span></code>.
The corresponding output <code class="docutils literal notranslate"><span class="pre">thread_data</span></code> in those threads will be
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[0,0,2,2],</span> <span class="pre">[4,4,6,6],</span> <span class="pre">...,</span> <span class="pre">[508,508,510,510]</span> <span class="pre">}</span></code>.
Furthermore the value <code class="docutils literal notranslate"><span class="pre">510</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> Block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a565aa8cc2381e9b9da35f095d779c384"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">initial_value</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_aggregate</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements. Also provides every thread
with the block-wide <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> of all inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id24">
<h2>Snippet<a class="headerlink" href="#id24" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates an inclusive prefix max scan of 128 integer items that
are partitioned in a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> across 64 threads
where each thread owns 2 consecutive items.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">InclusiveBlockScanKernelAggregate</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_block_aggregate</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Specialize BlockScan for a 1D block of 64 threads of type int</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">block_scan_t</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">temp_storage_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_scan_t</span><span class="o">::</span><span class="n">TempStorage</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">temp_storage_t</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">initial_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_items_per_thread</span><span class="p">),</span><span class="w"> </span><span class="c1">// item 0</span>
<span class="w">    </span><span class="mi">-1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num_items_per_thread</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// item 1</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">//  input: {[0, -1], [2, -3],[4, -5], ... [126, -127]}</span>

<span class="w">  </span><span class="c1">// Collectively compute the block-wide inclusive scan max</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">;</span>
<span class="w">  </span><span class="n">block_scan_t</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">initial_value</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// output: {[1, 1], [2, 2],[3, 3], ... [126, 126]}</span>
<span class="w">  </span><span class="c1">// block_aggregate = 126;</span>
<span class="w">  </span><span class="c1">// ...</span>
</pre></div>
</div>
<p>The value <code class="docutils literal notranslate"><span class="pre">126</span></code> will be stored in <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code> for all threads.</p>
</section>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">initial_value</span></code> is not applied to the block-wide aggregate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>initial_value</strong> – <strong>[in]</strong> Initial value to seed the inclusive scan (uniform across block). It is not taken into account for <code class="docutils literal notranslate"><span class="pre">block_aggregate</span></code>.</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_aggregate</strong> – <strong>[out]</strong> Block-wide aggregate reduction of input items </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp">
<span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">ScanOp</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname sig-name-template"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classcub_1_1BlockScan_1a201905c5957baf1b596e287acce212bc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InclusiveScan</span></span></span><span class="sig-paren">(</span>

<dl>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE" title="cub::BlockScan::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::ITEMS_PER_THREAD"><span class="n"><span class="pre">ITEMS_PER_THREAD</span></span></a><span class="p"><span class="pre">]</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::ScanOp"><span class="n"><span class="pre">ScanOp</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">scan_op</span></span></em>,</dd>
<dd><em class="sig-param"><a class="reference internal" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="cub::BlockScan::InclusiveScan::BlockPrefixCallbackOp"><span class="n"><span class="pre">BlockPrefixCallbackOp</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">block_prefix_callback_op</span></span></em></dd>
</dl>

<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp" title="Link to this definition">#</a><br /></dt>
<dd><p><p>Computes an inclusive block-wide prefix scan using the specified binary <code class="docutils literal notranslate"><span class="pre">scan_op</span></code> functor.
Each thread contributes an array of consecutive input elements.
The call-back functor <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> is invoked by the first warp in the block,
and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the “seed” value that logically prefixes the
thread block’s scan inputs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.2.0: </span>First appears in CUDA Toolkit 12.3.</p>
</div>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">block_prefix_callback_op</span></code> functor must implement a member function <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code>.
The functor will be invoked by the first warp of threads in the block, however only the return value
from <em>lane</em><sub>0</sub> is applied as the block-wide prefix. Can be stateful.</p></li>
<li><p>Supports non-commutative scan operators.</p></li>
<li><p>Assumes a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of (<em>block-threads</em> * <em>items-per-thread</em>) items across the thread block, where <em>thread</em><sub>i</sub> owns the <em>i</em><sup>th</sup> range of <em>items-per-thread</em> contiguous items. For multi-dimensional thread blocks, a row-major thread ordering is assumed.</p></li>
<li><p>Efficiency is increased with increased granularity <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code>. Performance is also typically increased until the additional register pressure or shared memory allocation size causes SM occupancy to fall too low. Consider variants of <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> for efficiently gathering a <a class="reference internal" href="../index.html#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.</p></li>
<li><p>A subsequent <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> threadblock barrier should be invoked after calling this method if the collective’s temporary storage (e.g., <code class="docutils literal notranslate"><span class="pre">temp_storage</span></code>) is to be reused or repurposed.</p></li>
</ul>
<section id="id25">
<h2>Snippet<a class="headerlink" href="#id25" title="Link to this heading">#</a></h2>
<p>The code snippet below illustrates a single thread block that progressively
computes an inclusive prefix max scan over multiple “tiles” of input using a
prefix functor to maintain a running total between block-wide scans.  Each tile consists
of 128 integer items that are partitioned across 128 threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="c1">   // or equivalently &lt;cub/block/block_scan.cuh&gt;</span>

<span class="c1">// A stateful callback functor that maintains a running prefix to be applied</span>
<span class="c1">// during consecutive scan operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockPrefixCallbackOp</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Running prefix</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Constructor</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="nf">BlockPrefixCallbackOp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">running_total</span><span class="p">(</span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Callback operator to be entered by the first warp of threads in the block.</span>
<span class="w">    </span><span class="c1">// Thread-0 is responsible for returning a value for seeding the block-wide scan.</span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_aggregate</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="p">;</span>
<span class="w">        </span><span class="n">running_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">block_aggregate</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">old_prefix</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ExampleKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockScan for a 1D block of 128 threads, 4 ints per thread</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="w">  </span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="w">                            </span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allocate aliased shared memory for BlockLoad, BlockStore, and BlockScan</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoad</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">     </span><span class="n">load</span><span class="p">;</span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">     </span><span class="n">scan</span><span class="p">;</span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStore</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">    </span><span class="n">store</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initialize running total</span>
<span class="w">    </span><span class="n">BlockPrefixCallbackOp</span><span class="w"> </span><span class="nf">prefix_op</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Have the block iterate over segments of items</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">;</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Load a segment of consecutive items that are blocked across threads</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="n">BlockLoad</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Collectively compute the block-wide inclusive prefix max scan</span>
<span class="w">        </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">scan</span><span class="p">).</span><span class="n">InclusiveScan</span><span class="p">(</span>
<span class="w">            </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">prefix_op</span><span class="p">);</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Store scanned items to output segment</span>
<span class="w">        </span><span class="n">BlockStore</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span><span class="p">);</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Suppose the input <code class="docutils literal notranslate"><span class="pre">d_data</span></code> is <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">2,</span> <span class="pre">-3,</span> <span class="pre">4,</span> <span class="pre">-5,</span> <span class="pre">...</span></code>.
The corresponding output for the first segment will be
<code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">...,</span> <span class="pre">510,</span> <span class="pre">510</span></code>. The output for the second
segment will be <code class="docutils literal notranslate"><span class="pre">512,</span> <span class="pre">512,</span> <span class="pre">514,</span> <span class="pre">514,</span> <span class="pre">516,</span> <span class="pre">516,</span> <span class="pre">...,</span> <span class="pre">1022,</span> <span class="pre">1022</span></code>.</p>
</section>
</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ITEMS_PER_THREAD</strong> – <strong>[inferred]</strong> The number of consecutive items partitioned onto each thread.</p></li>
<li><p><strong>ScanOp</strong> – <strong>[inferred]</strong> Binary scan functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(const</span> <span class="pre">T</span> <span class="pre">&amp;a,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;b)</span></code></p></li>
<li><p><strong>BlockPrefixCallbackOp</strong> – <strong>[inferred]</strong> Call-back functor type having member <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">operator()(T</span> <span class="pre">block_aggregate)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input</strong> – <strong>[in]</strong> Calling thread’s input items</p></li>
<li><p><strong>output</strong> – <strong>[out]</strong> Calling thread’s output items (may be aliased to <code class="docutils literal notranslate"><span class="pre">input</span></code>)</p></li>
<li><p><strong>scan_op</strong> – <strong>[in]</strong> Binary scan functor</p></li>
<li><p><strong>block_prefix_callback_op</strong> – <strong>[inout]</strong> <p><p><em>warp</em><sub>0</sub> only call-back functor for specifying a block-wide prefix to be applied to
the logical input sequence.</p>
</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv4N3cub9BlockScan11TempStorageE">
<span class="target" id="structcub_1_1BlockScan_1_1TempStorage"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TempStorage</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><span class="n"><span class="pre">Uninitialized</span></span><span class="p"><span class="pre">&lt;</span></span><span class="n"><span class="pre">_TempStorage</span></span><span class="p"><span class="pre">&gt;</span></span><a class="headerlink" href="#_CPPv4N3cub9BlockScan11TempStorageE" title="Link to this definition">#</a><br /></dt>
<dd><p>The operations exposed by <a class="reference internal" href="#classcub_1_1BlockScan"><span class="std std-ref">BlockScan</span></a> require a temporary memory allocation of this nested type for thread communication. This opaque storage can be allocated directly using the <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> keyword. Alternatively, it can be aliased to externally allocated memory (shared or global) or <code class="docutils literal notranslate"><span class="pre">union</span></code>’d with other storage allocation types to facilitate memory reuse. </p>
</dd></dl>

</dd></dl>

</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="classcub_1_1BlockRunLengthDecode.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">cub::BlockRunLengthDecode</p>
      </div>
    </a>
    <a class="right-next"
       href="structcub_1_1BlockScanRunningPrefixOp.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">cub::BlockScanRunningPrefixOp</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            


              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0_i_18BlockScanAlgorithm_i_iEN3cub9BlockScanE"><code class="docutils literal notranslate"><span class="pre">cub::BlockScan</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan9BlockScanEv"><code class="docutils literal notranslate"><span class="pre">BlockScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan9BlockScanER11TempStorage"><code class="docutils literal notranslate"><span class="pre">BlockScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan12ExclusiveSumE1TR1TR1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan12ExclusiveSumEv1TR1TR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_iEN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan12ExclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan13ExclusiveScanEv1TR1T1T6ScanOpR1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I00EN3cub9BlockScan13ExclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i00EN3cub9BlockScan13ExclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">ExclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan12InclusiveSumE1TR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan12InclusiveSumE1TR1TR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan12InclusiveSumEv1TR1TR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_iEN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan12InclusiveSumEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1TR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">InclusiveSum()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOp"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I0EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I00EN3cub9BlockScan13InclusiveScanEv1TR1T6ScanOpR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOp"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOp"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i0EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T1T6ScanOpR1T"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4I_i00EN3cub9BlockScan13InclusiveScanEvRA16ITEMS_PER_THREAD_1TRA16ITEMS_PER_THREAD_1T6ScanOpR21BlockPrefixCallbackOp"><code class="docutils literal notranslate"><span class="pre">InclusiveScan()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#_CPPv4N3cub9BlockScan11TempStorageE"><code class="docutils literal notranslate"><span class="pre">cub::BlockScan::TempStorage</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            

          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  

  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>


  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">




  <p class="copyright">
    
      Copyright © 2026, NVIDIA Corporation.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    <br/>
  </p>
</div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>