//===----------------------------------------------------------------------===//
//
// Part of CUDASTF in CUDA C++ Core Libraries,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2022-2025 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

//! \file
//! \brief Support for conditional nodes in the CUDA graphs generated by stackable_ctx

#pragma once

#include <cuda/__cccl_config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include "cuda/experimental/stf.cuh"

namespace cuda::experimental::stf
{

namespace reserved
{

#if _CCCL_CTK_AT_LEAST(12, 4) && !defined(CUDASTF_DISABLE_CODE_GENERATION) && defined(__CUDACC__)
// This kernel is used by the update_cond method to update the conditional handle. The device function passed as an
// argument returns a boolean value which defines the new value of the conditional handle.
template <typename CondFunc, typename... Args>
__global__ void condition_update_kernel(cudaGraphConditionalHandle conditional_handle, CondFunc cond_func, Args... args)
{
  // Direct call to the user's condition function - no lambda nesting
  bool result = cond_func(args...);
  cudaGraphSetConditional(conditional_handle, result);
}

template <bool value>
__global__ void condition_reset(cudaGraphConditionalHandle conditional_handle)
{
  //  printf("RESET CONDITION to %d\n", !!value);
  cudaGraphSetConditional(conditional_handle, value);
}
#endif // _CCCL_CTK_AT_LEAST(12, 4) && !defined(CUDASTF_DISABLE_CODE_GENERATION) && defined(__CUDACC__)

} // end namespace reserved

//! \brief Configuration class for push_while operations
//!
//! This class encapsulates the parameters needed for conditional graph nodes.
//! When CUDA 12.4+ is not available or code generation is disabled, it becomes effectively empty.
struct push_while_config
{
#if _CCCL_CTK_AT_LEAST(12, 4) && !defined(CUDASTF_DISABLE_CODE_GENERATION) && defined(__CUDACC__)
  cudaGraphConditionalHandle* conditional_handle     = nullptr;
  enum cudaGraphConditionalNodeType conditional_type = cudaGraphCondTypeWhile;
  unsigned int default_launch_value                  = 1;
  unsigned int flags                                 = cudaGraphCondAssignDefault;

  push_while_config() = default;

  push_while_config(cudaGraphConditionalHandle* handle,
                    enum cudaGraphConditionalNodeType type = cudaGraphCondTypeWhile,
                    unsigned int launch_value              = 1,
                    unsigned int condition_flags           = cudaGraphCondAssignDefault)
      : conditional_handle(handle)
      , conditional_type(type)
      , default_launch_value(launch_value)
      , flags(condition_flags)
  {}

#else
  // Empty implementation for pre-CUDA 12.4 or when code generation is disabled
  push_while_config() = default;

  // Constructor that ignores parameters for compatibility
  template <typename... Args>
  push_while_config(Args&&...)
  {}
#endif
};



} // end namespace cuda::experimental::stf
