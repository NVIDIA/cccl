#include <cuda/experimental/compiler.cuh>

#include <testing.cuh>
#include <utility.cuh>

constexpr auto test_cuda_src = R"(
#ifndef MACRO
#  error "NOT defined"
#endif
#ifdef UMACRO
#  error "UMACRO should not be defined"
#endif
template <class T>
__global__ void test_kernel(T* data) {
  *data = VALUE;
}
)";

constexpr auto test_ptx_src = R"(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_52
.address_size 64

	// .globl	_Z11test_kernelPi

.visible .entry _Z11test_kernelPi(
	.param .u64 _Z11test_kernelPi_param_0
)
{
	.reg .b32 	%r<2>;
	.reg .b64 	%rd<3>;


	ld.param.u64 	%rd1, [_Z11test_kernelPi_param_0];
	cvta.to.global.u64 	%rd2, %rd1;
	mov.u32 	%r1, 10;
	st.global.u32 	[%rd2], %r1;
	ret;

}
)";

C2H_TEST("Cuda compiler version", "[cuda.compiler.version]")
{
  STATIC_REQUIRE(cuda::std::is_same_v<int, decltype(cudax::cuda_compiler::version())>);
  [[maybe_unused]] auto version = cudax::cuda_compiler::version();
}

C2H_TEST("Compile cuda to ptx", "[cuda.compile.cuda_to_ptx]")
{
  cudax::cuda_compile_options cuda_opts;
  cuda_opts.add_macro_definition("MACRO");
  cuda_opts.add_macro_definition("VALUE", "10");
  cuda_opts.add_macro_undefinition("UMACRO");
  cuda_opts.add_include_path("/usr/local/cuda/include");
  cuda_opts.add_force_include("force_include.h");
  cuda_opts.set_std_version(cudax::cuda_std_version::cxx17);
  cuda_opts.set_virtual_arch(cuda::arch::id::sm_75);

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  compiler.set_thread_limit(2);
  compiler.enable_internal_cache(false);
  auto result = compiler.compile_to_ptx(src, cuda_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.log();
  }

  [[maybe_unused]] auto ptx          = result.ptx();
  [[maybe_unused]] auto lowered_name = result.lowered_name(name_expr);
}

C2H_TEST("Compile cuda to cubin", "[cuda.compile.cuda_to_cubin]")
{
  cudax::cuda_compile_options cuda_opts;
  cuda_opts.add_macro_definition("MACRO");
  cuda_opts.add_macro_definition("VALUE", "10");
  cuda_opts.add_macro_undefinition("UMACRO");
  cuda_opts.add_include_path("/usr/local/cuda/include");
  cuda_opts.add_force_include("force_include.h");
  cuda_opts.set_std_version(cudax::cuda_std_version::cxx17);
  cuda_opts.set_virtual_arch(cuda::arch::id::sm_75);

  cudax::ptx_compile_options ptx_opts;
  ptx_opts.enable_line_info(true);
  ptx_opts.enable_fmad();
  ptx_opts.set_max_reg_count(32);
  ptx_opts.set_optimization_level(cudax::ptx_optimization_level::O3);
  ptx_opts.set_binary_arch(cuda::arch::id::sm_75);

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  auto result = compiler.compile_to_cubin(src, cuda_opts, ptx_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.log();
  }

  [[maybe_unused]] auto ptx          = result.ptx();
  [[maybe_unused]] auto cubin        = result.cubin();
  [[maybe_unused]] auto lowered_name = result.lowered_name(name_expr);
}

C2H_TEST("Compile cuda to ltoir", "[cuda.compile.cuda_to_ltoir]")
{
  cudax::cuda_compile_options cuda_opts;
  cuda_opts.add_macro_definition("MACRO");
  cuda_opts.add_macro_definition("VALUE", "10");
  cuda_opts.add_macro_undefinition("UMACRO");
  cuda_opts.add_include_path("/usr/local/cuda/include");
  cuda_opts.add_force_include("force_include.h");
  cuda_opts.set_std_version(cudax::cuda_std_version::cxx17);
  cuda_opts.set_virtual_arch(cuda::arch::id::sm_75);

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  auto result = compiler.compile_to_ltoir(src, cuda_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.log();
  }

  [[maybe_unused]] auto ltoir        = result.ltoir();
  [[maybe_unused]] auto lowered_name = result.lowered_name(name_expr);
}

C2H_TEST("PTX compiler version", "[ptx.compiler.version]")
{
  STATIC_REQUIRE(cuda::std::is_same_v<int, decltype(cudax::ptx_compiler::version())>);
  [[maybe_unused]] auto version = cudax::ptx_compiler::version();
}

C2H_TEST("Compile ptx to cubin", "[ptx.compile.ptx_to_cubin]")
{
  cudax::ptx_compile_options ptx_opts;
  ptx_opts.enable_line_info(true);
  ptx_opts.enable_fmad();
  ptx_opts.set_max_reg_count(32);
  ptx_opts.set_optimization_level(cudax::ptx_optimization_level::O3);
  ptx_opts.set_binary_arch(cuda::arch::id::sm_75);

  constexpr auto lowered_name = "_Z11test_kernelPi";

  cudax::ptx_compile_source src{"test.ptx", test_ptx_src};
  src.add_kernel_symbol(lowered_name);

  cudax::ptx_compiler compiler{};
  compiler.set_thread_limit(2);
  auto result = compiler.compile_to_cubin(src, ptx_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.log();
  }

  [[maybe_unused]] auto cubin = result.cubin();
}
