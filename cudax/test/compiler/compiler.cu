#include <cuda/experimental/compiler.cuh>

#include <testing.cuh>
#include <utility.cuh>

constexpr auto test_cuda_src = R"(
#ifndef MACRO
#  error "NOT defined"
#endif
#ifdef UMACRO
#  error "UMACRO should not be defined"
#endif
template <class T>
__global__ void test_kernel(T* data) {
  *data = VALUE;
}
)";

constexpr auto test_ptx_src = R"(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_52
.address_size 64

	// .globl	_Z11test_kernelPi

.visible .entry _Z11test_kernelPi(
	.param .u64 _Z11test_kernelPi_param_0
)
{
	.reg .b32 	%r<2>;
	.reg .b64 	%rd<3>;


	ld.param.u64 	%rd1, [_Z11test_kernelPi_param_0];
	cvta.to.global.u64 	%rd2, %rd1;
	mov.u32 	%r1, 10;
	st.global.u32 	[%rd2], %r1;
	ret;

}
)";

C2H_TEST("Compile cuda to ptx", "[cuda.compile.cuda_to_ptx]")
{
  cudax::cuda_compile_opts cuda_opts;
  {
    using namespace cudax::cuda_compile_options;
    cuda_opts.add_option(define_macro_opt{"MACRO"});
    cuda_opts.add_option(define_macro_opt{"VALUE", "10"});
    cuda_opts.add_option(undefine_macro_opt{"UMACRO"});
    cuda_opts.add_option(include_path_opt{"/usr/local/cuda/include"});
    cuda_opts.add_option(force_include_opt{"force_include.h"});
    cuda_opts.add_option(std_version_opt::cxx17);
  }

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  auto result = compiler.compile_to_ptx(src, cuda_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.get_log();
  }

  [[maybe_unused]] auto ptx          = result.get_ptx();
  [[maybe_unused]] auto lowered_name = result.get_lowered_name(name_expr);
}

C2H_TEST("Compile cuda to cubin", "[cuda.compile.cuda_to_cubin]")
{
  cudax::cuda_compile_opts cuda_opts;
  {
    using namespace cudax::cuda_compile_options;
    cuda_opts.add_option(define_macro_opt{"MACRO"});
    cuda_opts.add_option(define_macro_opt{"VALUE", "10"});
    cuda_opts.add_option(undefine_macro_opt{"UMACRO"});
    cuda_opts.add_option(include_path_opt{"/usr/local/cuda/include"});
    cuda_opts.add_option(force_include_opt{"force_include.h"});
    cuda_opts.add_option(std_version_opt::cxx17);
  }
  cudax::ptx_compile_opts ptx_opts;
  {
    using namespace cudax::ptx_compile_options;
    ptx_opts.add_option(line_info_opt{true});
    ptx_opts.add_option(fmad_opt{true});
    ptx_opts.add_option(max_reg_count_opt{32});
    ptx_opts.add_option(optimization_level_opt{3});
  }

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  auto result = compiler.compile_to_cubin(src, cuda_opts, ptx_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.get_log();
  }

  [[maybe_unused]] auto ptx          = result.get_ptx();
  [[maybe_unused]] auto cubin        = result.get_cubin();
  [[maybe_unused]] auto lowered_name = result.get_lowered_name(name_expr);
}

C2H_TEST("Compile cuda to ltoir", "[cuda.compile.cuda_to_ltoir]")
{
  cudax::cuda_compile_opts cuda_opts;
  {
    using namespace cudax::cuda_compile_options;
    cuda_opts.add_option(define_macro_opt{"MACRO"});
    cuda_opts.add_option(define_macro_opt{"VALUE", "10"});
    cuda_opts.add_option(undefine_macro_opt{"UMACRO"});
    cuda_opts.add_option(include_path_opt{"/usr/local/cuda/include"});
    cuda_opts.add_option(force_include_opt{"force_include.h"});
    cuda_opts.add_option(std_version_opt::cxx17);
  }

  constexpr auto name_expr = "test_kernel<int>";

  cudax::cuda_compile_source src{"test.cu", test_cuda_src};
  src.add_name_expression(name_expr);

  cudax::cuda_compiler compiler{};
  auto result = compiler.compile_to_ltoir(src, cuda_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.get_log();
  }

  [[maybe_unused]] auto ltoir        = result.get_ltoir();
  [[maybe_unused]] auto lowered_name = result.get_lowered_name(name_expr);
}

C2H_TEST("Compile ptx to cubin", "[cuda.compile.ptx_to_cubin]")
{
  cudax::ptx_compile_opts ptx_opts;
  {
    using namespace cudax::ptx_compile_options;
    ptx_opts.add_option(line_info_opt{true});
    ptx_opts.add_option(fmad_opt{true});
    ptx_opts.add_option(max_reg_count_opt{32});
    ptx_opts.add_option(optimization_level_opt{3});
  }

  constexpr auto lowered_name = "_Z11test_kernelPi";

  cudax::ptx_compile_source src{"test.ptx", test_ptx_src};
  src.add_kernel_symbol(lowered_name);

  cudax::ptx_compiler compiler{};
  auto result = compiler.compile_to_cubin(src, ptx_opts);

  if (result)
  {
    [[maybe_unused]] const auto log = result.get_log();
  }

  [[maybe_unused]] auto cubin = result.get_cubin();
}
