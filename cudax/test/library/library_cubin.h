//===----------------------------------------------------------------------===//
//
// Part of CUDA Experimental in CUDA C++ Core Libraries,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#include <cuda/devices>

#include <cstddef>
#include <cstdio>
#include <string>

#include <nvJitLink.h>
#include <nvPTXCompiler.h>
#include <testing.cuh>

// extern "C" __constant__ int const_data;
//
// extern "C" __device__ int global_data;
//
// extern "C" __managed__ int managed_data;
//
// extern "C" __global__ void kernel(int* array, int n)
// {
//   __shared__ int shared[32];
//   int tid = blockDim.x * blockIdx.x + threadIdx.x;
//   if (tid < n)
//   {
//     shared[threadIdx.x] = array[tid];
//     __syncthreads();
//     array[tid] = shared[threadIdx.x + 1 % 32] + const_data;
//   }
// }

std::string make_library_src(bool with_unified_function)
{
  std::string ret{R"(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-32267302
// Cuda compilation tools, release 12.0, V12.0.140
// Based on NVVM 7.0.1
//

.version 8.0
.target )"};

  // unified function requires at least sm90
  ret += (with_unified_function) ? "sm_90" : "sm_75";
  ret += R"(
.address_size 64

	// .globl	kernel
.weak .const .align 4 .u32 const_data;
.weak .global .align 4 .u32 global_data;
.weak .global .attribute(.managed) .align 4 .u32 managed_data;
// _ZZ6kernelE6shared has been demoted

.visible .entry kernel(
	.param .u64 kernel_param_0,
	.param .u32 kernel_param_1
)
{
	.reg .pred 	%p<2>;
	.reg .b32 	%r<13>;
	.reg .b64 	%rd<5>;
	// demoted variable
	.shared .align 4 .b8 _ZZ6kernelE6shared[128];

	ld.param.u64 	%rd1, [kernel_param_0];
	ld.param.u32 	%r3, [kernel_param_1];
	mov.u32 	%r4, %ntid.x;
	mov.u32 	%r5, %ctaid.x;
	mov.u32 	%r1, %tid.x;
	mad.lo.s32 	%r2, %r4, %r5, %r1;
	setp.ge.s32 	%p1, %r2, %r3;
	@%p1 bra 	$L__BB0_2;

	cvta.to.global.u64 	%rd2, %rd1;
	mul.wide.s32 	%rd3, %r2, 4;
	add.s64 	%rd4, %rd2, %rd3;
	ld.global.u32 	%r6, [%rd4];
	shl.b32 	%r7, %r1, 2;
	mov.u32 	%r8, _ZZ6kernelE6shared;
	add.s32 	%r9, %r8, %r7;
	st.shared.u32 	[%r9], %r6;
	bar.sync 	0;
	ld.const.u32 	%r10, [const_data];
	ld.shared.u32 	%r11, [%r9+4];
	add.s32 	%r12, %r10, %r11;
	st.global.u32 	[%rd4], %r12;

$L__BB0_2:
	ret;

}
)";

  // unified function is not generated by the CUDA code
  if (with_unified_function)
  {
    ret += R"(
.visible .func .attribute(.unified(0xAB, 0xCD)) (.param .b32 func_retval0) unified_fn()
{
	.reg .b32 	%r<2>;
	mov.u32 	%r1, 10;
	st.param.b32 	[func_retval0+0], %r1;
	ret;

}
)";
  }
  return ret;
}

inline constexpr char kernel_name[]           = "kernel";
inline constexpr char global_symbol_name[]    = "global_data";
inline constexpr char const_symbol_name[]     = "const_data";
inline constexpr char managed_symbol_name[]   = "managed_data";
inline constexpr char unified_function_name[] = "unified_fn";

#define NVPTXCOMPILER_CALL(...) REQUIRE((__VA_ARGS__ == NVPTXCOMPILE_SUCCESS))
#define NVJITLINK_CALL(...)     REQUIRE((__VA_ARGS__) == NVJITLINK_SUCCESS)

std::string make_library_cubin(cuda::compute_capability cc)
{
  const auto arch_opt = "-arch=sm_" + std::to_string(cc.get());

  const auto src = make_library_src(cc >= cuda::compute_capability{90});

  nvPTXCompilerHandle compiler{};
  NVPTXCOMPILER_CALL(nvPTXCompilerCreate(&compiler, src.size(), src.c_str()));

  const char* const compile_opts[]{arch_opt.c_str(), "-c", "-preserve-relocs"};
  const auto compile_result = nvPTXCompilerCompile(compiler, std::size(compile_opts), compile_opts);

  if (compile_result != NVPTXCOMPILE_SUCCESS)
  {
    std::size_t log_size{};
    NVPTXCOMPILER_CALL(nvPTXCompilerGetErrorLogSize(compiler, &log_size));

    std::string log(log_size, '\0');
    NVPTXCOMPILER_CALL(nvPTXCompilerGetErrorLog(compiler, log.data()));

    // Remove the EOF character at the end of the log.
    log.pop_back();

    std::fputs(log.c_str(), stderr);
    REQUIRE(false);
  }

  std::size_t cubin_size{};
  NVPTXCOMPILER_CALL(nvPTXCompilerGetCompiledProgramSize(compiler, &cubin_size));

  std::string cubin(cubin_size, '\0');
  NVPTXCOMPILER_CALL(nvPTXCompilerGetCompiledProgram(compiler, cubin.data()));

  NVPTXCOMPILER_CALL(nvPTXCompilerDestroy(&compiler));

  nvJitLinkHandle linker{};

  const auto kernel_opt      = std::string{"-kernels-used="} + kernel_name;
  const auto global_var_opt  = std::string{"-variables-used="} + global_symbol_name;
  const auto const_var_opt   = std::string{"-variables-used="} + const_symbol_name;
  const auto managed_var_opt = std::string{"-variables-used="} + managed_symbol_name;
  const char* link_opts[]{
    arch_opt.c_str(), kernel_opt.c_str(), global_var_opt.c_str(), const_var_opt.c_str(), managed_var_opt.c_str()};
  NVJITLINK_CALL(nvJitLinkCreate(&linker, std::size(link_opts), link_opts));

  NVJITLINK_CALL(nvJitLinkAddData(linker, NVJITLINK_INPUT_CUBIN, cubin.c_str(), cubin.size(), "src"));

  const auto link_result = nvJitLinkComplete(linker);

  if (link_result != NVJITLINK_SUCCESS)
  {
    std::size_t log_size{};
    NVJITLINK_CALL(nvJitLinkGetErrorLogSize(linker, &log_size));

    std::string log(log_size, '\0');
    NVJITLINK_CALL(nvJitLinkGetErrorLog(linker, log.data()));

    // Remove the EOF character at the end of the log.
    log.pop_back();

    std::fputs(log.c_str(), stderr);
    REQUIRE(false);
  }

  NVJITLINK_CALL(nvJitLinkGetLinkedCubinSize(linker, &cubin_size));
  cubin.resize(cubin_size);

  NVJITLINK_CALL(nvJitLinkGetLinkedCubin(linker, cubin.data()));

  NVJITLINK_CALL(nvJitLinkDestroy(&linker));

  return cubin;
}
