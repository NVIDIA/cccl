name: "Run Windows Job"
description: "Run a job on a Windows runner."

inputs:
  id:
    description: "A unique identifier."
    required: true
  command:
    description: "The command to run."
    required: true
  image:
    description: "The Docker image to use."
    required: true

runs:
  using: "composite"
  steps:

    # Needed for GPU runners:
    - name: Install Git for Windows
      shell: powershell
      env:
        GFW_EXE_URL: https://github.com/git-for-windows/git/releases/download/v2.49.0.windows.1/PortableGit-2.49.0-64-bit.7z.exe
      run: |
        if ((Get-Command git -ErrorAction SilentlyContinue) -and (Get-Command bash -ErrorAction SilentlyContinue)) {
          Write-Host "Git and Bash are already installed."
          exit 0
        }
        Invoke-WebRequest -Uri "$env:GFW_EXE_URL" -OutFile "PortableGit.7z.exe"
        # Self-extracting, see https://gitforwindows.org/zip-archives-extracting-the-released-archives.html
        Start-Process .\PortableGit.7z.exe -Wait -Verbose -ArgumentList '-y -gm2'
        echo "$((Get-Location).Path)\\PortableGit\\bin" >> $env:GITHUB_PATH
        $env:Path += ";$((Get-Location).Path)\\PortableGit\\bin"
        git --version
        bash --version

    - name: Bootstrap winget if missing
      shell: powershell
      run: |
        if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {
          Write-Host "Bootstrapping WinGet..."
          # https://learn.microsoft.com/en-us/windows/package-manager/winget/
          Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe
          # Re-check availability:
          if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {
            Write-Host "winget still not found after registration"
            exit 1
          }
        }
        Write-Host "winget OK: $(winget --version)"
        # winget source remove --name msstore
        winget source list
        winget source update --disable-interactivity  # --accept-source-agreements --accept-package-agreements
        winget source list

    - name: Ensure Docker CLI installed
      shell: powershell
      run: |
        if (-not (Get-Command docker -ErrorAction SilentlyContinue)) {
          Write-Host "Installing Docker CLI via WinGet..."
          winget install --id Docker.DockerCLI --exact --disable-interactivity --accept-source-agreements --accept-package-agreements
        } else {
          Write-Host "Docker CLI already available."
        }

    - name: Setup docker path if needed
      shell: powershell
      run: |
        if (Get-Command docker -ErrorAction SilentlyContinue) {
          Write-Host "Docker CLI already in path."
          exit 0
        }

        # We expect docker here:
        $dockerPath = "C:\Program Files\Docker\Docker\resources\bin"
        if (-not (Test-Path -Path $dockerPath)) {
          Write-Host "Docker CLI installation failed, path not found: $dockerPath"
          Write-Host "Path: $env:Path"
          Write-Host "Locating docker executables for debugging:"
          $patterns = @('docker*.exe')
          Get-ChildItem -Path 'C:\' -Recurse -Include $patterns -ErrorAction SilentlyContinue |
              Select-Object -ExpandProperty FullName -Unique |
              Sort-Object
          exit 1
        }
        echo "$dockerPath" >> $env:GITHUB_PATH
        $env:Path += ";$dockerPath"

    - name: Test Docker...
      shell: powershell
      run: |
        docker --version
        docker info

#    # Needed for GPU runners:
#    - name: Update PowerShell
#      shell: powershell
#      run: |
#        Write-Host "Detected PowerShell version: $($PSVersionTable.PSVersion)"
#        if ($PSVersionTable.PSVersion.Major -ge 7) {
#          Write-Host "PowerShell 7 or higher is already installed."
#          exit 0
#        }
#        Write-Host "Installing newer PowerShell..."
#        Invoke-WebRequest 'https://github.com/PowerShell/PowerShell/releases/download/v7.5.0/PowerShell-7.5.0-win-x64.msi' -OutFile pwsh7.5.msi
#        Start-Process msiexec.exe -ArgumentList '/i pwsh7.5.msi /passive /norestart' -Wait
#        echo "C:\Program Files\PowerShell\7" >> $env:GITHUB_PATH
#        $env:Path = "C:\Program Files\PowerShell\7;$env:Path"
#        # Create a symlink for powershell to point to pwsh
#        New-Item -ItemType SymbolicLink -Path "C:\Program Files\PowerShell\7\powershell.exe" -Target "C:\Program Files\PowerShell\7\pwsh.exe" -Force
#
#    - name: "Verify PowerShell version"
#      shell: powershell
#      run: |
#        Write-Host "Detected PowerShell version: $($PSVersionTable.PSVersion)"
#
#    - name: Enable Windows Containers feature
#      shell: powershell
#      run: |
#        Enable-WindowsOptionalFeature -Online -FeatureName Containers -All
#
#    - name: Set up Docker
#      uses: docker/setup-docker-action@v4

#    # Needed for GPU runners:
#    - name: Install Docker
#      shell: powershell
#      run: |
#        if ((Get-Command docker -ErrorAction SilentlyContinue)) {
#          Write-Host "Docker is already installed."
#          exit 0
#        }
#        $dockerInstallerUrl = "https://download.docker.com/win/static/stable/x86_64/docker-28.3.3.zip"
#        $dockerZipPath = "$env:TEMP\docker.zip"
#        $dockerInstallPath = "C:\docker"
#
#        Write-Host "Downloading Docker from $dockerInstallerUrl to $dockerZipPath"
#        Invoke-WebRequest -Uri "$dockerInstallerUrl" -OutFile "$dockerZipPath"
#
#        Write-Host "Extracting Docker to $dockerInstallPath"
#        New-Item -ItemType Directory -Path "$dockerInstallPath" | Out-Null
#        tar -C "$dockerInstallPath" --strip-components=1 -xf "$dockerZipPath"
#
#        echo "$dockerInstallPath" >> $env:GITHUB_PATH
#        $env:Path += ";$dockerInstallPath"
#        docker --version
#
#        & dockerd --validate
#        if ($LastExitCode -ne 0) {
#            Write-Error "Failed to validate configuration"
#        }
#        & dockerd --register-service
#        if ($LastExitCode -ne 0) {
#            Write-Error "Failed to register dockerd as a service."
#        }
#
#        Write-Host "Starting docker service"
#        Get-Service "docker"
#        Start-Service "docker"
#
#        Start-Sleep -Seconds 2
#        Write-Host "Checking docker service"
#        Get-Service "docker"
#        & docker info

    - name: Configure env
      shell: bash --noprofile --norc -euo pipefail {0}
      run: |
        echo "SCCACHE_BUCKET=rapids-sccache-devs" | tee -a "${GITHUB_ENV}"
        echo "SCCACHE_REGION=us-east-2" | tee -a "${GITHUB_ENV}"
        echo "SCCACHE_IDLE_TIMEOUT=0" | tee -a "${GITHUB_ENV}"
        echo "SCCACHE_S3_USE_SSL=true" | tee -a "${GITHUB_ENV}"
        echo "SCCACHE_S3_NO_CREDENTIALS=false" | tee -a "${GITHUB_ENV}"
    - name: Get AWS credentials for sccache bucket
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::279114543810:role/gha-oidc-NVIDIA
        aws-region: us-east-2
        role-duration-seconds: 43200 # 12 hours
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        path: ${{github.event.repository.name}}
        persist-credentials: false
    - name: Fetch ${{ inputs.image }}
      shell: bash --noprofile --norc -euo pipefail {0}
      run: docker pull ${{ inputs.image }}
    - name: Prepare paths for docker
      shell: powershell
      id: paths
      run: |
        echo "HOST_REPO=${{ github.workspace }}\${{ github.event.repository.name }}".Replace('\', '/') | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        echo "MOUNT_REPO=C:/${{ github.event.repository.name }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        cat $env:GITHUB_OUTPUT
    - name: Run command # Do not change this step's name, it is checked in parse-job-times.py
      shell: bash --noprofile --norc -euo pipefail {0}
      run: |
        docker run \
          --mount type=bind,source="${{steps.paths.outputs.HOST_REPO}}",target="${{steps.paths.outputs.MOUNT_REPO}}" \
          --workdir "${{steps.paths.outputs.MOUNT_REPO}}" \
          --isolation=process \
          --env COMMAND='& ${{inputs.command}}' \
          ${{ inputs.image }} \
          powershell -c "
            [System.Environment]::SetEnvironmentVariable('AWS_ACCESS_KEY_ID','${{env.AWS_ACCESS_KEY_ID}}');
            [System.Environment]::SetEnvironmentVariable('AWS_SECRET_ACCESS_KEY','${{env.AWS_SECRET_ACCESS_KEY}}');
            [System.Environment]::SetEnvironmentVariable('AWS_SESSION_TOKEN','${{env.AWS_SESSION_TOKEN }}');
            [System.Environment]::SetEnvironmentVariable('SCCACHE_BUCKET','${{env.SCCACHE_BUCKET}}');
            [System.Environment]::SetEnvironmentVariable('SCCACHE_REGION','${{env.SCCACHE_REGION}}');
            [System.Environment]::SetEnvironmentVariable('SCCACHE_IDLE_TIMEOUT','${{env.SCCACHE_IDLE_TIMEOUT}}');
            [System.Environment]::SetEnvironmentVariable('SCCACHE_S3_USE_SSL','${{env.SCCACHE_S3_USE_SSL}}');
            [System.Environment]::SetEnvironmentVariable('SCCACHE_S3_NO_CREDENTIALS','${{env.SCCACHE_S3_NO_CREDENTIALS}}');
            git config --global --add safe.directory '${{steps.paths.outputs.MOUNT_REPO}}';
            Invoke-Expression \$env:COMMAND"
    - name: Prepare job artifacts
      shell: bash --noprofile --norc -euo pipefail {0}
      id: done
      run: |
        echo "SUCCESS=true" | tee -a "${GITHUB_OUTPUT}"

        result_dir="jobs/${{inputs.id}}"
        mkdir -p "$result_dir"

        touch "$result_dir/success"

        # Finds a matching file in the repo directory and copies it to the results directory.
        find_and_copy() {
          filename="$1"
          filepath="$(find ${{github.event.repository.name}} -name "${filename}" -print -quit)"
          if [[ -z "$filepath" ]]; then
            echo "${filename} does not exist in repo directory."
            return 1
          fi
          cp -v "$filepath" "$result_dir"
        }

        find_and_copy "sccache_stats.json" || true # Ignore failures

        echo "::group::Job artifacts"
        find "$result_dir" # Tree not available in this image.
        echo "::endgroup::"

    - name: Upload job artifacts
      uses: actions/upload-artifact@v4
      with:
        name: jobs-${{inputs.id}}
        path: jobs
        compression-level: 0
