# SPDX-FileCopyrightText: Copyright (c) 2024, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: "Release: 3. Create Final Release"

on:
  workflow_dispatch:

defaults:
  run:
    shell: bash --noprofile --norc -euo pipefail {0}

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      rc_tag: ${{ steps.prepare.outputs.rc_tag }}
      release_tag: ${{ steps.prepare.outputs.release_tag }}
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Prepare environment
        id: prepare
        run: |
          log_and_export_vars() {
            for var in "$@"; do
              printf "%-15s %s\n" "$var:" "${!var}" | tee -a $GITHUB_STEP_SUMMARY
              echo "${var}=${!var}" | tee -a $GITHUB_ENV | tee -a $GITHUB_OUTPUT
            done
          }

          # The ref must match a release candidate tag. Parse version info:
          tag_regex="^refs/tags/v([0-9]+)\.([0-9]+)\.([0-9]+)-rc([0-9]+)$"
          if [[ "${GITHUB_REF}" =~ ${tag_regex} ]]; then
            major_version=${BASH_REMATCH[1]}
            minor_version=${BASH_REMATCH[2]}
            patch_version=${BASH_REMATCH[3]}
            rc=${BASH_REMATCH[4]}
          else
            echo "::error::Invalid ref: ${GITHUB_REF}. Must be a release candidate tag (vX.Y.Z-rcN)."
            exit 1
          fi
          full_version="${major_version}.${minor_version}.${patch_version}"
          release_tag="v${full_version}"
          rc_tag="${release_tag}-rc${rc}"

          log_and_export_vars full_version major_version minor_version patch_version rc release_tag rc_tag

          # Ensure that there is no final release tag (vX.Y.Z) for the requested version.
          release_tag_escaped=$(echo "${release_tag}" | sed 's/\./\\./g')
          if git ls-remote --tags origin | grep -q "refs/tags/${release_tag_escaped}$"; then
            echo "::error::Tag ${release_tag} already exists."
            exit 1
            fi
          fi

      - name: Generate archives
        id: archive
        run: |
          filebase=cccl-install-${release_tag}
          prefix=${filebase}

          echo "::group::Configuring install"
          cmake --preset install -DCMAKE_INSTALL_PREFIX=${prefix}
          echo "::endgroup::"

          echo "::group::Installing"
          pushd build/install
          cmake --install .
          popd
          echo "::endgroup::"

          mkdir archives
          tarball=${PWD}/archives/${filebase}.tar.gz
          zipfile=${PWD}archives/${filebase}.zip

          echo "::group::Archiving: ${tarball}"
          tar -cvzf ${tarball} -C ${prefix} .
          echo "::endgroup::"

          echo "::group::Archiving: ${zipfile}"
          pushd ${prefix}
          zip -rv9 ${zipfile} .
          popd
          echo "::endgroup::"

      - name: Tag
        run: |
          git tag ${release_tag} ${rc_tag}
          git push origin ${release_tag}
          echo "Tagged release ${release_tag} from ${rc_tag}." | tee -a $GITHUB_STEP_SUMMARY

      - name: Draft Github Release
        run: |
          gh release create ${release_tag} \
            --draft \
            --generate-notes \
            --title "${release_tag}" \
            "archives/cccl-install-${release_tag}.zip#Install Tree (zip)" \
            "archives/cccl-install-${release_tag}.tar.gz#Install Tree (tar.gz)"
